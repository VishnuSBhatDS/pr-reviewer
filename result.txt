Question: how do we sync minimart orders ?


ðŸŸ¦ SERVICE: UnknownService
======================================================================

ðŸ“„ FILE: CartOrderPrivateController.java

--- CartOrderPrivateController | minimartOrderSync | CODE | 1/1 ---
    @PostMapping(value = "/v1/minimart-order-sync")
    public ResponseEntity<?> minimartOrderSync(@RequestBody OrderSyncRequestModel orderSyncRequestModel){
        return new ResponseEntity<>(myOrderService.minimartOrderSync(orderSyncRequestModel), HttpStatus.OK);


ðŸ“„ FILE: InventoryPassbookServiceImpl.java

--- InventoryPassbookServiceImpl | updateFailedPassbookStatus | CODE | 1/1 ---
	@Transactional(transactionManager = AppConstants.IMS_TRANSACTION_MANAGER_NAME)
	public void updateFailedPassbookStatus() {
		LocalDateTime targetDate = LocalDateTime.now().minusDays(AppConstants.INT_THREE);
		Optional<InventoryPassbook> minInvoiceData = inventoryPassbookReadRepo.findFirstRecordByCreatedDateGreaterThanOrEqualTo(targetDate);
		Long minId = minInvoiceData.isPresent() ? minInvoiceData.get().getId() : AppConstants.LONG_ZERO;
		int totUpdated = inventoryPassbookRepository.updateFailedInvoiceStatus(PassbookInvoiceStatus.TO_BE_PICKED.getStatus(), minId);

--- InventoryPassbookServiceImpl | updatePendingInvoiceStatus | CODE | 1/1 ---
	@Transactional(transactionManager = AppConstants.IMS_TRANSACTION_MANAGER_NAME)
	public void updatePendingInvoiceStatus() {
		LocalDateTime targetDate = LocalDateTime.now().minusDays(AppConstants.INT_FIVE);
		Optional<InventoryPassbook> minInvoiceData = inventoryPassbookReadRepo.findFirstRecordByCreatedDateGreaterThanOrEqualTo(targetDate);
		Long minId = minInvoiceData.isPresent() ? minInvoiceData.get().getId() : AppConstants.LONG_ZERO;
		int totUpdated = inventoryPassbookRepository.updatePendingInvoiceStatus(PassbookInvoiceStatus.TO_BE_PICKED.getStatus(), minId);


ðŸ“„ FILE: KafkaProducer.java

--- KafkaProducer | sendOrdersStatusUpdateTopic | CODE | 1/1 ---
    @Async
    @Override
    public void sendOrdersStatusUpdateTopic(OrdersStatusUpdateEvent ordersStatusUpdateEvent) {
        try {

--- KafkaProducer | sendOrderPlacedUserSMSCommunicationEvent | CODE | 1/1 ---
    @Async
    @Override
    public void sendOrderPlacedUserSMSCommunicationEvent(OrderUpdateEventDetail orderUpdateEventDetail) {
        try {


ðŸ“„ FILE: ImsSyncServiceImpl.java

--- ImsSyncServiceImpl | externalOrderDispatch | CODE | 1/1 ---
    @Override
    @Transactional(transactionManager = "transactionManager", rollbackFor = {Exception.class, InventoryException.class})
    public Object externalOrderDispatch(SyncDTO syncDTO) throws InventoryException, JsonProcessingException {
        List<WarehouseSkuInventory> warehouseSkuInventories = new ArrayList<>();
        // needs to validate warehouseId and sku list is not empty
        for (SkuSyncDTO sku:syncDTO.getData()){
            WarehouseSkuInventory warehouseSkuInventory = cacheService.get(syncDTO.getWarehouse_id(), sku.getSku_id(),true);
            int updates = 0;
            if(sku.getLooseInventory() != null)
                updates = warehouseSkuInventoryRepo.updateWarehouseInventoryWithLoose(syncDTO.getWarehouse_id(), sku.getSku_id(), sku.getSku_quantity(), sku.getLooseInventory());
            else
                updates = warehouseSkuInventoryRepo.updateWarehouseInventory(syncDTO.getWarehouse_id(), sku.getSku_id(), sku.getSku_quantity());
            if(updates < AppConstants.INT_ONE) {
                cacheService.flushSku(syncDTO.getWarehouse_id(), sku.getSku_id());
                throw new InventoryException("Error while update sku : " + sku.getSku_id());
            }
            logSyncInventoryHistory(syncDTO.getType(), sku.getSku_quantity(),warehouseSkuInventory, syncDTO.getRequest_id(), syncDTO.getSub_type());
            if(!syncDTO.getSub_type().equals("pos_update"))
                warehouseSkuInventory.setUpdateAvailableInv(utilityService.calculateUpdateAvailableInventory(sku.getSku_quantity(), AppConstants.INT_ZERO, AppConstants.INT_ZERO));
            warehouseSkuInventories.add(warehouseSkuInventory);
        }
        addDealExpiryStatusInQueue(warehouseSkuInventories, syncDTO.getType());

        for (SkuSyncDTO sku:syncDTO.getData())
            cacheService.updateInventoryCountCache(syncDTO.getWarehouse_id(), sku.getSku_id(),sku.getSku_quantity());
        return true;

--- ImsSyncServiceImpl | logSyncInventoryHistory | CODE | 1/1 ---
    private void logSyncInventoryHistory(String type, int requestedInventory, WarehouseSkuInventory warehouseSkuInventory, String requestId, String subType){
        InventorySyncHistory history = new InventorySyncHistory();
        history.setType(type);
        history.setStnType(subType);
        history.setRequestId(requestId);
        history.setSku(warehouseSkuInventory.getSkuId());
        history.setWarehouseId(warehouseSkuInventory.getWarehouseEntitiesId());

        if (type.equals(AppConstants.TYPE_SYNC_DELIVER_ORDER)) {
            history.setNewInventory(warehouseSkuInventory.getInventory());
        } else {
            history.setNewInventory(warehouseSkuInventory.getInventory() + requestedInventory);
        }

        history.setRequestedInventory(requestedInventory);
        history.setPrevInventory(warehouseSkuInventory.getInventory());
        history.setPrevInventorySold(warehouseSkuInventory.getInventorySold());
        history.setPrevDamage(warehouseSkuInventory.getDamage());
        inventorySyncHistoryRepo.saveAndFlush(history);

--- ImsSyncServiceImpl | reconSync | CODE | 1/1 ---
    @Override
    @Transactional(transactionManager = "transactionManager", rollbackFor = {Exception.class, InventoryException.class})
    public Object reconSync(SyncDTO syncDTO) throws InventoryException, JsonProcessingException {

        inventorySyncHistoryRepo.findByTypeAndStnTypeAndRequestIdAndSkuAndWarehouseId(syncDTO.getType(),syncDTO.getSub_type(), syncDTO.getRequest_id(),syncDTO.getData().get(AppConstants.INT_ZERO).getSku_id(),syncDTO.getWarehouse_id());
        List<WarehouseSkuInventory> warehouseSkuInventories = new ArrayList<>();
        for(SkuSyncDTO sku:syncDTO.getData()){
            WarehouseSkuInventory warehouseSkuInventory = cacheService.get(syncDTO.getWarehouse_id(), sku.getSku_id());
            int updates = warehouseSkuInventoryRepo.updateWarehouseInventory(syncDTO.getWarehouse_id(), sku.getSku_id(), sku.getInventory());
            if(updates < AppConstants.INT_ONE)
                throw new InventoryException("Error while update sku : "+sku.getSku_id());
            logSyncInventoryHistory(syncDTO.getType(), sku.getInventory(),warehouseSkuInventory, syncDTO.getRequest_id(), syncDTO.getSub_type());
            warehouseSkuInventory.setUpdateAvailableInv(utilityService.calculateUpdateAvailableInventory(sku.getInventory(), AppConstants.INT_ZERO, AppConstants.INT_ZERO));
            warehouseSkuInventories.add(warehouseSkuInventory);
        }

        addDealExpiryStatusInQueue(warehouseSkuInventories, syncDTO.getType());

        for (SkuSyncDTO sku:syncDTO.getData())
            cacheService.updateInventoryCountCache(syncDTO.getWarehouse_id(), sku.getSku_id(),sku.getInventory());
        return true;

--- ImsSyncServiceImpl | updateAvailableInventory | CODE | 1/1 ---
    private void updateAvailableInventory(WarehouseSkuInventory warehouseSkuInventory, OmsSyncDTO syncDTO, OmsSkuSyncDTO sku) {
        if (syncDTO.getRequestType().toUpperCase().equals(OmsRequestTypes.INVENTORY_UPDATE.getValue())) {


ðŸ“„ FILE: InventoryServiceImpl.java

--- InventoryServiceImpl | getInventoryHistoryByCenterAndDate | CODE | 1/1 ---
    @Override
    public List<InventoryHistory> getInventoryHistoryByCenterAndDate(Long inventoryCenterId, Date startDate, Date endDate) {

        startDate = addTimeToDate(startDate,0,0,0);
        endDate = addTimeToDate(endDate,23,59,59);

        return inventoryHistoryRepo.findByInventoryCenterIdAndTypeAndSubTypeAndCreatedDate(inventoryCenterId,"minimart","request_create_ds",startDate,endDate);

--- InventoryServiceImpl | reverseUpdate | CODE | 1/1 ---
    @Transactional(transactionManager = "transactionManager", rollbackFor = {Exception.class, InventoryException.class})
    @Override
    public void reverseUpdate(InventoryDTO inventoryDTO) throws InventoryException {
        Map<String,WarehouseSkuInventory> map = new HashMap<>();
        List<WarehouseSkuInventory> warehouseSkuInventories = new ArrayList<>();
        try {
            for (SkuInventoryDTO skuInventory: inventoryDTO.getSkuList()){
                WarehouseSkuInventory warehouseSkuInventory = cacheService.get(skuInventory.getWarehouse_entities_id(), skuInventory.getSku_id(), true);
                warehouseSkuInventory.setUpdateAvailableInv(-(utilityService.calculateUpdateAvailableInventory(skuInventory.getInventory() + skuInventory.getVirtual_inventory(),skuInventory.getStn_intransit_order() , skuInventory.getInventory_sold())));

                warehouseSkuInventories.add(warehouseSkuInventory);
                map.put(skuInventory.getWarehouse_entities_id()+skuInventory.getSku_id(),cacheService.get(skuInventory.getWarehouse_entities_id(), skuInventory.getSku_id(), true));
                warehouseSkuInventoryRepo.reverseUpdateSoldInventory(skuInventory.getWarehouse_entities_id(), skuInventory.getSku_id(), skuInventory.getInventory(), skuInventory.getInventory_sold(), skuInventory.getBtoc_sold(), skuInventory.getBtob_sold() ,
                        skuInventory.getStn_intransit_inventory(), skuInventory.getVirtual_inventory() , skuInventory.getStn_intransit_order() , skuInventory.getDelivered_inventory() , skuInventory.getDamage());
            }

            for (SkuInventoryDTO skuInventory: inventoryDTO.getSkuList())
                cacheService.revertUpdate(skuInventory);

        } catch (Exception e) {
            Map<String, String> sendEmailMap = new HashMap<>();
            sendEmailMap.put(AppConstants.TO, AppConstants.EMAIL);
            sendEmailMap.put(AppConstants.SUBJECT, "Inventory compensate Api failed Alert");
            try {
                e.printStackTrace();
                sendEmailMap.put(AppConstants.CONTENT, "Error occurred in Inventory compensate api, payload =:  " + mapper.writeValueAsString(inventoryDTO));
                chatServiceClient.sendEmail(sendEmailMap);
                sendEmailMap.put(AppConstants.SUBJECT, "Inventory compensate error detail ");
                sendEmailMap.put(AppConstants.CONTENT, getPrintStackTrace(e));
                chatServiceClient.sendEmail(sendEmailMap);
            } catch (JsonProcessingException ex) {
                ex.printStackTrace();
            }
            throw new InventoryException("Inventory compensate Api failed");
        }
        utilityService.logUpdateRequest(inventoryDTO,map,"revert");
        imsSyncService.addDealExpiryStatusInQueue(warehouseSkuInventories, AppConstants.REVERSE_UPDATE);

--- InventoryServiceImpl | reverseUpdateSync | CODE | 1/1 ---
    @Transactional(transactionManager = "transactionManager", rollbackFor = {Exception.class, InventoryException.class})
    @Override
    public void reverseUpdateSync(InventoryDTO inventoryDTO) throws InventoryException {
        Map<String,WarehouseSkuInventory> map = new HashMap<>();
        List<WarehouseSkuInventory> warehouseSkuInventories = new ArrayList<>();
        try{
            for (SkuInventoryDTO skuInventory: inventoryDTO.getSkuList()){
                WarehouseSkuInventory warehouseSkuInventory = cacheService.get(skuInventory.getWarehouse_entities_id(), skuInventory.getSku_id(), true);
                warehouseSkuInventory.setUpdateAvailableInv(utilityService.calculateUpdateAvailableInventory(skuInventory.getInventory() + skuInventory.getVirtual_inventory(),skuInventory.getStn_intransit_order() , skuInventory.getInventory_sold()));

                warehouseSkuInventories.add(warehouseSkuInventory);

                map.put(skuInventory.getWarehouse_entities_id()+skuInventory.getSku_id(),cacheService.get(skuInventory.getWarehouse_entities_id(), skuInventory.getSku_id(), true));
                warehouseSkuInventoryRepo.reverseUpdateSoldInventory(skuInventory.getWarehouse_entities_id(), skuInventory.getSku_id(), skuInventory.getInventory(), skuInventory.getInventory_sold(), skuInventory.getBtoc_sold(), skuInventory.getBtob_sold() ,
                        skuInventory.getStn_intransit_inventory(), skuInventory.getVirtual_inventory() , skuInventory.getStn_intransit_order() , skuInventory.getDelivered_inventory() , skuInventory.getDamage());
            }
            warehouseSkuInventoryRepo.flush();
            for (SkuInventoryDTO skuInventory: inventoryDTO.getSkuList())
                cacheService.revertUpdate(skuInventory);

    } catch (Exception e) {
            Map<String, String> sendEmailMap = new HashMap<>();
            sendEmailMap.put(AppConstants.TO, AppConstants.EMAIL);
            sendEmailMap.put(AppConstants.SUBJECT, "Inventory compensate error detail ");
            e.printStackTrace();
            sendEmailMap.put(AppConstants.CONTENT, getPrintStackTrace(e));
            chatServiceClient.sendEmail(sendEmailMap);
        }
        utilityService.logUpdateRequest(inventoryDTO,map,"revert");
        imsSyncService.addDealExpiryStatusInQueue(warehouseSkuInventories,AppConstants.REVERSE_UPDATE);

--- InventoryServiceImpl | updateInventory | CODE | 6/7 ---

                        InventoryPassbook inventoryPassbookUpdate =
                            createInventoryPassbook(updatedInventoryManage, updateInventoryRequest,
                                skuQuantityModel);
                        DTOUtils.updatePassbookDateToCurrentTimeIfNotExists(
                            inventoryPassbookUpdate);
                        inventoryPassbookService.savePassbookData(inventoryPassbookUpdate);

                    }
                    else {
                        throw new BadRequestException("Sku not found");
                    }
                } catch (Exception ex) {
                    throw ex;
                }
            }

            inventoryHistoryRepo.saveAll(updatedInventoryManageHistoryList);
            inventoryPassbookRepo.saveAll(updateInventoryPassbookList);
            inventoryUpdateManageRepo.saveAll(updateInventoryUpdateManageList);
            syncDTO.setData(syncDTODataList);

            try {

                // OMS SYNC
                if (Objects.isNull(updateInventoryRequest.getIsAsync())) {
                    updateInventoryRequest.setIsAsync(Boolean.FALSE);
                }
                if (updateInventoryRequest.getIsAsync()) {
                    inventoryUpdateSqsPublisher.sendMessage(objectMapper.writeValueAsString(syncDTO), updateInventoryRequest.getSkuQuantities().size() > UPDATE_INV_COMPRESSION_LIMIT);
                } else {
                    imsSyncService.omsInventorySync(syncDTO);
                }

            } catch (Exception e) {
                log.error("Error occurred while syncing inventory in ims and oms with request id {} . ErrorMsg: {} ", updateInventoryRequest.getRequestId(),e.getMessage());

                // reSync cache data in case of rollback
                cacheService.asyncUpdateInventoryCountCache(syncDTO, Boolean.TRUE);

                try {
                    log.error("This payload failed in oms update process: " +objectMapper.writeValueAsString(updateInventoryRequest));
                } catch (JsonProcessingException ex) {
                    log.error("Object mapper failed. This payload failed in oms update process: {}", updateInventoryRequest);
                }

                throw new RuntimeException(String.format("Error occurred while syncing inventory in ims and oms with request id %s . ErrorMsg: %s ", updateInventoryRequest.getRequestId(),e.getMessage()));
            }
            return null;
        });


ðŸ“„ FILE: ImsSyncController.java

--- ImsSyncController | rvpSync | CODE | 1/1 ---
    @PostMapping("rvp")
    private ResponseEntity<?> rvpSync(@RequestBody SyncDTO syncDTO,
                                      @RequestParam(value = "isAsync", defaultValue = "0", required = false) boolean isAsync) throws InventoryException, JsonProcessingException {
        // Using same functionality of external order dispatch to sync RVP
        if(!Optional.ofNullable(syncDTO.getType()).isPresent())
            syncDTO.setType("RVP");
        if(isAsync)

--- ImsSyncController | externalOrderDispatch | CODE | 1/1 ---
    @PostMapping("external-order-dispatch")
    private ResponseEntity<?> externalOrderDispatch(@RequestBody SyncDTO syncDTO,
                                                    @RequestParam(value = "isAsync", defaultValue = "0", required = false) boolean isAsync) throws InventoryException, JsonProcessingException {
        if(!Optional.ofNullable(syncDTO.getType()).isPresent())
            syncDTO.setType("EXTERNAL-ORDER-DISPATCH");
        if(isAsync)

--- ImsSyncController | rtvSync | CODE | 1/1 ---
    @PostMapping("rtv")
    private ResponseEntity<?> rtvSync(@RequestBody RtvDTO rtvDTO,
                                      @RequestParam(value = "isAsync", defaultValue = "0", required = false) boolean isAsync) throws InventoryException, JsonProcessingException {
        // Using same functionality of external order dispatch to sync RVP
        if(isAsync)

--- ImsSyncController | cycleCountSync | CODE | 1/1 ---
    @PostMapping("cycle-count")
    private ResponseEntity<?> cycleCountSync(@RequestBody SyncDTO syncDTO,
                                      @RequestParam(value = "isAsync", defaultValue = "0", required = false) boolean isAsync) throws InventoryException, JsonProcessingException {
        // Using same functionality of external order dispatch to sync RVP
//        log.error("Request recieved in cycle-count api {}", syncDTO);
        if(!Optional.ofNullable(syncDTO.getType()).isPresent())
            syncDTO.setType("CYCLE_COUNT");
        if(isAsync)


ðŸ“„ FILE: PaymentServiceImplV3.java

--- PaymentServiceImplV3 | paymentDetailsBreakUp | CODE | 2/2 ---
            martOrderPayment.setOrderId(orderDetail.getId());
            martOrderPayment.setAmount(orderDetail.getAmount());
            martOrderPayment.setBilledAmount(orderDetail.getBilledAmount());
            martOrderPayment.setDiscountAmount(orderDetail.getDiscountAmount());
            martOrderPayment.setOrderDiscountModels(Objects.nonNull(orderDetailsResponseModel.getOrderDiscountingDetails())
                    ? orderDetailsResponseModel.getOrderDiscountingDetails().getDiscountingHistoryDetails() : Collections.emptyList());

            if (orderDetail.getSource().equalsIgnoreCase("Minimart") && orderPaymentDetail.size() > 0) {
                Double voucherAmount = orderPaymentDetail.stream().filter(paymentInitDetailsEntity ->
                                PaymentModes.VOUCHER.getType().equalsIgnoreCase(paymentInitDetailsEntity.getPaymentMode()))
                        .mapToDouble(PaymentInitDetailsEntity::getAmount).sum();

                Double creditNote = orderPaymentDetail.stream().filter(paymentInitDetailsEntity ->
                                PaymentModes.CREDIT_NOTE.getType().equalsIgnoreCase(paymentInitDetailsEntity.getPaymentMode()))
                        .mapToDouble(PaymentInitDetailsEntity::getAmount).sum();

                Double cash = orderPaymentDetail.stream().filter(paymentInitDetailsEntity ->
                                PaymentModes.CASH.getType().equalsIgnoreCase(paymentInitDetailsEntity.getPaymentMode()))
                        .mapToDouble(PaymentInitDetailsEntity::getAmount).sum();

                Double online = orderPaymentDetail.stream().filter(paymentInitDetailsEntity ->
                                !PaymentModes.CASH.getType().equalsIgnoreCase(paymentInitDetailsEntity.getPaymentMode()))
                        .filter(paymentInitDetailsEntity ->
                                !PaymentModes.CREDIT_NOTE.getType().equalsIgnoreCase(paymentInitDetailsEntity.getPaymentMode()))
                        .filter(paymentInitDetailsEntity ->
                                !PaymentModes.VOUCHER.getType().equalsIgnoreCase(paymentInitDetailsEntity.getPaymentMode()))
                        .mapToDouble(PaymentInitDetailsEntity::getAmount).sum();
                martOrderPayment.setVoucher(voucherAmount.floatValue());
                martOrderPayment.setOnline(online.floatValue());
                martOrderPayment.setCash(cash.floatValue());
                martOrderPayment.setCreditNote(creditNote.floatValue());
            } else {
                if (orderDetail.getPaymentType().equalsIgnoreCase(PaymentModes.COD.getType())) {
                    martOrderPayment.setCash(orderDetail.getAmount());
                } else {
                    martOrderPayment.setOnline(orderDetail.getAmount());
                }
            }
            responseModel.add(martOrderPayment);
        }
        return responseModel;


ðŸ“„ FILE: ExpressDeliveryServiceImpl.java

--- ExpressDeliveryServiceImpl | syncOrdersToIms | CODE | 1/1 ---
    private void syncOrdersToIms(List<DealLevelPromotion> cartItems, long warehouseId) {
        List<Long> orderIds = cartItems.stream().filter(cartItem ->
                cartItem.getDeliveryType().equalsIgnoreCase(DeliveryType.EXPRESS.name()))
                .map(DealLevelPromotion::getOrderPKId).collect(Collectors.toList());
        OrderPushToImsRequest orderPushToImsRequest = new OrderPushToImsRequest();
        orderPushToImsRequest.setWarehouseId(warehouseId);
        orderPushToImsRequest.setOrderIds(orderIds);
        orderPushToImsRequest.setDeliveryType(DeliveryType.EXPRESS.name());
        try {


ðŸ“„ FILE: MyOrderServiceImpl.java

--- MyOrderServiceImpl | minimartOrderSync | CODE | 1/2 ---
    public OrderSyncResponseModel minimartOrderSync(OrderSyncRequestModel orderSyncRequestModel) {

        List<UserOrderSyncModel> userOrderSyncModelList = orderSyncRequestModel.getUserOrderSyncModelList();
        
        List<String> posOrderIds = userOrderSyncModelList.stream()
                .map(UserOrderSyncModel::getPosOrderId)
                .filter(Objects::nonNull)
                .distinct()
                .collect(Collectors.toList());
        
        List<String> acquiredLocks = new ArrayList<>();
        try {
            for (String posOrderId : posOrderIds.stream().sorted().collect(Collectors.toList())) {
                String lockKey = MINIMART_ORDER_SYNC_LOCK + posOrderId;
                acquireLock(lockKey, posOrderId);
                acquiredLocks.add(lockKey);
            }
        } catch (Exception e) {
            // Release all acquired locks if any lock acquisition fails
            releaseLocks(acquiredLocks);
            throw e;
        }

        OrderSyncResponseModel orderSyncResponseModel = new OrderSyncResponseModel();
        Map<String, List<OrderDealMappingModel>> posOrderOmsOrderMap = new HashMap<>();
        Map<String, String> ordersSyncStatusMap = new HashMap<>();

        List<String> posOrderIdList = userOrderSyncModelList.stream()
                .map(UserOrderSyncModel::getPosOrderId)
                .collect(Collectors.toList());

        List<POSOrderMapping> posOrderMappingList = posOrderMappingRepository.findByPosOrderIdIn(posOrderIdList);

        Set<String> posOrderIdSet = posOrderMappingList.stream()
                .map(POSOrderMapping::getPosOrderId)
                .collect(Collectors.toSet());

        List<UserOrderSyncModel> existingUserOrderSyncModelList = userOrderSyncModelList.stream()
                .filter(userOrderSyncModel -> posOrderIdSet.contains(userOrderSyncModel.getPosOrderId()))
                .collect(Collectors.toList());

        Map<String, List<POSOrderMapping>> posOrderMappingMap = posOrderMappingList.stream()
                .collect(Collectors.groupingBy(POSOrderMapping::getPosOrderId));

        posOrderIdSet.clear();

        for(UserOrderSyncModel userOrderSyncModel : existingUserOrderSyncModelList) {
            List<POSOrderMapping> posOrderMappings = posOrderMappingMap.get(userOrderSyncModel.getPosOrderId());

            List<OrderDealMappingModel> orderDealMappingModelList = getOrderDealMappingForExistingOrder(posOrderMappings,


ðŸ“„ FILE: InventoryUpdateMapper.java

--- InventoryUpdateMapper | updateInventory | CODE | 1/1 ---
    public WarehouseSkuInventory updateInventory(WarehouseSkuInventory warehouseSkuInventory, SkuInventoryDTO skuInventoryDTO){
        warehouseSkuInventory.setInventory(warehouseSkuInventory.getInventory()+skuInventoryDTO.getInventory());
        warehouseSkuInventory.setInventorySold(warehouseSkuInventory.getInventorySold()+skuInventoryDTO.getInventory_sold());;
        warehouseSkuInventory.setBtocSold(warehouseSkuInventory.getBtocSold()+skuInventoryDTO.getBtoc_sold());
        warehouseSkuInventory.setBtobSold(warehouseSkuInventory.getBtobSold()+skuInventoryDTO.getBtob_sold());
        warehouseSkuInventory.setStnIntransitInventory(warehouseSkuInventory.getStnIntransitInventory()+skuInventoryDTO.getStn_intransit_inventory());
        warehouseSkuInventory.setVirtualInventory(warehouseSkuInventory.getVirtualInventory()+skuInventoryDTO.getVirtual_inventory());
        warehouseSkuInventory.setStnIntransitOrder(warehouseSkuInventory.getStnIntransitOrder()+ skuInventoryDTO.getStn_intransit_order());
        warehouseSkuInventory.setDeliveredInventory(warehouseSkuInventory.getDeliveredInventory()+skuInventoryDTO.getDelivered_inventory());
        warehouseSkuInventory.setDamage(warehouseSkuInventory.getDamage()+skuInventoryDTO.getDamage());
        warehouseSkuInventory.setModifiedDate(new Date());
        return warehouseSkuInventory;

--- InventoryUpdateMapper | revertInventory | CODE | 1/1 ---
    public WarehouseSkuInventory revertInventory(WarehouseSkuInventory warehouseSkuInventory, SkuInventoryDTO skuInventoryDTO){
        warehouseSkuInventory.setInventory(warehouseSkuInventory.getInventory()-skuInventoryDTO.getInventory());
        warehouseSkuInventory.setInventorySold(warehouseSkuInventory.getInventorySold()-skuInventoryDTO.getInventory_sold());;
        warehouseSkuInventory.setBtocSold(warehouseSkuInventory.getBtocSold()-skuInventoryDTO.getBtoc_sold());
        warehouseSkuInventory.setBtobSold(warehouseSkuInventory.getBtobSold()-skuInventoryDTO.getBtob_sold());
        warehouseSkuInventory.setStnIntransitInventory(warehouseSkuInventory.getStnIntransitInventory()-skuInventoryDTO.getStn_intransit_inventory());
        warehouseSkuInventory.setVirtualInventory(warehouseSkuInventory.getVirtualInventory()-skuInventoryDTO.getVirtual_inventory());
        warehouseSkuInventory.setStnIntransitOrder(warehouseSkuInventory.getStnIntransitOrder()- skuInventoryDTO.getStn_intransit_order());
        warehouseSkuInventory.setDeliveredInventory(warehouseSkuInventory.getDeliveredInventory()-skuInventoryDTO.getDelivered_inventory());
        warehouseSkuInventory.setDamage(warehouseSkuInventory.getDamage()-skuInventoryDTO.getDamage());
        warehouseSkuInventory.setModifiedDate(new Date());
        return warehouseSkuInventory;

--- InventoryUpdateMapper | cacheUpdateInventory | CODE | 1/1 ---
    public WarehouseSkuInventory cacheUpdateInventory(WarehouseSkuInventory warehouseSkuInventory, OmsSkuSyncDTO skuInventoryDTO){
        warehouseSkuInventory.setInventory(warehouseSkuInventory.getInventory()+skuInventoryDTO.getInventory());
        warehouseSkuInventory.setInventorySold(warehouseSkuInventory.getInventorySold()+skuInventoryDTO.getInventorySold());
        warehouseSkuInventory.setBtocSold(warehouseSkuInventory.getBtocSold()+skuInventoryDTO.getBtocSold());
        warehouseSkuInventory.setStnIntransitInventory(warehouseSkuInventory.getStnIntransitInventory()+skuInventoryDTO.getStnIntransitInventory());
        warehouseSkuInventory.setVirtualInventory(warehouseSkuInventory.getVirtualInventory()+skuInventoryDTO.getVirtualInventory());
        warehouseSkuInventory.setStnIntransitOrder(warehouseSkuInventory.getStnIntransitOrder()+ skuInventoryDTO.getStnIntransitInventoryOrder());
        warehouseSkuInventory.setDeliveredInventory(warehouseSkuInventory.getDeliveredInventory()+skuInventoryDTO.getDeliveredInventory());
        warehouseSkuInventory.setDamage(warehouseSkuInventory.getDamage()+skuInventoryDTO.getDamage());
        warehouseSkuInventory.setLooseInventory(warehouseSkuInventory.getLooseInventory()+ skuInventoryDTO.getLooseInventory());
        warehouseSkuInventory.setModifiedDate(new Date());
        return warehouseSkuInventory;


ðŸ“„ FILE: CacheServiceImpl.java

--- CacheServiceImpl | asyncUpdateInventoryCountCache | CODE | 1/1 ---
    @Override
    @Async
    public void asyncUpdateInventoryCountCache(SyncDTO syncDTO, Boolean reSyncData) {
        List<WarehouseSkuInventory> warehouseSkuInventories = new ArrayList<>();
        for (SkuSyncDTO sku : syncDTO.getData()) {
            try {
                if (AppConstants.IS_CACHE_ENABLED) {
                    // If cache enable
//            flushSku(warehouseId, skuId);
                    Optional<WarehouseSkuInventory> entity = warehouseSkuInventoryReadRepo.findBySkuIdAndWarehouseEntitiesId(sku.getSku_id(), sku.getWarehouseId());
                    if (entity.isPresent() && !reSyncData) {
                        create(inventoryUpdateMapper.omsCacheUpdateInventory(entity.get(), sku));
                    } else if (entity.isPresent() && reSyncData){
                        create(entity.get());
                    }

                    entity.ifPresent(warehouseSkuInventories::add);
                }
            } catch (Exception ex) {
                log.error("omsInventorySync - asyncUpdateInventoryCountCache while updating cache with SKU {}", sku);
            }
        }
        asyncService.asyncAddDealExpiryStatusInQueue(warehouseSkuInventories, syncDTO.getType());


ðŸ“„ FILE: InventoryController.java

--- InventoryController | reverseUpdateSync | CODE | 1/1 ---
    @PostMapping("/compensate-sync")
    private ResponseEntity<?> reverseUpdateSync(@RequestBody InventoryDTO inventoryDTO) throws JsonProcessingException, InventoryException {
        inventoryService.reverseUpdateSync(inventoryDTO);
        return sendSuccessResponse(true);


ðŸ“„ FILE: EtaServiceImpl.java

--- EtaServiceImpl | updateOrderStatusWidgetCacheAsync | CODE | 1/1 ---
    @Async
    public CompletableFuture<Void> updateOrderStatusWidgetCacheAsync(List<OrderStatusWidgetCacheUpdateModel> orderStatusWidgetCacheUpdateModelList) {
        orderServiceClient.updateOrderStatusWidgetCache(orderStatusWidgetCacheUpdateModelList);
        return CompletableFuture.completedFuture(null);


ðŸ“„ FILE: UtilityServiceImpl.java

--- UtilityServiceImpl | postWarehouseExpiryUpdateStn | CODE | 1/1 ---
    @Async
    @Override
    public void postWarehouseExpiryUpdateStn(SyncDTO stnHoldRequestDTO, int stnWarehouseId, Map<String, WarehouseSkuInventory> warehouseSkuInventoryMap) throws InventoryException {
        try {


ðŸ“„ FILE: ExpressDeliveryServiceImplTest.java

--- ExpressDeliveryServiceImplTest | testOrderSyncException | TEST | 1/1 ---
    @Test
    public void testOrderSyncException() throws Exception {
        // We need to access the private syncOrdersToIms method
        Method syncOrdersToImsMethod = ExpressDeliveryServiceImpl.class.getDeclaredMethod(
            "syncOrdersToIms", List.class, long.class);
        syncOrdersToImsMethod.setAccessible(true);
        
        // Create test data
        List<DealLevelPromotion> cartItems = new ArrayList<>();
        DealLevelPromotion item1 = new DealLevelPromotion();
        item1.setDeliveryType(DeliveryType.EXPRESS.name());
        item1.setOrderPKId(101L);
        
        DealLevelPromotion item2 = new DealLevelPromotion();
        item2.setDeliveryType(DeliveryType.EXPRESS.name());
        item2.setOrderPKId(102L);
        
        cartItems.add(item1);
        cartItems.add(item2);
        
        // Mock the orderServiceClient to throw an exception
        when(orderServiceClient.syncOrderService(any()))
            .thenThrow(new RuntimeException("Sync Failed"));
        
        // Invoke the private method
        syncOrdersToImsMethod.invoke(expressDeliveryService, cartItems, 1001L);
        
        // Verify that orderServiceClient was called with an OrderPushToImsRequest 
        // containing the correct order IDs and warehouse ID
        ArgumentCaptor<OrderPushToImsRequest> requestCaptor = ArgumentCaptor.forClass(OrderPushToImsRequest.class);
        verify(orderServiceClient).syncOrderService(requestCaptor.capture());
        
        OrderPushToImsRequest capturedRequest = requestCaptor.getValue();
        assertEquals(Long.valueOf(1001L), capturedRequest.getWarehouseId());
        assertEquals(DeliveryType.EXPRESS.name(), capturedRequest.getDeliveryType());
        assertEquals(2, capturedRequest.getOrderIds().size());
        assertTrue(capturedRequest.getOrderIds().contains(101L));
        assertTrue(capturedRequest.getOrderIds().contains(102L));


ðŸ“„ FILE: V1UserPhoneCartIdTest.java

--- V1UserPhoneCartIdTest | testFetchEtaForOrders_IndividualOrderParseException | TEST | 1/2 ---
    @Test
    public void testFetchEtaForOrders_IndividualOrderParseException() throws Exception {
        // Arrange
        List<Long> orderIds = Arrays.asList(101L, 102L);
        
        // Create warehouse delivery ETAs
        List<WarehouseDeliveryEtaEntity> etaEntities = new ArrayList<>();
        
        // Create ETA for order 101 (with valid date)
        WarehouseDeliveryEtaEntity eta1 = new WarehouseDeliveryEtaEntity();
        eta1.setId(1L);
        eta1.setOrderId(101L);
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        Date deliveryDate1 = sdf.parse("2025-01-01");
        eta1.setDeliveryDate(deliveryDate1);
        
        // Create ETA for order 102 
        WarehouseDeliveryEtaEntity eta2 = new WarehouseDeliveryEtaEntity();
        eta2.setId(2L);
        eta2.setOrderId(102L);
        Date deliveryDate2 = sdf.parse("2025-01-02"); // Use a valid date, we'll mock the exception
        eta2.setDeliveryDate(deliveryDate2);
        
        etaEntities.add(eta1);
        etaEntities.add(eta2);
        
        // Mock repository response
        when(warehouseEtaDeliveryRepository.findAllByOrderIdInOrderByDeliveryDateDesc(orderIds))
            .thenReturn(Optional.of(etaEntities));
        
        // Create a partial mock of EtaServiceImpl to capture and validate the calls
        EtaServiceImpl spyEtaService = spy(new EtaServiceImpl());
        ReflectionTestUtils.setField(spyEtaService, "warehouseEtaDeliveryRepository", warehouseEtaDeliveryRepository);
        
        // Make order 101 format successfully
        doReturn("01 January, 2025").when(spyEtaService).fetchEtaForOrder(101L);
        
        // Make order 102 format throw exception - return empty string instead of null
        doReturn("").when(spyEtaService).fetchEtaForOrder(102L);
        
        // Make cart level ETA format successfully
        doReturn("01 January, 2025").when(spyEtaService).fetchEtaForOrder(CART_LEVEL_ETA);
        
        // Act
        Map<Long, String> result = spyEtaService.fetchEtaForOrders(orderIds);
        
        // Assert
        assertNotNull(result);
        assertEquals(3, result.size());  // All entries are included in the result map
        assertTrue(result.containsKey(101L));  // Order 101 has a valid date


ðŸ“„ FILE: MyOrderServiceImplTest.java

--- MyOrderServiceImplTest | createTestOrders | TEST | 1/1 ---
    private List<Order> createTestOrders() {
        List<Order> orders = new ArrayList<>();

        Order order1 = new Order();
        order1.setId(1L);
        order1.setOrderId("ORDER001");
        order1.setOfferId("OFFER001");
        order1.setOrderStatus("delivered");
        order1.setOrderType("normal");
        order1.setSource("B2C");
        order1.setPhone(phoneNumber);
        order1.setAmount(100.00);
        order1.setBilledAmount(100.00);
        order1.setQuantity(1L);
        order1.setPaymentType("COD");
        order1.setPaymentStatus("COMPLETED");
        order1.setOrderDate(new Date());
        orders.add(order1);

        Order order2 = new Order();
        order2.setId(2L);
        order2.setOrderId("ORDER002");
        order2.setOfferId("OFFER002");
        order2.setOrderStatus("cancelled");
        order2.setOrderType("normal");
        order2.setSource("B2C");
        order2.setPhone(phoneNumber);
        order2.setAmount(200.00);
        order2.setBilledAmount(200.00);
        order2.setQuantity(1L);
        order2.setPaymentType("COD");
        order2.setPaymentStatus("CANCELLED");
        order2.setOrderDate(new Date());
        orders.add(order2);

        return orders;


ðŸ“„ FILE: JusPayXServiceImpl.java

--- JusPayXServiceImpl | synchronousOrderStatusCall | CODE | 1/1 ---
    @Override
    public JuspayWebhookRequestModel synchronousOrderStatusCall(String orderId, Boolean eventRequired) {
        try {
            JuspayWebhookRequestModel juspayWebhookRequestModel = JuspayWebhookRequestModel.builder()
                    .eventName(JuspayWebhookEvents.ORDER_SUCCEEDED.name())
                    .content(JuspayWebhookContentModel.builder()
                            .order(juspayXFeignClientWrapper.getJuspayOrder(orderId))
                            .build())
                    .build();
            if(eventRequired) {
                juspayWebhook(juspayWebhookRequestModel,false);
            }
            return juspayWebhookRequestModel;
        } catch (Exception e) {
            log.error("Error in synchronous order status call, ex : {} for order_id : {}", e.getMessage(), orderId);
        }
        return null;
