Question: how do we sync minimart orders ?


ðŸŸ¦ SERVICE: payment-service
======================================================================

ðŸ“„ FILE: OrderProvider.java

--- OrderProvider | getUpdateOrderModel | TEST | 1/1 ---
    public static UpdateOrderModel getUpdateOrderModel(){
        UpdateOrderModel updateOrderModel = new UpdateOrderModel();
        updateOrderModel.setCartId(Long.valueOf(TEST_CART_ID));
        updateOrderModel.setTotalCartAmount(BigDecimal.TEN);
        updateOrderModel.setPlatform("platform");
        updateOrderModel.setEntityId(TEST_PAYMENT_ENTITY_ID);
        return updateOrderModel;


ðŸ“„ FILE: PaymentServiceV5ImplTest.java

--- PaymentServiceV5ImplTest | verifyTransactionSorting | TEST | 1/1 ---
    @Test
    void verifyTransactionSorting() {
        // Create multiple payment entities with different dates to test sorting
        List<PaymentEntity> dateOrderedPayments = new ArrayList<>();
        
        // Create payments with different dates using fixed base date
        Calendar calendar = Calendar.getInstance();
        calendar.set(2023, Calendar.JANUARY, 10, 12, 0, 0);
        calendar.set(Calendar.MILLISECOND, 0);
        
        for (int i = 0; i < 3; i++) {
            PaymentEntity payment = new PaymentEntity();
            payment.setId(i);
            payment.setUserId(1L);
            payment.setCartId(100L + i);
            payment.setTotalAmount(BigDecimal.valueOf(1000));
            payment.setStatus("CHARGED");
            payment.setPaymentId("pay_" + i);
            
            // Set different dates - each payment is one day earlier than the previous
            Calendar paymentCalendar = (Calendar) calendar.clone();
            paymentCalendar.add(Calendar.DAY_OF_MONTH, -i);
            payment.setCreatedDate(paymentCalendar.getTime());
            
            dateOrderedPayments.add(payment);
        }

        // Mocking repository responses
        when(paymentRepo.findAllByUserIdAndUptoXDaysOldAndEntityId(1L, 30, "entity1")).thenReturn(Optional.of(dateOrderedPayments));
        when(userRepository.findById(1L)).thenReturn(Optional.of(userEntity));
        when(cartServiceClient.getTransactionsModule(1L, null, "", "30")).thenReturn(Collections.emptyList());

        // Execute
        UserTransactionResponseModel response = paymentServiceV5.getUserTransactions(1L, null, 30, null, null, null, 0, 10, "entity1");

        // Verify sorting order (if implemented)
        List<UserTransactionModel> transactions = response.getTransactions();
        assertNotNull(transactions);
        assertEquals(3, transactions.size());
        
        // Verify transactions are ordered by date if sorting is implemented
        // If not explicitly implemented in the service, this might not be a valid check
        // and should be modified based on actual expected behavior
        if (transactions.size() > 1) {

--- PaymentServiceV5ImplTest | getUserTransactionsWithPagination | TEST | 1/2 ---
    @Test
    void getUserTransactionsWithPagination() {
        // Create multiple payment entities to test pagination with fixed dates
        List<PaymentEntity> multiplePayments = new ArrayList<>();
        Calendar cal = Calendar.getInstance();
        cal.set(2023, Calendar.JANUARY, 1, 12, 0, 0);
        cal.set(Calendar.MILLISECOND, 0);
        
        for (int i = 0; i < 25; i++) {
            PaymentEntity payment = new PaymentEntity();
            payment.setId(i);
            payment.setUserId(1L);
            payment.setCartId(100L + i);
            payment.setTotalAmount(BigDecimal.valueOf(1000 + i));
            payment.setStatus("CHARGED");
            payment.setPaymentId("pay_" + i);
            
            // Set different dates but with consistent format
            Calendar paymentCal = (Calendar) cal.clone();
            paymentCal.add(Calendar.DAY_OF_MONTH, -i);
            payment.setCreatedDate(paymentCal.getTime());
            multiplePayments.add(payment);
        }

        // Mocking repository responses
        when(paymentRepo.findAllByUserIdAndUptoXDaysOldAndEntityId(1L, 30, "entity1")).thenReturn(Optional.of(multiplePayments));
        when(userRepository.findById(1L)).thenReturn(Optional.of(userEntity));
        when(cartServiceClient.getTransactionsModule(1L, null, "", "30")).thenReturn(Collections.emptyList());

        // Execute with page 0, size 10
        UserTransactionResponseModel responsePage0 = paymentServiceV5.getUserTransactions(1L, null, 30, null, null, null, 0, 10, "entity1");

        // Verify page 0
        assertNotNull(responsePage0);
        assertEquals(10, responsePage0.getTransactions().size());
        assertEquals(3, (int) responsePage0.getTotalPages());
        assertEquals(0, (int) responsePage0.getCurrentPage());

        // Execute with page 1, size 10
        UserTransactionResponseModel responsePage1 = paymentServiceV5.getUserTransactions(1L, null, 30, null, null, null, 1, 10, "entity1");

        // Verify page 1
        assertNotNull(responsePage1);
        assertEquals(10, responsePage1.getTransactions().size());
        assertEquals(3, (int) responsePage1.getTotalPages());
        assertEquals(1, (int) responsePage1.getCurrentPage());

        // Execute with page 2, size 10
        UserTransactionResponseModel responsePage2 = paymentServiceV5.getUserTransactions(1L, null, 30, null, null, null, 2, 10, "entity1");


--- PaymentServiceV5ImplTest | getUserTransactionsWithWalletTransactions | TEST | 1/2 ---
    @Test
    void getUserTransactionsWithWalletTransactions() {
        // Mocking repository responses with no payment entities
        when(paymentRepo.findAllByUserIdAndUptoXDaysOldAndEntityId(1L, 30, "entity1")).thenReturn(Optional.of(Collections.emptyList()));
        when(userRepository.findById(1L)).thenReturn(Optional.of(userEntity));
        
        // Create a map to store order ID to cart ID mappings for verification
        Map<Long, Long> orderToCartMap = new HashMap<>();
        
        // Multiple wallet transactions
        List<TransactionsModelDTO> multipleWalletTxns = new ArrayList<>();
        for (int i = 0; i < 5; i++) {
            Long orderId = 200L + i;
            Long cartId = 300L + i;
            
            TransactionsModelDTO txn = new TransactionsModelDTO();
            txn.setOrderId(orderId);
            txn.setAmount(100F * i);
            txn.setType("Credit");
            txn.setStatus("Active");
            txn.setDate("0" + (i+1) + " Jan 2023");
            multipleWalletTxns.add(txn);
            
            // Store mapping for verification
            orderToCartMap.put(orderId, cartId);
            
            // Mock cart order mappings with matching order IDs
            CartOrdersMapping mapping = new CartOrdersMapping();
            mapping.setCartId(cartId);
            mapping.setOrderId(orderId);
            when(cartOrderMappingRepository.findByOrderId(orderId)).thenReturn(Optional.of(mapping));
        }
        
        when(cartServiceClient.getTransactionsModule(1L, null, "", "30")).thenReturn(multipleWalletTxns);

        // Execute
        UserTransactionResponseModel response = paymentServiceV5.getUserTransactions(1L, null, 30, null, null, null, 0, 10, "entity1");

        // Verify
        assertNotNull(response);
        assertEquals(5, response.getTransactions().size());
        assertEquals(1, (int) response.getTotalPages());
        
        // Check wallet transactions are properly formatted - validating each transaction
        for (UserTransactionModel walletTxn : response.getTransactions()) {

--- PaymentServiceV5ImplTest | getUserTransactionsWithPagination | TEST | 2/2 ---
        assertEquals(1, (int) responsePage1.getCurrentPage());

        // Execute with page 2, size 10
        UserTransactionResponseModel responsePage2 = paymentServiceV5.getUserTransactions(1L, null, 30, null, null, null, 2, 10, "entity1");

        // Verify page 2
        assertNotNull(responsePage2);
        assertEquals(5, responsePage2.getTransactions().size());
        assertEquals(3, (int) responsePage2.getTotalPages());
        assertEquals(2, (int) responsePage2.getCurrentPage());


ðŸ“„ FILE: CreateJuspayOrderTest.java

--- CreateJuspayOrderTest | juspayApiCallError | TEST | 1/1 ---
    @DisplayName("Juspay Create order error")
    @Test
    void juspayApiCallError() {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
        when(juspayXFeignClientWrapper.createJuspayOrder(JuspayProvider.getJuspayCreateOrderRequestModel(),LocalDate.now().format(formatter)))
                .thenThrow(JuspayCreateOrderException.class);

        Exception actualException = assertThrows(JuspayCreateOrderException.class, () -> {
            jusPayXService.createJuspayOrder(OrderProvider.getUpdateOrderModel(), PaymentProvider.getUserPaymentMethodsEntity(),
                    TEST_JUSPAY_CUST_ID, "appsFlyerId", "deviceId", "advertisingId", "instanceId");
        });

        assertEquals("Exception while juspay create order", actualException.getMessage());

--- CreateJuspayOrderTest | positiveCase | TEST | 1/1 ---
    @DisplayName("Juspay Order created")
    @Test
    void positiveCase() {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
        when(juspayXFeignClientWrapper.createJuspayOrder(JuspayProvider.getJuspayCreateOrderRequestModel(), LocalDate.now().format(formatter)))
                .thenReturn(JuspayProvider.getJuspayCreateOrderResponseModel());

        JuspayCreateOrderResponseModel juspayCreateOrderResponseModel = jusPayXService.
                createJuspayOrder(OrderProvider.getUpdateOrderModel(), PaymentProvider.getUserPaymentMethodsEntity(),
                        TEST_JUSPAY_CUST_ID, "appsFlyerId", "deviceId","advertisingId", "instanceId");

        assert (juspayCreateOrderResponseModel).equals(JuspayProvider.getJuspayCreateOrderResponseModel());


ðŸ“„ FILE: SynchronousOrderStatusTest.java

--- SynchronousOrderStatusTest | orderStatusCallError | TEST | 1/1 ---
    @DisplayName("Error in order status call")
    @Test
    void orderStatusCallError(){
        when(juspayXFeignClientWrapper.getJuspayOrder(TEST_JUSPAY_ORDER_ID)).thenThrow(ValidationException.class);
        assertThat(jusPayXService.synchronousOrderStatusCall(TEST_JUSPAY_ORDER_ID,false)).isNull();

--- SynchronousOrderStatusTest | positiveCase | TEST | 1/1 ---
    @DisplayName("Positive Case")
    @Test
    void positiveCase(){
        juspayWebhookOrderModel.setStatus("CHARGED");
        when(juspayXFeignClientWrapper.getJuspayOrder(TEST_JUSPAY_ORDER_ID))
                .thenReturn(juspayWebhookOrderModel);
        when(cartServiceClient.getCartOrderDetails(Long.valueOf(TEST_CART_ID)))
                .thenReturn(new ResponseEntity<>(OrderProvider.getCartOrderDetailsResponseModel(),HttpStatus.OK));
        JuspayWebhookRequestModel juspayWebhookRequestModel = jusPayXService.
                synchronousOrderStatusCall(TEST_JUSPAY_ORDER_ID,true);

        JuspayWebhookRequestModel expectedJuspayWebhookRequestModel = JuspayProvider.getJuspayWebhookRequestModel();
        expectedJuspayWebhookRequestModel.getContent().getOrder().setStatus("CHARGED");

        assertThat(juspayWebhookRequestModel).isEqualTo(expectedJuspayWebhookRequestModel);


ðŸ“„ FILE: UpdatePaymentMethodConfigTest.java

--- UpdatePaymentMethodConfigTest | updateGlobalOrder | TEST | 1/1 ---
    @DisplayName("Update Global Order For All Entries")
    @Test
    void updateGlobalOrder(){

        when(paymentMethodConfigRepo.findAll()).thenReturn(Collections.singletonList(paymentMethodConfigEntity));
        paymentMethodConfigService.updateGlobalOrderForAllEntries(Collections.singletonList("COD"));

        verify(paymentMethodConfigRepo,times(1)).saveAll(any());


ðŸ“„ FILE: PaymentServiceImplV5Test.java

--- PaymentServiceImplV5Test | setUp | TEST | 1/1 ---
    @BeforeEach
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        updateOrderModel = new UpdateOrderModel();
        paymentMethodsRequestModel = new PaymentMethodsRequestModel();
        paymentMethodsRequestModel.setUpdateOrderModel(updateOrderModel);


ðŸ“„ FILE: JuspayXFeignClientWrapper.java

--- JuspayXFeignClientWrapper | getJuspayOrder | CODE | 1/1 ---
    public JuspayWebhookOrderModel getJuspayOrder(String orderId){
        return juspayXFeignClient.getJuspayOrder(juspayMerchantId,orderId);


ðŸ“„ FILE: PrivatePaymentController.java

--- PrivatePaymentController | orderStatusUpdate | CODE | 1/1 ---
    @ApiOperation(value = "Was created when rz callback mechanism was broken as a fallback.")
    @Deprecated
    @GetMapping(value = "/payment/order-status-update")
    public ResponseEntity<?> orderStatusUpdate(@RequestParam(value = "date" , required = false ) String date) {
        if(ObjectUtils.isEmpty(date)){
            date = CommonUtils.getCurrentDate();
        }
        return new ResponseEntity<>("OK", HttpStatus.OK);


ðŸ“„ FILE: PaymentMethodConfigController.java

--- PaymentMethodConfigController | updateGlobalOrderForAllEntries | CODE | 1/1 ---
    @PostMapping("/update-global-order")
    public ResponseEntity<Void> updateGlobalOrderForAllEntries(@RequestBody List<String> globalOrder){
        paymentMethodConfigService.updateGlobalOrderForAllEntries(globalOrder);
        return new ResponseEntity<>(HttpStatus.OK);


ðŸ“„ FILE: PaymentControllerV5.java

--- PaymentControllerV5 | synchronousOrderStatus | CODE | 1/1 ---
    @PostMapping(value = "/sync/juspay/order-status")
    public ResponseEntity<?> synchronousOrderStatus(@RequestParam(value = "orderId") String orderId,
                                                    @RequestHeader(name = "userId", required = false) Long headerUserId, HttpServletRequest request) {
        Long tokenUserId = commonUtils.getFinalValidUserId(request, headerUserId);
        Long userId = jusPayXService.getUserIdFromJuspayOrderId(orderId);
        if(!tokenUserId.equals(userId)){
            throw new BadRequestException("OrderId doesn't belong to this user", HttpStatus.BAD_REQUEST);
        }
        return new ResponseEntity<>(jusPayXService.synchronousOrderStatusCall(orderId, true),HttpStatus.OK);


ðŸ“„ FILE: DeploymentStartupHook.java

--- DeploymentStartupHook | ListenDeploymentStartUpHook | CODE | 1/1 ---
    @EventListener(ApplicationReadyEvent.class)
    public void ListenDeploymentStartUpHook() {
        cacheService.set("pending-orders-cron-process", false,30000L);
        cacheService.set("pending-orders-refund-cron-process", false,30000L);


ðŸ“„ FILE: RefundBatchConfig.java

--- RefundBatchConfig | batchRefunds | CODE | 1/1 ---
    @Bean
    public Job batchRefunds(JobBuilderFactory jobBuilderFactory, StepBuilderFactory stepBuilderFactory,
                            ItemReader<OrderEntity> orderEntityItemReader, ItemProcessor<OrderEntity, PaymentRefundInfoEntity> orderEntityProcessor,
                            ItemWriter<PaymentRefundInfoEntity> paymentRefundWriter, ItemWriteListener<PaymentRefundInfoEntity> addDeliveryFeeListenerImpl) throws Exception {

        Step step = stepBuilderFactory.get("refund-for-cancel-order-step")
                .<OrderEntity, PaymentRefundInfoEntity>chunk(100)
                .reader(orderEntityItemReader)
                .processor(orderEntityProcessor)
                .writer(paymentRefundWriter)
                .listener(addDeliveryFeeListenerImpl)
                .faultTolerant()
                .skip(Exception.class)
                .skip(SQLException.class)
                .skip(UncategorizedSQLException.class)
                .skipLimit(Integer.MAX_VALUE)
                .build();
        return jobBuilderFactory.get("refund-for-cancellations").incrementer(new RunIdIncrementer()).start(step).build();

--- RefundBatchConfig | orderEntityItemReader | CODE | 1/1 ---
    @Bean
    public ItemReader<OrderEntity> orderEntityItemReader(DataSource dataSource) {
        log.info("Starting Reader: " + new Date());

        final boolean[] firstTime = {true};
        return new JdbcCursorItemReaderBuilder<OrderEntity>()


ðŸ“„ FILE: KafkaService.java

--- KafkaService | sendOrdersStatusUpdateTopic | CODE | 1/1 ---
  public void sendOrdersStatusUpdateTopic(OrdersStatusUpdateEvent ordersStatusUpdateEvent) {
    try {

--- KafkaService | sendOrderPlacedSMSCommunicationEvent | CODE | 1/1 ---
  public void sendOrderPlacedSMSCommunicationEvent(OrderUpdateEventDetail orderUpdateEventDetail) {
    try {


ðŸ“„ FILE: RazorPayPaymentServiceImplV2.java

--- RazorPayPaymentServiceImplV2 | getRazorPayOrderId | CODE | 1/1 ---
    @Override
    public Order getRazorPayOrderId(UpdateOrderModel orderModel) throws RazorpayException {
        log.info("Payment initiation process - Razorpay order id generation of Rs. {} for cartId : {} and userId : {}", orderModel.getTotalCartAmount(), orderModel.getCartId(), orderModel.getUserId());
        RazorpayClient razorpayClient = new RazorpayClient(key, rzSecretKey);
        try {


ðŸ“„ FILE: PaymentServiceImplV3.java

--- PaymentServiceImplV3 | createJuspayDirectOtpTransaction | CODE | 1/1 ---
    private JuspayTxnResponse createJuspayDirectOtpTransaction(UpdateOrderModel updateOrderModel){
        JuspayCreateTxnRequestModel juspayCreateTxnRequestModel = new JuspayCreateTxnRequestModel();
        juspayCreateTxnRequestModel.setFormat("json");
        juspayCreateTxnRequestModel.setPaymentMethod(LAZYPAY.name());
        juspayCreateTxnRequestModel.setOrderId(updateOrderModel.getPaymentId());
        juspayCreateTxnRequestModel.setMerchantId(juspayMerchantId);
        juspayCreateTxnRequestModel.setRedirectAfterPayment("true");
        juspayCreateTxnRequestModel.setPaymentMethodType(PaymentV3Constants.WALLET.name());
        juspayCreateTxnRequestModel.setAuthType("OTP");
        return jusPayXService.createJuspayTransaction(juspayCreateTxnRequestModel);

--- PaymentServiceImplV3 | paymentDetailsBreakUp | CODE | 1/2 ---
    @Override
    public List<OrderPaymentBreakUp> paymentDetailsBreakUp(
            Set<Long> orderIds) {

        OrderDetailsGenericRequestModel requestModel = new OrderDetailsGenericRequestModel();

        // Simplify filter and additionalRequiredData creation
        requestModel.setFilter(Collections.singletonMap(FilterTypeEnums.INCLUDE,
                Collections.singletonMap(FilterValueEnums.ORDER_IDS, orderIds)));
        requestModel.setAdditionalRequiredData(Map.of(
                AdditionalRequiredDataEnums.ORDER_DISCOUNTING_DETAILS, true,
                AdditionalRequiredDataEnums.ORDER_CART_DETAILS, true
        ));
        requestModel.setCustomFilter(Collections.emptyMap());

        List<OrderDetailsResponseModel> orderDetails =
                Optional.ofNullable(orderServiceClient.getOrderDetailsGeneric("invoice_discounting_view", requestModel).getBody())
                        .map(OrderDetailsGenericResponseModel::getData)
                        .orElseThrow(() -> new RuntimeException("Order details not found"));

        if (orderDetails.isEmpty()) {
            throw new RuntimeException("Order details not found");
        }

        List<PaymentInitDetailsEntity> paymentInitDetailsEntities =
                Optional.of(paymentInitDetailsRepository
                                .findByOrderIdIn(
                                        orderDetails.stream().map(OrderDetailsResponseModel::getOrderDetails)
                                                .map(OrderDetailsModel::getId).collect(Collectors.toSet())))
                        .orElseThrow(() -> new RuntimeException("Payment details not found"));


        Map<Long, List<PaymentInitDetailsEntity>> paymentInitDetailsEntityMap =
                paymentInitDetailsEntities.stream().collect(Collectors
                        .groupingBy(PaymentInitDetailsEntity::getOrderId));

        List<OrderPaymentBreakUp> responseModel = new ArrayList<>();

        for (OrderDetailsResponseModel orderDetailsResponseModel : orderDetails) {
            OrderDetailsModel orderDetail = orderDetailsResponseModel.getOrderDetails();

            List<PaymentInitDetailsEntity> orderPaymentDetail = paymentInitDetailsEntityMap
                    .getOrDefault(orderDetail.getId(), Collections.emptyList());

            OrderPaymentBreakUp martOrderPayment = new OrderPaymentBreakUp();
            martOrderPayment.setOrderId(orderDetail.getId());
            martOrderPayment.setAmount(orderDetail.getAmount());
            martOrderPayment.setBilledAmount(orderDetail.getBilledAmount());
            martOrderPayment.setDiscountAmount(orderDetail.getDiscountAmount());
            martOrderPayment.setOrderDiscountModels(Objects.nonNull(orderDetailsResponseModel.getOrderDiscountingDetails())

--- PaymentServiceImplV3 | paymentDetailsBreakUp | CODE | 2/2 ---
            martOrderPayment.setOrderId(orderDetail.getId());
            martOrderPayment.setAmount(orderDetail.getAmount());
            martOrderPayment.setBilledAmount(orderDetail.getBilledAmount());
            martOrderPayment.setDiscountAmount(orderDetail.getDiscountAmount());
            martOrderPayment.setOrderDiscountModels(Objects.nonNull(orderDetailsResponseModel.getOrderDiscountingDetails())
                    ? orderDetailsResponseModel.getOrderDiscountingDetails().getDiscountingHistoryDetails() : Collections.emptyList());

            if (orderDetail.getSource().equalsIgnoreCase("Minimart") && orderPaymentDetail.size() > 0) {
                Double voucherAmount = orderPaymentDetail.stream().filter(paymentInitDetailsEntity ->
                                PaymentModes.VOUCHER.getType().equalsIgnoreCase(paymentInitDetailsEntity.getPaymentMode()))
                        .mapToDouble(PaymentInitDetailsEntity::getAmount).sum();

                Double creditNote = orderPaymentDetail.stream().filter(paymentInitDetailsEntity ->
                                PaymentModes.CREDIT_NOTE.getType().equalsIgnoreCase(paymentInitDetailsEntity.getPaymentMode()))
                        .mapToDouble(PaymentInitDetailsEntity::getAmount).sum();

                Double cash = orderPaymentDetail.stream().filter(paymentInitDetailsEntity ->
                                PaymentModes.CASH.getType().equalsIgnoreCase(paymentInitDetailsEntity.getPaymentMode()))
                        .mapToDouble(PaymentInitDetailsEntity::getAmount).sum();

                Double online = orderPaymentDetail.stream().filter(paymentInitDetailsEntity ->
                                !PaymentModes.CASH.getType().equalsIgnoreCase(paymentInitDetailsEntity.getPaymentMode()))
                        .filter(paymentInitDetailsEntity ->
                                !PaymentModes.CREDIT_NOTE.getType().equalsIgnoreCase(paymentInitDetailsEntity.getPaymentMode()))
                        .filter(paymentInitDetailsEntity ->
                                !PaymentModes.VOUCHER.getType().equalsIgnoreCase(paymentInitDetailsEntity.getPaymentMode()))
                        .mapToDouble(PaymentInitDetailsEntity::getAmount).sum();
                martOrderPayment.setVoucher(voucherAmount.floatValue());
                martOrderPayment.setOnline(online.floatValue());
                martOrderPayment.setCash(cash.floatValue());
                martOrderPayment.setCreditNote(creditNote.floatValue());
            } else {
                if (orderDetail.getPaymentType().equalsIgnoreCase(PaymentModes.COD.getType())) {
                    martOrderPayment.setCash(orderDetail.getAmount());
                } else {
                    martOrderPayment.setOnline(orderDetail.getAmount());
                }
            }
            responseModel.add(martOrderPayment);
        }
        return responseModel;


ðŸ“„ FILE: PaymentServiceImplV2.java

--- PaymentServiceImplV2 | placeOrder | CODE | 1/1 ---
    @Override
    public Optional<UpdateOrderModel> placeOrder(UpdateOrderModel orderModel, String authKey, Integer palId,String appsFlyerId, String deviceId,String advertisingId) {
        log.info("payment initiation process - place order process started for cartId : {} and userId : {}", orderModel.getCartId(), orderModel.getUserId());
        log.error("Cart-Service Request  for place order {}", orderModel);
        Object responseEntityBody = null;
        try {
            ResponseEntity<?> responseEntity = cartServiceClient.placeOrder(orderModel, authKey, orderModel.getUserId(), palId, deviceId,appsFlyerId,orderModel.getPlatform(),advertisingId);
            responseEntityBody = responseEntity.getBody();
            if (responseEntity.getStatusCode().value() == 204 || responseEntityBody == null) {
                log.warn("No order is created for cart id : {}", orderModel.getCartId());
                return Optional.empty();
            }
        } catch (FeignException e) {
            log.error("Unable to place order for cart id : {} , response content {}", orderModel.getCartId(), e.toString());
            return Optional.empty();
        }

        try {


ðŸ“„ FILE: MaintenanceServiceImpl.java

--- MaintenanceServiceImpl | setCronRunCacheKey | CODE | 1/1 ---
    public void setCronRunCacheKey(Boolean flag) {
        cacheService.set("pending-orders-cron-process", flag,30000L);

--- MaintenanceServiceImpl | checkIfPaymentReceived | CODE | 1/1 ---
    private JuspayWebhookRequestModel checkIfPaymentReceived(String orderId) {
        JuspayWebhookRequestModel juspaySynchronousOrderModel = jusPayXService.synchronousOrderStatusCall(orderId, false);
        if (Objects.isNull(juspaySynchronousOrderModel) ||
                Objects.isNull(juspaySynchronousOrderModel.getContent()) ||
                Objects.isNull(juspaySynchronousOrderModel.getContent().getOrder())) {
            return null;
        }

        JuspayWebhookOrderModel juspayOrder = juspaySynchronousOrderModel.getContent().getOrder();
        if (!orderId.equals(juspayOrder.getOrderId()) ||
                !CHARGED_PAYMENT_STATUS.equalsIgnoreCase(juspayOrder.getStatus())) {
            return null;
        }

        return juspaySynchronousOrderModel;

--- MaintenanceServiceImpl | cancelOrder | CODE | 1/1 ---
    private void cancelOrder(OrderEntity y,Optional<UserEntity> userData,Set<Long> cartIdsToMarkProcessed,Optional<CartOrdersMapping> optMapping,List<String> result){
        if (postPaymentUpdateHelper.cancelOrder(y, userData.get().getAuthKey())) {
            cartIdsToMarkProcessed.add(optMapping.get().getCartId());
            OrderHistoryEntity orderHistoryEntity = new OrderHistoryEntity(y, "remove-pending-order-cron");
            orderHistoryRepo.save(orderHistoryEntity);
            result.add(y.getOrderId());
            y.setStatus("discarded");
            y.setPaymentStatus("PAYMENT_FAILED");
            orderRepo.save(y);
            return ;
        }
        asyncService.discardFailedCancellationsOrdOrders(y);

--- MaintenanceServiceImpl | removePendingOrders | CODE | 1/4 ---
    @Transactional
    @Override
    @Async
    public void removePendingOrders() {
        int threadCount = 5;
        Object isCronRunning =  cacheService.get("pending-orders-cron-process");
        Boolean isRunning = (Boolean)isCronRunning;
        if (Boolean.TRUE.equals(isRunning)) {
            return;
        }
        cacheService.set("pending-orders-cron-process", true,30000L);

        try {
            TimeZone.setDefault(TimeZone.getTimeZone("IST"));

            List<OrderEntity> orderEntities = orderRepo.findPendingOrdersForCancellationUsingLock("PAYTM", "pending", ORDERS_OLDER_THAN_MINUTES);
            if (orderEntities == null || orderEntities.isEmpty()) {
                cacheService.set("pending-orders-cron-process", false,30000L);
                log.error("removePendingOrders cron No pending orders present.");
                return;
            }

            log.error("removePendingOrders cron count {}", orderEntities.size());
            List<Long> orderIds = orderEntities.stream().map(OrderEntity::getId).collect(Collectors.toList());
            List<CartOrdersMapping> cartOrdersMappings = cartOrderMappingRepository.findAllByOrderIds(orderIds).get();

            // get distinct cartIds
            ExecutorService paymentExecutor = Executors.newFixedThreadPool(threadCount);
            List<String> cartIds = cartOrdersMappings.stream().map(cartOrdersMapping -> cartOrdersMapping.getCartId().toString()).distinct().collect(Collectors.toList());
            Map<String, JuspayWebhookRequestModel> juspaySynchronousOrderModelMap = new ConcurrentHashMap<>(); // this is map to store info for cartIds for which payment is charged
            List<Future<?>> juspayFutures = new ArrayList<>();

            for (String cartId : cartIds) {
                juspayFutures.add(paymentExecutor.submit(() -> {
                    try {
                        JuspayWebhookRequestModel model = checkIfPaymentReceived(AppConstants.ORDER_PREFIX + cartId);
                        if (model != null) {
                            juspaySynchronousOrderModelMap.put(cartId, model);
                        }
                    } catch (Exception e) {
                        log.error("removePendingOrders cron Error checking payment for cartId: {} message {}", cartId, e.getMessage());
                    }
                }));
            }

            for (Future<?> f : juspayFutures) {
                try {
                    f.get();
                } catch (Exception e) {
                    log.error("removePendingOrders cron Error in parallel payment check {}", e.getMessage());

--- MaintenanceServiceImpl | removePendingOrders | CODE | 2/4 ---
            for (Future<?> f : juspayFutures) {
                try {
                    f.get();
                } catch (Exception e) {
                    log.error("removePendingOrders cron Error in parallel payment check {}", e.getMessage());
                }
            }
            paymentExecutor.shutdown();
            log.error("removePendingOrders cron paymentExecutor completed {} juspaySynchronousOrderModelMap {}", juspayFutures.size(), juspaySynchronousOrderModelMap);

            Set<Long> webHookCalledCartIds = ConcurrentHashMap.newKeySet(); // to call webhook process for every cartId only once
            Set<Long> cartIdsToMarkProcessed = ConcurrentHashMap.newKeySet();
            List<String> result = Collections.synchronizedList(new ArrayList<>());

            // Group orders by cartId
            Map<Long, List<OrderEntity>> cartIdToOrdersMap = orderEntities.stream()
                    .collect(Collectors.groupingBy(order ->
                            cartOrdersMappings.stream()
                                    .filter(m -> m.getOrderId().equals(order.getId()))
                                    .map(CartOrdersMapping::getCartId)
                                    .findFirst()
                                    .orElse(0L)
                    ));

            ExecutorService orderExecutor = Executors.newFixedThreadPool(threadCount);
            List<Future<?>> futures = new ArrayList<>();

            for (Map.Entry<Long, List<OrderEntity>> entry : cartIdToOrdersMap.entrySet()) {
                List<OrderEntity> ordersInCart = entry.getValue();

                // Submit one task per cartId â†’ ensures sequential processing within a cart
                futures.add(orderExecutor.submit(() -> {
                    for (OrderEntity y : ordersInCart) {
                        try {
                            Long userId = y.getUserId();
                            Optional<UserEntity> userData = userRepository.findById(userId);
                            if (userData.isEmpty()) {
                                log.error("removePendingOrders cron User not found " + userId);
                                return;
                            }

                            Optional<CartOrdersMapping> optMapping = cartOrdersMappings.stream().filter(cartOrdersMapping -> cartOrdersMapping.getOrderId().equals(y.getId())).findAny();
                            if (optMapping.isEmpty()) {
                                log.error("removePendingOrders cron Cart order mapping not present for order : " + y.getId());
                                OrderHistoryEntity orderHistoryEntity = new OrderHistoryEntity(y, "remove-pending-order-cron");
                                orderHistoryRepo.save(orderHistoryEntity);
                                if (postPaymentUpdateHelper.cancelOrder(y, userData.get().getAuthKey())) {
                                    result.add(y.getOrderId());
                                    orderRepo.setStatusAndPaymentStatus("discarded", "PAYMENT_FAILED", y.getId());
                                } else {

--- MaintenanceServiceImpl | removePendingOrders | CODE | 3/4 ---
                                orderHistoryRepo.save(orderHistoryEntity);
                                if (postPaymentUpdateHelper.cancelOrder(y, userData.get().getAuthKey())) {
                                    result.add(y.getOrderId());
                                    orderRepo.setStatusAndPaymentStatus("discarded", "PAYMENT_FAILED", y.getId());
                                } else {
                                    Optional<OrderEntity> orderData = orderRepo.findById(y.getId());
                                    if (orderData.isPresent() && orderData.get().getStatus().equalsIgnoreCase(OrderStatus.CANCEL.status)) {
                                        result.add(y.getOrderId());
                                        orderRepo.setStatusAndPaymentStatus("discarded", "PAYMENT_FAILED", y.getId());
                                    }
                                }
                                return;
                            }

                            // check if current time is more than 30 minute of order creation
                            boolean isOrderMoreThen30MinOldPending =
                                    (new Date().getTime() - y.getOrderDate().getTime()) >= (30 * 60 * 1000);
                            // this means payment is received for this cartId
                            if (!isOrderMoreThen30MinOldPending && juspaySynchronousOrderModelMap.containsKey(optMapping.get().getCartId().toString())) {
                                if (webHookCalledCartIds.contains(optMapping.get().getCartId())) {
                                    return;
                                }
                                log.error("removePendingOrders cron Not discarding orders in cron as payment is received for this order :{} for cartId :{} ", y.getId(), optMapping.get().getCartId());
                                JuspayWebhookRequestModel juspaySynchronousOrderModel = juspaySynchronousOrderModelMap.get(optMapping.get().getCartId().toString());
                                jusPayXService.juspayWebhook(juspaySynchronousOrderModel, true);
                                webHookCalledCartIds.add(optMapping.get().getCartId());
                                return;
                            }
                            cancelOrder(y, userData, cartIdsToMarkProcessed, optMapping, result);
                        } catch (Exception e) {
                            log.error("removePendingOrders cron  Error while discarding order : {} with exception {} in payment service", y.getId(), e.getMessage(), e);
                        }
                    }
                }));
            }

            for (Future<?> f : futures) {
                try {
                    f.get();
                } catch (Exception e) {
                    log.error("removePendingOrders cron Error in parallel cart processing {}", e.getMessage());
                }
            }
            log.error("removePendingOrders cron paymentExecutor completed {} cartIdsToMarkProcessed {}", futures.size(), cartIdsToMarkProcessed);
            orderExecutor.shutdown();

            List<CartEntity> cartList = cartRepository.findAllById(cartIdsToMarkProcessed);
            cartList.forEach(cart -> cart.setCartStatus("PROCESSED"));
            cartRepository.saveAll(cartList);
        }finally {

--- MaintenanceServiceImpl | removePendingOrders | CODE | 4/4 ---

            List<CartEntity> cartList = cartRepository.findAllById(cartIdsToMarkProcessed);
            cartList.forEach(cart -> cart.setCartStatus("PROCESSED"));
            cartRepository.saveAll(cartList);
        }finally {
            cacheService.set("pending-orders-cron-process", false,30000L);
        }

        log.error("removePendingOrders cron completed");


ðŸ“„ FILE: AsyncServiceImpl.java

--- AsyncServiceImpl | asyncCreateRefundsForCancelledOrders | CODE | 1/1 ---
    @Trace(async = true)
    @Async
    public void asyncCreateRefundsForCancelledOrders(Token newRelicToken) throws JobParametersInvalidException, JobExecutionAlreadyRunningException, JobRestartException, JobInstanceAlreadyCompleteException {
        Object isCronRunning =  cacheService.get("pending-orders-refund-cron-process");

        Boolean isRunning = (Boolean)isCronRunning;
        if(Boolean.TRUE.equals(isRunning)) {
            return;
        }
        log.error("Setting cacheKey for  cancelled orders");
        cacheService.set("pending-orders-refund-cron-process", true,30000L);

        newRelicToken.link();
        JobParameters jobParameters = new JobParametersBuilder()
                .addLong("refund-for-cancellations",System.currentTimeMillis()).toJobParameters();
        JobExecution jobExecution = jobLauncher.run(job, jobParameters);

        List<Throwable> allFailureExceptions = jobExecution.getAllFailureExceptions();
        for (Throwable failureException : allFailureExceptions) {
            log.error("createRefundsForCancelledOrders failureException ", failureException);
        }
        newRelicToken.linkAndExpire();
        log.error("UnSetting cacheKey for  cancelled orders");
        cacheService.set("pending-orders-refund-cron-process", false,30000L);

--- AsyncServiceImpl | discardFailedCancellationsOrdOrders | CODE | 1/1 ---
    @Async
    public void discardFailedCancellationsOrdOrders(OrderEntity order) {
        CompletableFuture.runAsync(


ðŸ“„ FILE: RefundServiceImpl.java

--- RefundServiceImpl | updateOrdersRefundDone | CODE | 1/1 ---
    private void updateOrdersRefundDone(List<Long> orderIds) {
        List<OrderEntity> orderEntities = orderRepo.findByIdIn(orderIds);
        orderEntities.stream().
            forEach(orderEntity -> orderEntity.setPaymentStatus(PaymentOrderStatus.REFUND_DONE.toString()));
        orderRepo.saveAll(orderEntities);


ðŸ“„ FILE: JusPayXServiceImpl.java

--- JusPayXServiceImpl | createJuspayOrder | CODE | 1/1 ---
    @Override
    public JuspayCreateOrderResponseModel createJuspayOrder(UpdateOrderModel orderModel, UserPaymentMethodsEntity userPaymentMethodsEntity, String custId,String appsFlyerId,String deviceId,String advertisingId, String instanceId) throws JuspayCreateOrderException {
        try {

--- JusPayXServiceImpl | synchronousOrderStatusCall | CODE | 1/1 ---
    @Override
    public JuspayWebhookRequestModel synchronousOrderStatusCall(String orderId, Boolean eventRequired) {
        try {
            JuspayWebhookRequestModel juspayWebhookRequestModel = JuspayWebhookRequestModel.builder()
                    .eventName(JuspayWebhookEvents.ORDER_SUCCEEDED.name())
                    .content(JuspayWebhookContentModel.builder()
                            .order(juspayXFeignClientWrapper.getJuspayOrder(orderId))
                            .build())
                    .build();
            if(eventRequired) {
                juspayWebhook(juspayWebhookRequestModel,false);
            }
            return juspayWebhookRequestModel;
        } catch (Exception e) {
            log.error("Error in synchronous order status call, ex : {} for order_id : {}", e.getMessage(), orderId);
        }
        return null;

--- JusPayXServiceImpl | getJuspayWebhookOrderModel | CODE | 1/1 ---
    private JuspayWebhookOrderModel getJuspayWebhookOrderModel(JuspayWebhookRequestModel juspayRequestModel, String eventName, Boolean orderStatusCheckRequired) {
        try {
            if (Objects.isNull(juspayRequestModel.getContent())) {
                log.error("Juspay webhook content is missing for event: {}", eventName);
                return null;
            }
            JuspayWebhookOrderModel juspayRequestOrder = juspayRequestModel.getContent().getOrder();
            if (Objects.isNull(juspayRequestOrder)) {
                log.error("Order details are missing in the Juspay webhook payload for event: {}", eventName);
                return null;
            }
            if(!orderStatusCheckRequired){
                return juspayRequestOrder;
            }
            JuspayWebhookRequestModel juspaySynchronousOrderModel = synchronousOrderStatusCall(juspayRequestOrder.getOrderId(), false);
            if(Objects.isNull(juspaySynchronousOrderModel)){
                log.error("Juspay webhook synchronous call for Order ID: {} has an error", juspayRequestOrder.getOrderId());
                return null;
            }
            if (Objects.isNull(juspaySynchronousOrderModel.getContent())) {
                log.error("Juspay webhook content is missing in synchronous call for Order ID: {}", juspayRequestOrder.getOrderId());
                return null;
            }
            JuspayWebhookOrderModel juspayOrder = juspaySynchronousOrderModel.getContent().getOrder();
            if (Objects.isNull(juspayOrder)) {
                log.error("Order details are missing in the Juspay synchronous response for event: {}", eventName);
                return null;
            }
            if (!juspayOrder.getOrderId().equals(juspayRequestOrder.getOrderId())) {
                log.error("Order ID mismatch: request Order ID = {}, synchronous Order ID = {}", juspayRequestOrder.getOrderId(), juspayOrder.getOrderId());
                return null;
            }
            return juspayOrder;
        } catch (Exception e) {
            log.error("Error in getJuspayWebhookOrderModel for event: {} and payload : {}. Error: ", eventName,juspayRequestModel, e);
        }
        return null;

--- JusPayXServiceImpl | handleOrderSucceededEvent | CODE | 1/1 ---
    private void handleOrderSucceededEvent(JuspayWebhookOrderModel juspayOrder, JuspayWebhookRequestModel juspayRequestModel) {

        log.error("handle Order Success event request  juspayOrder {}, juspayRequestModel : {}", juspayOrder, juspayRequestModel);
        if (!CHARGED_PAYMENT_STATUS.equalsIgnoreCase(juspayOrder.getStatus())) {
//            log.error("Order status is not CHARGED: {} for cart : {}", juspayOrder.getStatus(), juspayOrder.getUdf2());
            return;
        }
        try {

--- JusPayXServiceImpl | captureOrders | CODE | 1/1 ---
    private void captureOrders(JuspayWebhookOrderModel juspayWebhookOrderModel, PaymentEntity paymentEntity, JuspayCustomParameters juspayCustomParameters) {
        setStatus(juspayWebhookOrderModel, paymentEntity,juspayCustomParameters);
        paymentRepo.save(paymentEntity);
        paymentRepo.flush();
        PaymentSuccessOrderStatusUpdate postOrderUpdateResp =  postPaymentUpdateHelper.updateOrderForPaymentSuccessThroughCallback(paymentEntity);
        if(postOrderUpdateResp == null){
            log.error("Payment success callback did not update order status for cartId : {}", paymentEntity.getCartId());
            return;
        }
        log.error("{} - sending event for payment success callback for cart id : {}, orderIds : {}", PAYMENT_SUCCESS_CALLBACK_MSG, paymentEntity.getCartId(),postOrderUpdateResp.getUpdatedOrderEntities().stream()
                .map(OrderEntity::getId)
                .filter(Objects::nonNull)
                .collect(Collectors.toList()));
        postPaymentUpdateHelper.raiseOrderStatusSuccessEvent(postOrderUpdateResp.getUpdatedOrderEntities(), paymentEntity.getCartId(), juspayCustomParameters);
        log.info("{} - initiating notification after successful update for cart id : {}.", PAYMENT_SUCCESS_CALLBACK_MSG, paymentEntity.getCartId());
        notificationHelper.paymentJourneyUpdate(ORDER_COMPLETE_POST_PAYMENT, postOrderUpdateResp.getDealIds(), postOrderUpdateResp.getFirstValidOrder().getUserId());
        paymentServiceV5.updatePaymentMethodsCache(juspayWebhookOrderModel, juspayCustomParameters, paymentEntity);


ðŸ“„ FILE: PaymentServiceV5Impl.java

--- PaymentServiceV5Impl | getPaymentMethodListOrder | CODE | 1/1 ---
    private List<String> getPaymentMethodListOrder(UserEntity user,CartDetailsModel cartDetailsModel) throws IOException {
        // Get the payment method order from growthBook
        PaymentMethodsOrderConfig fallbackValue = new PaymentMethodsOrderConfig();
        fallbackValue.setAbEnabled(false);
        PaymentMethodsOrderConfig config =  growthBookService.getGrowthBookConfig(user, AppConstants.PAYMENT_SERVICE_PAYMENT_METHODS_ORDER_EXP, PaymentMethodsOrderConfig.class,fallbackValue);

        // If AB test is enabled, return the order from the config
        if(config.getAbEnabled()){
            if(Objects.nonNull(config.getPaymentMethodsOrder()) && config.getPaymentMethodsOrder().size() == AppConstants.defaultAbTestPaymentMethodOrders.size()
                && new HashSet<>(config.getPaymentMethodsOrder()).containsAll(AppConstants.defaultAbTestPaymentMethodOrders)
            ) {
                // log.error("received default order from growthBook for userId {} as :{}",user.getId(),config.getPaymentMethodsOrder());
                return config.getPaymentMethodsOrder();
            }
        }
        // return order from the payment config according to userRank
        return fetchPaymentConfigListInOrder(user.getUserRank(), cartDetailsModel.getTotalCartAmount().doubleValue());


ðŸ“„ FILE: RazorpayOrderServiceImpl.java

--- RazorpayOrderServiceImpl | fetchOrderDetails | CODE | 1/1 ---
    @Override
    public RazorpayOrderDetails fetchOrderDetails(String razorpayOrderId) throws RazorpayException {
        RazorpayOrderDetails razorpayOrderDetails = new RazorpayOrderDetails();
        RazorpayClient razorpayClient = new RazorpayClient(keyId, keySecret);

        try {
            Order orderData = razorpayClient.Orders.fetch(razorpayOrderId);
            log.info("Fetching order details from Razorpay {}", orderData);

            razorpayOrderDetails.setRazorpayOrderId(orderData.get("id"));
            razorpayOrderDetails.setOrderStatus(orderData.get("status"));
            razorpayOrderDetails.setAmount(orderData.get("amount"));
        } catch (RazorpayException e) {
            throw new RazorpayException(e.getMessage());
        }

        return razorpayOrderDetails;


ðŸ“„ FILE: CapturedPaymentProcessor.java

--- CapturedPaymentProcessor | process | CODE | 1/1 ---
    @Override
    public void process(RazorPayCallbackModel.EntityModel gatewayEntity, PaymentEntity payment, Boolean paidPaymentExists) {
        if (payment.getStatus().equals(AppConstants.CAPTURED)) {
            log.info("status is set to {} for order id : {} already.", AppConstants.CAPTURED, gatewayEntity.getOrderId());
            return;
        }

        this.setStatus(event, gatewayEntity, payment);
        paymentRepo.save(payment);


ðŸ“„ FILE: PaidOrderProcessor.java

--- PaidOrderProcessor | process | CODE | 1/1 ---
    @Override
    public void process(RazorPayCallbackModel.EntityModel gatewayEntity, PaymentEntity payment, Boolean paidPaymentExists) {
        if (payment.isPaid()) {
            log.info("cart payment status is set to {} for order id : {} already.", AppConstants.PAYMENT_PAID_STATUS, gatewayEntity.getOrderId());
            return;
        }
        this.captureOrders(event, gatewayEntity, payment);
        paymentServiceV4.updatePaymentMethod(gatewayEntity,payment);

--- PaidOrderProcessor | captureOrders | CODE | 1/1 ---
    public void captureOrders(String event, RazorPayCallbackModel.EntityModel entityModel, PaymentEntity paymentEntity) {
        setStatus(event, entityModel, paymentEntity);
        paymentRepo.save(paymentEntity);
        postPaymentUpdateHelper.updateOrderForPaymentSuccessThroughCallback(paymentEntity);


ðŸ“„ FILE: DefaultPaymentProcessor.java

--- DefaultPaymentProcessor | process | CODE | 1/1 ---
    @Override
    public void process(RazorPayCallbackModel.EntityModel gatewayEntity, PaymentEntity payment, Boolean paidPaymentExists) {
        if (payment.getStatus().equals(FAILED)) {
            log.info("status is set to {} for order id : {} already.", FAILED , gatewayEntity.getOrderId());
            return;
        }

        this.setStatus(event, gatewayEntity, payment);
        paymentRepo.save(payment);

        if ( ! paidPaymentExists) {


ðŸ“„ FILE: OrderStatusUpdateHelper.java

--- OrderStatusUpdateHelper | updateOrders | CODE | 1/1 ---
    public List<OrderEntity> updateOrders(List<OrderEntity> orderEntityList, List<String> dealIds, String addressVerifiedStatus) {
        List<Long> orderIds = orderEntityList.stream().map(OrderEntity::getId).collect(Collectors.toList());
        Date verifiedDate = (PaymentOrderStatus.VERIFIED.name().equalsIgnoreCase(addressVerifiedStatus)) ? new Date() : null;
        orderRepo.bulkUpdateOrderPaymentStatus(addressVerifiedStatus,PaymentOrderStatus.PAYMENT_SUCCESSFUL.name(),verifiedDate,orderIds);
        List<OrderEntity> orderEntities = orderEntityList.stream()
                .peek(orderEntity -> {
                    dealIds.add(orderEntity.getDealId());
                })
                .collect(Collectors.toList());
        log.error("Callback Updated Orders for success callback : {}", orderEntities);
        orderRepo.flush();
        orderEntities = orderRepo.findByIdIn(orderIds);
        return orderEntities;


ðŸ“„ FILE: PostPaymentUpdateHelper.java

--- PostPaymentUpdateHelper | getOrderHistoryEntity | CODE | 1/1 ---
    private OrderHistoryEntity getOrderHistoryEntity(OrderEntity orderEntity, String updatedBy){
        return new OrderHistoryEntity(orderEntity, updatedBy);

--- PostPaymentUpdateHelper | isValidOnlineToBePaidOrder | CODE | 1/1 ---
    private OrderEntity isValidOnlineToBePaidOrder(List<Long> orderIds) {
        Optional<OrderEntity> optFirstOrder = orderRepo.findById(orderIds.get(0));
        if (optFirstOrder.isEmpty()) {
            return null;
        }

        OrderEntity firstOrder = optFirstOrder.get();
        if (firstOrder.getPaymentType().equals("COD") || firstOrder.getPaymentStatus().equals(PaymentOrderStatus.PAYMENT_SUCCESSFUL.name())) {
            return null;
        }

        return firstOrder;

--- PostPaymentUpdateHelper | createPaymentCartEntity | CODE | 1/1 ---
    private void createPaymentCartEntity(PaymentEntity paymentEntity, String orderStatus) {
        List<LinkedHashMap<String, Object>> dealList;
        List<PaymentCartEntity> persistPaymentCartEntity = new ArrayList<>();

        try {
            dealList = objectMapper.readValue(paymentEntity.getProductInformation(), List.class);
        } catch (IOException e) {
            throw new JsonParserException("Failed to parse ProductInformation!!");
        }

        List<Long> orderIds = cartOrderMappingRepository.findAllByCartId(paymentEntity.getCartId()).get().stream().map(CartOrdersMapping::getOrderId).collect(Collectors.toList());
        List<OrderEntity> orderEntityList = orderRepo.findAllById(orderIds);

        dealList.forEach(x -> {
                PaymentCartEntity paymentCartEntity = new PaymentCartEntity();
                OrderEntity order = orderEntityList.stream().filter(y -> y.getDealId().equals(x.get("dealId"))).findAny().get();
                paymentCartEntity.setOrderPkId(order.getId());
                paymentCartEntity.setOrderStatus(orderStatus);
                paymentCartEntity.setProductInformation(paymentEntity.getProductInformation());
                paymentCartEntity.setAmount(new BigDecimal((int) x.get("dealPrice")));
                paymentCartEntity.setRefundAmount(new BigDecimal((int) x.get("dealPrice")));
                paymentCartEntity.setPaymentId(paymentEntity.getPaymentId());
                paymentCartEntity.setDealId(order.getDealId());
                paymentCartEntity.setOrderId(order.getOrderId());
                persistPaymentCartEntity.add(paymentCartEntity);
        });
        paymentCartRepo.saveAll(persistPaymentCartEntity);

--- PostPaymentUpdateHelper | checkOfflineToOnlineConversion | CODE | 1/1 ---
    Boolean checkOfflineToOnlineConversion(List<OrderEntity> updatedOrderEntities, List<Long> excludedIds) {
        Long userId = updatedOrderEntities.get(0).getUserId();
        String source = updatedOrderEntities.get(0).getSource();
        if (userId == null || !Source.APP.matches(source)) {
            return false;
        }

        Optional<OrderEntity> minimartOrder = orderRepo.findFirstByUserIdAndSource(
            userId,
            Source.MINIMART.getValue()
        );

        if(minimartOrder.isEmpty()) {
            return false;
        }

        return isFirstPurchase(excludedIds, updatedOrderEntities);

--- PostPaymentUpdateHelper | updateOrderForPaymentSuccessThroughCallback | CODE | 1/2 ---
    @Transactional
    public PaymentSuccessOrderStatusUpdate updateOrderForPaymentSuccessThroughCallback(PaymentEntity paymentEntity) {
        Long cartId = paymentEntity.getCartId();
//        log.error("updating for payment success through callback for Cart : {}, payment id : {}", cartId,paymentEntity.getTransactionId());

        updateCartStatus(paymentEntity);
        Optional<List<CartOrdersMapping>> cartOrdersMappingsOptional = cartOrderMappingRepository.findAllByCartId(cartId);

        if (cartOrdersMappingsOptional.isEmpty()) {
            log.error("{} - Invalid cart while payment successCallback, could not find orders in cart orders mapping table - cart id : {}", PAYMENT_SUCCESS_CALLBACK_MSG, cartId);
            return null;
        }

        List<Long> orderIds = cartOrdersMappingsOptional.get().stream()
                .map(CartOrdersMapping::getOrderId)
                .collect(Collectors.toList());

        OrderEntity firstValidOrder = isValidOnlineToBePaidOrder(orderIds);
        if (firstValidOrder == null) {
            log.error("{} - Invalid/COD/Already Paid Orders : {} in cart id : {}", PAYMENT_SUCCESS_CALLBACK_MSG, orderIds, cartId);
            return null;
        }

        Optional<PaymentRefundInfoEntity> paymentRefundInfoEntity = paymentRefundInfoRepo.findByPaymentIdAndStatus(paymentEntity.getTransactionId(), RefundTypes.LATE_PAYMENT.name());
        if (paymentRefundInfoEntity.isPresent()) {
            log.warn("Payment refund entity already exists for RP Payment ID : {}", paymentEntity.getTransactionId());
            return null;
        }

        List<OrderEntity> orderEntityList = orderRepo.findAllByIdWithLock(orderIds);
        String addressVerifiedStatus = getAddressVerifyStatus(firstValidOrder);

        log.info("{} - updating payment cart initiate for cart id : {}.", PAYMENT_SUCCESS_CALLBACK_MSG, cartId);
        updatePaymentCartInitiate(paymentEntity, orderEntityList, addressVerifiedStatus);

        if (isAllItemsDiscarded(orderEntityList)) {
            refundHelper.createPaymentRefundForPayment(paymentEntity);
            log.error("{} - All Items are discarded for cart id : {}", PAYMENT_SUCCESS_CALLBACK_MSG, cartId);
            return null;
        }

        List<String> dealIds = new ArrayList<>();
        log.info("{} - updating orders for cart id : {}.", PAYMENT_SUCCESS_CALLBACK_MSG, cartId);
        List<OrderEntity> updatedOrderEntities = orderStatusUpdateHelper.updateOrders(orderEntityList, dealIds, addressVerifiedStatus);

        log.info("{} - updating orders history for cart id : {}.", PAYMENT_SUCCESS_CALLBACK_MSG, cartId);
        updateOrdersHistory(updatedOrderEntities, PAYMENT_SUCCESS_CALLBACK);

        PaymentSuccessOrderStatusUpdate  paymentSuccessOrderStatusUpdate = new PaymentSuccessOrderStatusUpdate();
        paymentSuccessOrderStatusUpdate.setUpdatedOrderEntities(updatedOrderEntities);

--- PostPaymentUpdateHelper | raiseOrderStatusSuccessEvent | CODE | 1/2 ---
    public void raiseOrderStatusSuccessEvent(List<OrderEntity> updatedOrderEntities, Long cartId,JuspayCustomParameters juspayCustomParameters) {
        OrdersStatusUpdateEvent event = new OrdersStatusUpdateEvent();
        event.setOrderIds(updatedOrderEntities.stream()
                .map(OrderEntity::getId)
                .filter(Objects::nonNull)
                .collect(Collectors.toList()));
        event.setEvent(PaymentOrderStatus.ORDER_ONLINE_PAYMENT_COMPLETED.name());
        kafkaService.sendOrdersStatusUpdateTopic(event);

        List<Long> excludedIds = new ArrayList<>();
        if(!updatedOrderEntities.isEmpty()){
            excludedIds = updatedOrderEntities.stream()
                    .map(OrderEntity::getId)
                    .collect(Collectors.toList());
        }

        try {
            ThirdPartyDataPushEventModel eventModel = new ThirdPartyDataPushEventModel();
            eventModel.setEventType(PURCHASE);
            eventModel.setPlatform(juspayCustomParameters.getPlatform());
            eventModel.setEventTime(ZonedDateTime.now(ZoneId.of("Asia/Kolkata")).toString());
            ThirdPartyEventsParams modelParams = new ThirdPartyEventsParams();
            modelParams.setCartId(cartId.toString());
            modelParams.setUserId(updatedOrderEntities.get(0).getUserId().toString());
            modelParams.setDeviceId(juspayCustomParameters.getDeviceId());
            modelParams.setAppsFlyerId(juspayCustomParameters.getAppsFlyerId());
            modelParams.setInstanceId(juspayCustomParameters.getInstanceId());
            modelParams.setAdvertisingId(juspayCustomParameters.getAdvertisingId());
            eventModel.setThirdPartyEventsParams(modelParams);
            eventModel.setGetCartDetails(true);

            if (Objects.nonNull(juspayCustomParameters.getAppsFlyerId()) && !juspayCustomParameters.getAppsFlyerId().isEmpty()) {
                eventModel.setThirdPartyName(APPSFLYER);
                kafkaService.sendKafkaEvent(eventModel, cartUpdateEventsTopic);
            }
            eventModel.setThirdPartyName(ThirdPartyName.CLEVERTAP);
            kafkaService.sendKafkaEvent(eventModel, cartUpdateEventsTopic);

            if (Objects.nonNull(juspayCustomParameters.getInstanceId()) && !juspayCustomParameters.getInstanceId().isEmpty()) {
                eventModel.setThirdPartyName(ThirdPartyName.FIREBASE);
                kafkaService.sendKafkaEvent(eventModel, cartUpdateEventsTopic);
            }

            CommonUtils.noticeError("S2S PURCHASE", null, false);

            if (Objects.isNull(juspayCustomParameters.getAdvertisingId()) || juspayCustomParameters.getAdvertisingId().isEmpty()) {
                CommonUtils.noticeError("S2S PURCHASE NULL OR EMPTY ADVERTISING ID", null, false);
            }

            try {

--- PostPaymentUpdateHelper | updateOrderForPaymentSuccessThroughCallback | CODE | 2/2 ---
        log.info("{} - updating orders history for cart id : {}.", PAYMENT_SUCCESS_CALLBACK_MSG, cartId);
        updateOrdersHistory(updatedOrderEntities, PAYMENT_SUCCESS_CALLBACK);

        PaymentSuccessOrderStatusUpdate  paymentSuccessOrderStatusUpdate = new PaymentSuccessOrderStatusUpdate();
        paymentSuccessOrderStatusUpdate.setUpdatedOrderEntities(updatedOrderEntities);
        paymentSuccessOrderStatusUpdate.setFirstValidOrder(firstValidOrder);
        paymentSuccessOrderStatusUpdate.setDealIds(dealIds);
        return paymentSuccessOrderStatusUpdate;

--- PostPaymentUpdateHelper | raiseOrderStatusSuccessEvent | CODE | 2/2 ---
            if (Objects.isNull(juspayCustomParameters.getAdvertisingId()) || juspayCustomParameters.getAdvertisingId().isEmpty()) {
                CommonUtils.noticeError("S2S PURCHASE NULL OR EMPTY ADVERTISING ID", null, false);
            }

            try {
                boolean firstPurchase = isFirstPurchase(excludedIds, updatedOrderEntities);
                if (firstPurchase) {
                    eventModel.setEventType(FIRST_PURCHASE);
                    if (Objects.nonNull(juspayCustomParameters.getAppsFlyerId()) && !juspayCustomParameters.getAppsFlyerId().isEmpty()) {
                        eventModel.setThirdPartyName(APPSFLYER);
                        kafkaService.sendKafkaEvent(eventModel, cartUpdateEventsTopic);
                    }
                    eventModel.setThirdPartyName(ThirdPartyName.CLEVERTAP);
                    kafkaService.sendKafkaEvent(eventModel, cartUpdateEventsTopic);

                    if (Objects.nonNull(juspayCustomParameters.getInstanceId()) && !juspayCustomParameters.getInstanceId().isEmpty()) {
                        eventModel.setThirdPartyName(ThirdPartyName.FIREBASE);
                        kafkaService.sendKafkaEvent(eventModel, cartUpdateEventsTopic);
                    }
                }

                boolean isOfflineToOnlineConversion = checkOfflineToOnlineConversion(updatedOrderEntities, excludedIds);
                if (isOfflineToOnlineConversion) {
                    eventModel.setEventType(OFFLINE_TO_ONLINE_CONVERSION);
                    if (Objects.nonNull(juspayCustomParameters.getAppsFlyerId()) && !juspayCustomParameters.getAppsFlyerId().isEmpty()) {
                        eventModel.setThirdPartyName(APPSFLYER);
                        kafkaService.sendKafkaEvent(eventModel, cartUpdateEventsTopic);
                    }
                    eventModel.setThirdPartyName(ThirdPartyName.CLEVERTAP);
                    kafkaService.sendKafkaEvent(eventModel, cartUpdateEventsTopic);
                }
            } catch (Exception e) {
                log.error("Error while sending AppsFlyer event for cartId: {} - {}", cartId, e.getMessage(), e);
            }
        }catch (Exception e){
            log.error("error while raising order status success event: {}", e.getMessage(),e);
        }

        schedulerService.getScheduler().schedule(() -> {


ðŸ“„ FILE: RefundHelper.java

--- RefundHelper | getOrderUpdateEventDetail | CODE | 1/1 ---
    private OrderUpdateEventDetail getOrderUpdateEventDetail(PaymentEntity paymentEntity, UserAndUserPreferencesCacheModel userAndUserPreferenceCacheModel) {
        OrderUpdateEventDetail orderUpdateEventDetail = new OrderUpdateEventDetail();
        orderUpdateEventDetail.setEventType(REFUND_INITIATED_TRANSITION);
        orderUpdateEventDetail.setUserId(paymentEntity.getUserId().toString());
        orderUpdateEventDetail.setCartId(paymentEntity.getCartId());
        orderUpdateEventDetail.setPhone(userAndUserPreferenceCacheModel.getUserData().getPhone());
        orderUpdateEventDetail.setRefundAmount(paymentEntity.getTotalAmount().toString());

        Long cartId = paymentEntity.getCartId();
        Optional<List<CartOrdersMapping>> cartOrdersMapping = cartOrderMappingRepository.findAllByCartId(cartId);
        List<OrderUpdateEventDetail.OrderUpdateDetails> orderUpdateDetailsList = new ArrayList<>();
        if (cartOrdersMapping.isPresent()) {
            OrderUpdateEventDetail.OrderUpdateDetails orderUpdateDetails = new OrderUpdateEventDetail.OrderUpdateDetails();
            orderUpdateDetails.setOrderId(cartOrdersMapping.get().get(0).getOrderId());
            orderUpdateDetails.setEventType(REFUND_INITIATED_TRANSITION);
            orderUpdateDetailsList.add(orderUpdateDetails);
        }
        orderUpdateEventDetail.setOrderUpdateDetails(orderUpdateDetailsList);
        return orderUpdateEventDetail;


ðŸ“„ FILE: Task.java

--- Task | fetchLatePaymentRecords | CODE | 1/1 ---
    @Async
    public void fetchLatePaymentRecords(String orderDate, String toDate) {
        log.info("Cron fetchLatePaymentRecords fetchCancelledOrders Processing at: {} ",  LocalDateTime.now(TimeZone.getTimeZone("Asia/Kolkata").toZoneId()));
        refundService.getFailedPaymentFromPaymentInitiate(orderDate, toDate);
        log.info("Cron fetchLatePaymentRecords Finished Processing at:  {}",  LocalDateTime.now(TimeZone.getTimeZone("Asia/Kolkata").toZoneId()));
