Question: how do we sync minimart orders ?


ðŸŸ¦ SERVICE: chat-service
======================================================================

ðŸ“„ FILE: KafkaProvider.java

--- KafkaProvider | getLeadUpdateKafka | TEST | 1/1 ---
    public static final LeadUpdateKafka getLeadUpdateKafka() {
        LeadUpdateKafka leadUpdateKafka = new LeadUpdateKafka();
        leadUpdateKafka.setUpdatedBy("DS1911");
        leadUpdateKafka.setDispositionText(LeadDispositionType.ALREADY_DELIVERED.getValue());
        leadUpdateKafka.setContextId("U286191226608872");
        leadUpdateKafka.setContextType(LeadContextType.SHIPMENTS.getValue());
        return leadUpdateKafka;


ðŸ“„ FILE: LeadProvider.java

--- LeadProvider | getShipmentDetailsResponse | TEST | 1/1 ---
    public static BulkShipmentDetailsResponse getShipmentDetailsResponse(){
        BulkShipmentDetailsResponse bulkShipmentDetailsResponse = new BulkShipmentDetailsResponse();

        ShipmentDetailsDto shipmentDetailsDto = new ShipmentDetailsDto();
        shipmentDetailsDto.setId(549936736436127598L);
        shipmentDetailsDto.setDisplayId("U286191226608872");
        shipmentDetailsDto.setStatus("allotted");

        ShipmentItemDetailsDto itemDetailsDto = new ShipmentItemDetailsDto();
        itemDetailsDto.setStatus("in_process");
        OrderDetailsResponseModel orderDetailsResponseModel = new OrderDetailsResponseModel();
        OrderDetailsModel orderDetailsModel = new OrderDetailsModel();
        orderDetailsModel.setUserId(875445L);
        orderDetailsResponseModel.setOrderDetails(orderDetailsModel);
        itemDetailsDto.setShipmentItemOrderDetails(orderDetailsResponseModel);
        List<ShipmentItemDetailsDto> shipmentItemDetailsDtos = new ArrayList<>();
        shipmentItemDetailsDtos.add(itemDetailsDto);

        shipmentDetailsDto.setShipmentItemDetails(shipmentItemDetailsDtos);
        List<ShipmentDetailsDto> ls = new ArrayList<>();
        ls.add(shipmentDetailsDto);

        bulkShipmentDetailsResponse.setShipmentDetails(ls);
        return bulkShipmentDetailsResponse;


ðŸ“„ FILE: ShipmentDataProvider.java

--- ShipmentDataProvider | getShipmentDetailsDto | TEST | 1/1 ---
    public static ShipmentDetailsDto getShipmentDetailsDto(){
        ShipmentDetailsDto shipmentDetailsDto = new ShipmentDetailsDto();
        shipmentDetailsDto.setDisplayId(TEST_CONTEXT_ID);
        shipmentDetailsDto.setUpdatedAt(TEST_UPDATED_TIME);
        shipmentDetailsDto.setWarehouseId(TEST_WAREHOUSE_ID);
        shipmentDetailsDto.setStatus(TEST_SHIPMENT_STATUS);
        shipmentDetailsDto.setShipmentItemDetails(List.of(getShipmentItemDetails()));
        return shipmentDetailsDto;

--- ShipmentDataProvider | getShipmentItemDetails | TEST | 1/1 ---
    public static ShipmentItemDetailsDto getShipmentItemDetails(){
        ShipmentItemDetailsDto shipmentItemDetailsDto = new ShipmentItemDetailsDto();
        shipmentItemDetailsDto.setShipmentItemOrderDetails(getShipmentItemOrderDetails());
        return shipmentItemDetailsDto;

--- ShipmentDataProvider | getShipmentItemOrderDetails | TEST | 1/1 ---
    public static OrderDetailsResponseModel getShipmentItemOrderDetails(){
        OrderDetailsResponseModel orderDetailsResponseModel = new OrderDetailsResponseModel();
        orderDetailsResponseModel.setOrderDetails(getOrderDetailsModel());
        return orderDetailsResponseModel;

--- ShipmentDataProvider | getOrderDetailsModel | TEST | 1/1 ---
    public static OrderDetailsModel getOrderDetailsModel(){
        OrderDetailsModel orderDetailsModel = new OrderDetailsModel();
        orderDetailsModel.setName(TEST_CUSTOMER_NAME);
        orderDetailsModel.setPhone(TEST_PHONE_NUMBER);
        orderDetailsModel.setAmount(TEST_ORDER_AMOUNT);
        orderDetailsModel.setPaymentType(TEST_PAYMENT_TYPE);
        orderDetailsModel.setDeliveryBoyName(TEST_DELIVERY_BOY_NAME+"/"+TEST_DELIVERY_BOY_PHONE);
        return orderDetailsModel;


ðŸ“„ FILE: KafkaTest.java

--- KafkaTest | produceKafka | TEST | 1/1 ---
    @Test
    @DisplayName("Kafka producer Success")
    public void produceKafka() throws JsonProcessingException {
        String jsonData = "{\"contextType\":\"SHIPMENTS\",\"contextId\":\"U286191226608872\",\"dispositionText\":\"Delivered\",\"updatedBy\":\"DS1911\",\"createdDate\":null}";
        lenient().when(objectMapper.writeValueAsString(any())).thenReturn(jsonData);
        lenient().when(kafkaTemplate.send("topic",jsonData)).thenReturn(null);
        kafkaMessageProducer.produceLeadMessage(KafkaProvider.getLeadUpdateKafka(),"topic");


ðŸ“„ FILE: LeadCreateTest.java

--- LeadCreateTest | setup | TEST | 1/1 ---
    @BeforeEach
    public void setup() {
        MockitoAnnotations.initMocks(this);
        lenient().when(leadBasicDetailsProvider.getLeadBasicDetails(LeadContextType.SHIPMENTS))
            .thenReturn(shipmentLeadDetails);
        lenient().when(shipmentLeadDetails.createLead(LeadProvider.getLeadCreateRequestDto(),


ðŸ“„ FILE: GetLeadDetailsTest.java

--- GetLeadDetailsTest | setUp | TEST | 1/1 ---
    @BeforeEach
    void setUp(){

        warehouseEntity.setId(TEST_WAREHOUSE_ID.longValue());
        warehouseEntity.setWarehouseName(TEST_WAREHOUSE);

        lenient().when(leadRepository.findById(TEST_LEAD_ID)).thenReturn(Optional.of(leads));
        lenient().when(leadBasicDetailsProvider.getLeadBasicDetails(LeadContextType.valueOf(TEST_LEAD_CONTEXT_TYPE)))
                .thenReturn(shipmentLeadDetails);
        lenient().when(shipmentLeadDetails.getLeadDetails(leads))
                .thenReturn((ResponseModelProvider.getShipmentDetailsResponse()));
        lenient().when(userAddressServiceClient.getUserAddressDetail(any()))
                .thenReturn(ResponseModelProvider.getUserAddressResponseModel());
        lenient().when(dealIndexServiceClient.getOfferInfoByOfferId(any())).thenReturn(new ArrayList<>());
        lenient().when(warehouseRepository.findById(TEST_WAREHOUSE_ID.longValue()))


ðŸ“„ FILE: CreateLeadTest.java

--- CreateLeadTest | shipmentLeadCreateTestFail | TEST | 1/1 ---
    @Test
    @DisplayName("Shipment CreateLead Fail")
    public void shipmentLeadCreateTestFail() {
        BulkShipmentDetailsResponse data = new BulkShipmentDetailsResponse();
        data.setShipmentDetails(new ArrayList<>());
        when(routingServiceClientWrapper.getShipmentDetails(any(), any())).thenReturn(data);

        LeadServiceException exception = assertThrows(LeadServiceException.class, () -> {
            shipmentLeadDetails.createLead(LeadProvider.getLeadCreateRequestDto(),
                    CommonUtils.getCurrentLocalDateInIST());
        });
        assertThat(exception.getMessage()).isNotBlank();


ðŸ“„ FILE: KafkaConfig.java

--- KafkaConfig | kafkaListenerContainerFactory | CODE | 1/1 ---
  @Bean
  public ConcurrentKafkaListenerContainerFactory<String, String> kafkaListenerContainerFactory(){
    ConcurrentKafkaListenerContainerFactory<String, String> kafkaListenerContainerFactory= new ConcurrentKafkaListenerContainerFactory();
    kafkaListenerContainerFactory.setConsumerFactory(consumerFactory());

    return kafkaListenerContainerFactory;

--- KafkaConfig | ordersStatusUpdateTopic | CODE | 1/1 ---
  @Bean
  public NewTopic ordersStatusUpdateTopic(){
    return new NewTopic(ordersStatusUpdateTopic, 1, (short)2);


ðŸ“„ FILE: SqsConfig.java

--- SqsConfig | simpleMessageListenerContainerFactory | CODE | 1/1 ---
    @Bean
    public SimpleMessageListenerContainerFactory simpleMessageListenerContainerFactory() {
        SimpleMessageListenerContainerFactory msgListenerContainerFactory = new SimpleMessageListenerContainerFactory();
        msgListenerContainerFactory.setAmazonSqs(amazonSQSAsync());
        return msgListenerContainerFactory;

--- SqsConfig | amazonSQSAsync | CODE | 1/1 ---
    public AmazonSQSAsync amazonSQSAsync() {
        AmazonSQSAsyncClientBuilder amazonSQSAsyncClientBuilder = AmazonSQSAsyncClientBuilder.standard();
        AmazonSQSAsync amazonSQSAsync = null;
        amazonSQSAsyncClientBuilder.withRegion(region);
        BasicAWSCredentials basicAWSCredentials = new BasicAWSCredentials(accessKey, secretKey);
        amazonSQSAsyncClientBuilder.withCredentials(new AWSStaticCredentialsProvider(basicAWSCredentials));
        amazonSQSAsync = amazonSQSAsyncClientBuilder.build();
        return amazonSQSAsync;


ðŸ“„ FILE: SqsMessageReceiver.java

--- SqsMessageReceiver | receiveOrderSmsUpdatesComm | CODE | 1/1 ---
    @SqsListener("${aws.sqs.order-sms-updates.url}")
    public void receiveOrderSmsUpdatesComm(String message) throws JsonProcessingException {
        OrderSmsUpdatesDto orderSmsUpdatesDto = objectMapper.readValue(message, OrderSmsUpdatesDto.class);
        try {


ðŸ“„ FILE: ChatController.java

--- ChatController | syncRoom | CODE | 1/1 ---
    @GetMapping(value = "sync-room")
    public ResponseEntity<?> syncRoom(){
        return new ResponseEntity<>(chatService.syncRoom(), HttpStatus.OK);


ðŸ“„ FILE: PostOrderCommunicationService.java

--- PostOrderCommunicationService | saveCommunicationMessage | CODE | 1/1 ---
    private void saveCommunicationMessage(OrderUpdateEventDetail orderUpdateEventDetail, String template) {
        PostOrderCommunication postOrderCommunication = new PostOrderCommunication();
        postOrderCommunication.setUserId(orderUpdateEventDetail.getUserId());
        postOrderCommunication.setCartId(orderUpdateEventDetail.getCartId());
        postOrderCommunication.setEventType(orderUpdateEventDetail.getEventType());
        StringBuilder orderIds = new StringBuilder();
        for (OrderUpdateEventDetail.OrderUpdateDetails orderUpdateDetails : orderUpdateEventDetail.getOrderUpdateDetails()) {
            if (orderIds.length() > 0) {
                orderIds.append(",");
            }
            orderIds.append(orderUpdateDetails.getOrderId());
        }
        postOrderCommunication.setOrderIds(orderIds.toString());
        postOrderCommunicationRepo.save(postOrderCommunication);

--- PostOrderCommunicationService | getOrderPlacedDataMap | CODE | 1/1 ---
    private static Map<String, String> getOrderPlacedDataMap(OrderUpdateEventDetail orderUpdateEventDetail) {
        Map<String,String> data = new HashMap<>();

        if(Objects.isNull(orderUpdateEventDetail.getCartId()) || orderUpdateEventDetail.getOrderUpdateDetails().isEmpty()){
           throw new IllegalArgumentException("Invalid request to process for OFD transition");
        }

        data.put(CART_ID_KEY, String.valueOf(orderUpdateEventDetail.getCartId()));
        data.put(NO_OF_ITEMS_KEY, String.valueOf(orderUpdateEventDetail.getOrderUpdateDetails().size()));
        data.put(DELIVERY_TIME_KEY,orderUpdateEventDetail.getDeliveryEta());

        float discountAmount = 0;
        for (OrderUpdateEventDetail.OrderUpdateDetails orderUpdateDetail : orderUpdateEventDetail.getOrderUpdateDetails()) {
                if (orderUpdateDetail != null) {
                    discountAmount += (orderUpdateDetail.getDiscountAmount());
                }
        }



        data.put(DISCOUNT_AMOUNT_KEY, String.valueOf((int)discountAmount));
        data.put(ORDER_DETAILS_DEEP_LINK_KEY, OrderDetailsLink);
        return data;

--- PostOrderCommunicationService | getOutForDeliveryDataMap | CODE | 1/1 ---
    private static Map<String,String> getOutForDeliveryDataMap(OrderUpdateEventDetail orderUpdateEventDetail){
        Map<String,String> data = new HashMap<>();
        if(Objects.isNull(orderUpdateEventDetail.getDeliveryEta())){
            throw new IllegalArgumentException("Invalid request to process for OFD transition");
        }

        data.put(DELIVERY_TIME_KEY, orderUpdateEventDetail.getDeliveryEta());

        return data;

--- PostOrderCommunicationService | getDelayedOutForDeliveryDataMap | CODE | 1/1 ---
    private static Map<String,String> getDelayedOutForDeliveryDataMap(OrderUpdateEventDetail orderUpdateEventDetail){
        Map<String,String> data = new HashMap<>();
        if(Objects.isNull(orderUpdateEventDetail.getDeliveryEta())){
            throw new IllegalArgumentException("Invalid request to process for OFD transition");
        }

        data.put(DELIVERY_TIME_KEY, orderUpdateEventDetail.getDeliveryEta());

        return data;

--- PostOrderCommunicationService | getPartiallyDeliveredPrepaidOneItemDataMap | CODE | 1/1 ---
    private static Map<String,String> getPartiallyDeliveredPrepaidOneItemDataMap(OrderUpdateEventDetail orderUpdateEventDetail){
        Map<String,String> data = new HashMap<>();
        if(Objects.isNull(orderUpdateEventDetail.getRefundAmount())){
            throw new IllegalArgumentException("Invalid request to process for PartiallyDeliveredPrepaid transition");
        }

        data.put(REFUND_AMOUNT_KEY, String.valueOf(orderUpdateEventDetail.getRefundAmount()));

        return data;

--- PostOrderCommunicationService | getPartiallyDeliveredCODOneItemDataMap | CODE | 1/1 ---
    private static Map<String,String> getPartiallyDeliveredCODOneItemDataMap(OrderUpdateEventDetail orderUpdateEventDetail){
        Map<String,String> data = new HashMap<>();

        return data;

--- PostOrderCommunicationService | getPartiallyDeliveredPrepaidMultipleItemDataMap | CODE | 1/1 ---
    private static Map<String,String> getPartiallyDeliveredPrepaidMultipleItemDataMap(OrderUpdateEventDetail orderUpdateEventDetail){
        Map<String,String> data = new HashMap<>();
        if(Objects.isNull(orderUpdateEventDetail.getRefundAmount()) || orderUpdateEventDetail.getOrderUpdateDetails().isEmpty()){
            throw new IllegalArgumentException("Invalid request to process for PartiallyDeliveredPrepaid transition");
        }

        data.put(REFUND_AMOUNT_KEY, String.valueOf(orderUpdateEventDetail.getRefundAmount()));
        data.put(NO_OF_ITEMS_KEY, String.valueOf(orderUpdateEventDetail.getOrderUpdateDetails().size()));

        return data;

--- PostOrderCommunicationService | getPartiallyDeliveredCODMultipleItemDataMap | CODE | 1/1 ---
    private static Map<String,String> getPartiallyDeliveredCODMultipleItemDataMap(OrderUpdateEventDetail orderUpdateEventDetail){
        Map<String,String> data = new HashMap<>();
        if(orderUpdateEventDetail.getOrderUpdateDetails().isEmpty()){
            throw new IllegalArgumentException("Invalid request to process for PartiallyDeliveredCOD transition");
        }

        data.put(NO_OF_ITEMS_KEY, String.valueOf(orderUpdateEventDetail.getOrderUpdateDetails().size()));

        return data;

--- PostOrderCommunicationService | getDeliveredDataMap | CODE | 1/1 ---
    private static Map<String,String> getDeliveredDataMap(OrderUpdateEventDetail orderUpdateEventDetail){
        return new HashMap<>();

--- PostOrderCommunicationService | getCustomerNotReachableCancelledDataMap | CODE | 1/1 ---
    private static Map<String,String> getCustomerNotReachableCancelledDataMap(OrderUpdateEventDetail orderUpdateEventDetail){
        Map<String,String> data = new HashMap<>();
        if(Objects.isNull(orderUpdateEventDetail.getDeliveryEta())){
            throw new IllegalArgumentException("Invalid request to process for CustomerNotReachableCancelled transition");
        }

        data.put(DELIVERY_TIME_KEY, orderUpdateEventDetail.getDeliveryEta());

        return data;

--- PostOrderCommunicationService | getCustomerRefundInitiatedDataMap | CODE | 1/1 ---
    private static Map<String,String> getCustomerRefundInitiatedDataMap(OrderUpdateEventDetail orderUpdateEventDetail){
        Map<String,String> data = new HashMap<>();
        if(Objects.isNull(orderUpdateEventDetail.getRefundAmount())){
            throw new IllegalArgumentException("Invalid request to process for CustomerRefundInitiated transition");
        }

        data.put(REFUND_AMOUNT_KEY, String.valueOf(orderUpdateEventDetail.getRefundAmount()));

        return data;

--- PostOrderCommunicationService | getOrderDelayedDataMap | CODE | 1/1 ---
    private static Map<String,String> getOrderDelayedDataMap(OrderUpdateEventDetail orderUpdateEventDetail){
        return new HashMap<>();

--- PostOrderCommunicationService | processOrderCommunication | CODE | 1/2 ---
    @Transactional(transactionManager = "dataSourceTransactionManager")
    public void processOrderCommunication(OrderUpdateEventDetail orderUpdateEventDetail) {

        ValidateRequest(orderUpdateEventDetail);

        if(!orderUpdateEventDetail.getEventType().equalsIgnoreCase(REFUND_INITIATED_TRANSITION)) {
            PostOrderCommunication postOrderCommunication = postOrderCommunicationRepo.findByCartIdAndEventType(orderUpdateEventDetail.getCartId(), orderUpdateEventDetail.getEventType());
            if (Objects.nonNull(postOrderCommunication)) {
                log.info("Communication already sent for cartId: {}", orderUpdateEventDetail.getCartId());
                return;
            }
        }

        Integer warehouseIdByOrderId = orderRepository.findFirstWarehouseIdByOrderId(orderUpdateEventDetail.getOrderUpdateDetails().get(0).getOrderId());
        if (ObjectUtils.isEmpty(warehouseIdByOrderId)) {
            log.error("WarehouseId not found for order: {}", orderUpdateEventDetail.getOrderUpdateDetails().get(0).getOrderId());
            return;
        }

        boolean isOmniEnabled = Boolean.TRUE.equals(orderRepository.isWarehouseAStore(warehouseIdByOrderId));

        RiderWarehouseConfig riderWarehouseConfig = growthBookService.getRiderWarehouseEnabled(warehouseIdByOrderId, Long.valueOf(orderUpdateEventDetail.getUserId()));

        boolean isProcess = riderWarehouseConfig.isEnable() || isOmniEnabled;
        if (!isProcess) {
//            log.error("RiderWarehouse is not enabled for warehouseId: {} and userId: {}, {} , {}", warehouseIdByOrderId, orderUpdateEventDetail.getUserId(),isOmniEnabled, riderWarehouseConfig);
            return;
        }

        PostOrderCommunicationConfig config = growthBookService.getOrderCommunicationEnabled(Long.valueOf(orderUpdateEventDetail.getUserId()), warehouseIdByOrderId);
        if(!config.getEnable()){
            return;
        }

        SendSMSModel sendSMSModel = new SendSMSModel();
        sendSMSModel.setPhone(String.valueOf(orderUpdateEventDetail.getPhone()));


        Map<String, String> data = getStringStringMap(orderUpdateEventDetail);
        String template = formatTemplate(data, orderUpdateEventDetail.getEventType(),orderUpdateEventDetail.getLang());
        if (template.contains("Maybe soon")) {
            try {
                Long orderId = orderUpdateEventDetail.getOrderUpdateDetails().get(0).getOrderId();
                String eta = orderServiceClient.getOrderEta(orderId);
                log.error("Fetched eta {} from client : {}",eta,orderId);
                template = template.replace("Maybe soon", eta != null ? eta : "tomorrow");
            } catch (Exception e) {
                log.error("Failed to fetch delivery ETA for orderId {}", data.get("orderId"), e);
            }
        }

--- PostOrderCommunicationService | processOrderCommunication | CODE | 2/2 ---
                template = template.replace("Maybe soon", eta != null ? eta : "tomorrow");
            } catch (Exception e) {
                log.error("Failed to fetch delivery ETA for orderId {}", data.get("orderId"), e);
            }
        }
        sendSMSModel.setMessageText(template);
        sendSMSModel.setMessageType(KALEYRA_TXN_MESSAGE_TYPE);

        kaleyraMessageService.sendSMS(sendSMSModel);
        saveCommunicationMessage(orderUpdateEventDetail, template);


ðŸ“„ FILE: GrowthBookService.java

--- GrowthBookService | getOrderCommunicationEnabled | CODE | 1/1 ---
    public PostOrderCommunicationConfig getOrderCommunicationEnabled(Long userId, Integer warehouseId){
        Map<String, ?> attributesMap = new HashMap<>();
        attributesMap.put("userId", GrowthBookUtility.castToGenericType(userId));
        attributesMap.put("warehouse", GrowthBookUtility.castToGenericType(warehouseId));

        GrowthBook growthBook = growthBookFactory.newGrowthBook(attributesMap);

        PostOrderCommunicationConfig fallbackValue = new PostOrderCommunicationConfig();
        fallbackValue.setEnable(false);

        return growthBook.evalFeature("chat-service_post-order-sms", fallbackValue, PostOrderCommunicationConfig.class);


ðŸ“„ FILE: CommunicationService.java

--- CommunicationService | getDeeplinkForEvent | CODE | 1/1 ---
  private String getDeeplinkForEvent(CommunicationEvent event){
    switch(event){
      case ORDER_PLACED:
      case RESCHEDULED:
      case APP_CANCEL_COD:
      case APP_CANCEL_ONLINE:
      case DOORSTEP_CANCEL:
      case RETURN_PICKED:
      case INITIATE_REFUND:
      case REFUND_DONE:
        return AppConstants.ORDER_DETAIL_DEEPLINK;
      case OUT_FOR_DELIVERY:
      case DELIVERED:
        return AppConstants.ORDER_HISTORY_DEEPLINK;
      case SHIPMENT_FEEDBACK:
        return AppConstants.HOME_PAGE_DEEPLINK;
    }

    return "";

--- CommunicationService | resolveOrderPlaceholders | CODE | 1/1 ---
  private Map<String, String> resolveOrderPlaceholders(UserData userData, OrderInfoModel oneOrderInfo,
      CommunicationEventModel communicationEventModel) throws CommunicationException {

    Map<String, String> placeholdersMap = new HashMap<>();

    String itemNamePlaceholder = getDealName(userData, oneOrderInfo);
    placeholdersMap.put(PlaceholderConstants.ITEM_NAME, itemNamePlaceholder);

    List<Long> orderIds = communicationEventModel.getOrderIds();
    if(orderIds.size()> 1)
      itemNamePlaceholder = itemNamePlaceholder + " & " + (orderIds.size()- 1) + " more";

    placeholdersMap.put(PlaceholderConstants.ITEM_NAME_N_MORE, itemNamePlaceholder);

    placeholdersMap.put(PlaceholderConstants.ETA, oneOrderInfo.getDeliveryDate());

    CommunicationEvent event = communicationEventModel.getEvent();
    switch (event) {
      case RETURN_PICKED:
      case INITIATE_REFUND:
      case REFUND_DONE:
        BigDecimal billedAmount = getBilledAmount(orderIds);
        placeholdersMap.put(PlaceholderConstants.BILLED_AMOUNT, String.valueOf(billedAmount));
        break;
      case OUT_FOR_DELIVERY:
        List<UserShipmentModel> shipmentModels = cartServiceClient.getAllShipments(
            userData.getPhoneNumber(), oneOrderInfo.getSource(), userData.getId());
        if (CollectionUtils.isEmpty(shipmentModels) || shipmentModels.get(0).getDoorStepOtp() == null) {
          throw new CommunicationException("No OFD order for userId: " + userData.getId());
        }
        placeholdersMap.put(PlaceholderConstants.OTP, String.valueOf(shipmentModels.get(0).getDoorStepOtp()));
        break;
      case APP_CANCEL_ONLINE:
        long refundAmount = cartServiceClient.getOnlineRefundAmount(oneOrderInfo.getOrderPkId());
        placeholdersMap.put(PlaceholderConstants.BILLED_AMOUNT, String.valueOf(refundAmount));
        break;
      default:
        break;
    }

    return placeholdersMap;

--- CommunicationService | getBilledAmount | CODE | 1/1 ---
  private BigDecimal getBilledAmount(List<Long> orderIds) throws CommunicationException {
    List<RefundInfoModel> refundInfoModels = paymentServiceClient.getRefundsStatusByOrderIds(
        orderIds, "System", "System123");

    BigDecimal billedAmount = BigDecimal.ZERO;
    for(RefundInfoModel refundInfoModel: refundInfoModels){
      billedAmount = billedAmount.add(refundInfoModel.getAmount());
    }

    return billedAmount;

--- CommunicationService | getDealName | CODE | 1/1 ---
  private String getDealName(UserData userData, OrderInfoModel orderInfo){
    String dealName = orderInfo.getNameMap().get(userData.getLang());
    if(dealName != null)
      return dealName;

    return orderInfo.getNameMap().get("en");


ðŸ“„ FILE: KafkaConsumer.java

--- KafkaConsumer | listenOrdersStatusUpdates | CODE | 1/1 ---
  @KafkaListener(topics = "${kafka.topic-name.orders-status-update-topic}", groupId = "${kafka.group-id.orders-status-communication}", autoStartup = "true")
  public void listenOrdersStatusUpdates(String payload){
    CommunicationEventModel communicationEventModel = null;
    try{
      communicationEventModel = CommonUtils.parseJsonString(payload, CommunicationEventModel.class);
      communicationService.triggerCommunications(communicationEventModel);
    }catch(JsonProcessingException e){
//      log.error("Invalid payload: {}, JsonProcessingException: {}", payload, e.getMessage());
    }catch(Exception e){
//      log.error("Exception in processing the payload: {}, exception: {}", payload, e.getMessage());
    }
    try {

--- KafkaConsumer | processOrderStatusUpdateEvent | CODE | 1/1 ---
  @KafkaListener(topics = "${kafka-topic-name-post-order-sms}", groupId = "kafka.group-id.orders-update-chat-service-stage", autoStartup = "true")
  public void processOrderStatusUpdateEvent(String payload){
    try{


ðŸ“„ FILE: SmsServiceImpl.java

--- SmsServiceImpl | saveSmsHistory | CODE | 1/1 ---
    @Transactional(transactionManager = "dataSourceTransactionManager")
    public void saveSmsHistory(NotificationRequestBody notificationRequestBody){
        SMSQueueEntity smsQueueEntity = new SMSQueueEntity();
        smsQueueEntity.setCurrentState("TRIGGERED");
        Map<String, Object> parameters = new HashMap<>();
        parameters.put("orderIds", fetchOrderIdsBySource(notificationRequestBody.getShipmentModel(),
                notificationRequestBody.getSmsTypes().get("smsType")));
        parameters.put("phone", notificationRequestBody.getShipmentModel().getPhone());
        parameters.put("userId" , notificationRequestBody.getShipmentModel().getUserId());
        parameters.put("bagId", notificationRequestBody.getCartId());
        parameters.put("type", notificationRequestBody.getSmsTypes().get("messageType"));
        parameters.put("allocationId", notificationRequestBody.getShipmentModel().getAllocationId());
        String params = JSONObject.valueToString(parameters);
        smsQueueEntity.setParameters(params);
        smsQueueEntity.setUserId(notificationRequestBody.getShipmentModel().getUserId());
        smsQueueEntity.setReferenceId(Long.parseLong(String.valueOf(parameters.get("allocationId"))));
        smsQueueEntity.setSmstype(notificationRequestBody.getSmsTypes().get("smsType"));
        smsQueueEntity = smsQueueEntityRepository.save(smsQueueEntity);
        log.info("SMS queue entity created : " + smsQueueEntity.getId());

--- SmsServiceImpl | fetchOrderIdsBySource | CODE | 1/1 ---
    private List<Long> fetchOrderIdsBySource(ShipmentModel shipmentModel, String smsType){
        switch(smsType){


ðŸ“„ FILE: CoreChatServiceImpl.java

--- CoreChatServiceImpl | syncRoom | CODE | 1/1 ---
    @Override
    public List<ChatRoom> syncRoom() {
        String token = pusherHelper.generateToken("1", true, false);
        List<JsonNode> roomList = pusherClient.getRooms(token);
        List<ChatRoom> chatRoomsList = roomList.stream().map(item -> {
            ChatRoom chatRoom = new ChatRoom();
            chatRoom.setRoomName(item.get("name").asText());
            chatRoom.setPusherRoomId(item.get("id").asText());
            chatRoom.setCreatedAt(item.get("created_at").asText());
            chatRoom.setCreatedById(item.get("created_by_id").asText());
            chatRoom.setRoomType(item.get("private").asBoolean());
            chatRoom.setUpdatedAt(item.get("updated_at").asText());
            return chatRoom;
        }).collect(Collectors.toList());
        return chatRoomRepository.saveAll(chatRoomsList);


ðŸ“„ FILE: RescheduleOrderTrigger.java

--- RescheduleOrderTrigger | processEvent | CODE | 1/1 ---
    @Override
    @Transactional(transactionManager = "dataSourceTransactionManager")
    public Map<String, Object> processEvent(ShipmentModel shipmentModel) {
        Map<String, Object> errorMessage = new HashMap<>();
        if (CollectionUtils.isEmpty(shipmentModel.getRescheduled()))
            return new HashMap<>();

        Optional<Order> order = ordersRepository.findById(shipmentModel.getRescheduled().get(0));
        if (!order.isPresent()) {
            errorMessage.put(AppConstants.ERROR_KEY, String.format("Order id %s does not exist .", shipmentModel.getRescheduled().get(0)));
            return errorMessage;
        }

        if (!order.get().getUserId().equals(shipmentModel.getUserId())) {
            errorMessage.put(AppConstants.ERROR_KEY, String.format("Order id %s does not belong to user %s .", shipmentModel.getRescheduled().get(0), shipmentModel.getUserId()));
            return errorMessage;
        }
        if (!order.get().getStatus().equals("outfordelivery")) {
            errorMessage.put(AppConstants.ERROR_KEY, String.format("Order id %s is not in outfordelivery state and user ID  %s", shipmentModel.getRescheduled().get(0), shipmentModel.getUserId()));
            return errorMessage;
        }
        if (Arrays.asList(0, 1).contains(order.get().getSkipBts())) {
            errorMessage.put(AppConstants.ERROR_KEY, String.format("User has already provided response for order ID  %s and user ID  %s", shipmentModel.getRescheduled().get(0), shipmentModel.getUserId()));
            return errorMessage;
        }
        Long cartID = ordersRepository.getCartIdForOrderId(order.get().getId());

        Map<String, Object> response = new HashMap<>();
        NotificationRequestBody notificationRequestBody = buildNotificationRequestBody(shipmentModel, order.get(), cartID);
        response.put("firebase_response", triggerNotification(notificationRequestBody));
        response.put("sms_response", triggerSms(notificationRequestBody));
        return response;

--- RescheduleOrderTrigger | buildNotificationRequestBody | CODE | 1/1 ---
    private NotificationRequestBody buildNotificationRequestBody(ShipmentModel shipmentModel, Order order, Long cartID){
        NotificationRequestBody notificationRequestBody = new NotificationRequestBody();
        notificationRequestBody.setShipmentModel(shipmentModel);
        notificationRequestBody.setOrder(order);
        notificationRequestBody.setCartId(cartID);
        Map<String, String> smsTypes = new HashMap<>();
        smsTypes.put("messageType", "reschedule");
        smsTypes.put("smsType", "RIDER_ORDER_RESCHEDULE");
        notificationRequestBody.setSmsTypes(smsTypes);
        return notificationRequestBody;

--- RescheduleOrderTrigger | triggerSms | CODE | 1/1 ---
    @Override
    @Transactional(transactionManager = "dataSourceTransactionManager")
    public String triggerSms(NotificationRequestBody notificationRequestBody) {
        try {
            // need to update these orders in sms queue table
            smsService.saveSmsHistory(notificationRequestBody);
            String productSpec = orderDao.getProductNameFromDealIdAndLang(notificationRequestBody.getOrder().getOfferId(), "en");
            Integer count = notificationRequestBody.getShipmentModel().getRescheduled().size() - 1;
            String text;
            String replaceText = "";
            if(count==0) text = "+ {X} items ";
            else {
                text = "{X}";
                replaceText=String.valueOf(count);
            }
            String message = AppConstants.RIDER_RESCHEDULE_REVIEW_SMS_TEMPLATE.replace("productName", StringUtils.abbreviate(productSpec, 30));
            message = message.replace(text, replaceText);
            message = message.replace("LINK", AppConstants.RIDER_RESCHEDULE_SMS_DEEPLINK);
            log.info(message);
            SendSMSModel messageModel = new SendSMSModel();
            messageModel.setMessageText(message);
            messageModel.setMessageUserId(messageUserId);
            messageModel.setMessagePassword(messagePassword);
            messageModel.setPhone(notificationRequestBody.getShipmentModel().getPhone());
            return "Sending msgs stopped";
        }
        catch (Exception e) {
            log.error("Error occurred while triggering sms with exception = {}",e.toString());
        }
        return null;


ðŸ“„ FILE: OrderDeliveredTrigger.java

--- OrderDeliveredTrigger | processEvent | CODE | 1/1 ---
    @Override
    @Transactional(transactionManager = "dataSourceTransactionManager")
    public Map<String, Object> processEvent(ShipmentModel shipmentModel) {
        Map<String, Object> errorMessage = new HashMap<>();
        if (CollectionUtils.isEmpty(shipmentModel.getDelivered()))
            return new HashMap<>();

        Optional<Order> order = ordersRepository.findById(shipmentModel.getDelivered().get(0));
        if (!order.isPresent()) {
            errorMessage.put(ERROR_KEY, String.format("Order id %s does not exist .", shipmentModel.getDelivered().get(0)));
            return errorMessage;
        }

        if (!order.get().getUserId().equals(shipmentModel.getUserId())) {
            errorMessage.put(ERROR_KEY, String.format("Order id %s does not belong to user %s .", shipmentModel.getDelivered().get(0), shipmentModel.getUserId()));
            return errorMessage;
        }
        if (!order.get().getStatus().equals("outfordelivery")) {
            errorMessage.put(ERROR_KEY, String.format("Order id %s is not in outfordelivery state.", shipmentModel.getDelivered().get(0)));
            return errorMessage;
        }
        if (Arrays.asList(0, 1).contains(order.get().getSkipBts())) {
            errorMessage.put(ERROR_KEY, "User has already provided response for orders.");
            return errorMessage;
        }
        Long cartID = ordersRepository.getCartIdForOrderId(order.get().getId());

        Map<String, Object> response = new HashMap<>();
        NotificationRequestBody notificationRequestBody = buildNotificationRequestBody(shipmentModel, order.get(), cartID);
        response.put("firebase_response", triggerNotification(notificationRequestBody));
        response.put("sms_response", triggerSms(notificationRequestBody));
        return response;

--- OrderDeliveredTrigger | buildNotificationRequestBody | CODE | 1/1 ---
    private NotificationRequestBody buildNotificationRequestBody(ShipmentModel shipmentModel, Order order, Long cartID){
        NotificationRequestBody notificationRequestBody = new NotificationRequestBody();
        notificationRequestBody.setShipmentModel(shipmentModel);
        notificationRequestBody.setOrder(order);
        notificationRequestBody.setCartId(cartID);
        return notificationRequestBody;

--- OrderDeliveredTrigger | triggerSms | CODE | 1/2 ---
    @Override
    @Transactional(transactionManager = "dataSourceTransactionManager")
    public String triggerSms(NotificationRequestBody notificationRequestBody) {
        try {
            // need to update these orders in sms queue table
            SMSQueueEntity smsQueueEntity = new SMSQueueEntity();
            smsQueueEntity.setCurrentState("TRIGGERED");
            Map<String, Object> parameters = new HashMap<>();
            parameters.put("orderIds", notificationRequestBody.getShipmentModel().getDelivered());
            parameters.put("phone", notificationRequestBody.getShipmentModel().getPhone());
            parameters.put("userId" , notificationRequestBody.getShipmentModel().getUserId());
            parameters.put("bagId", notificationRequestBody.getCartId());
            parameters.put("type", "delivered");
            parameters.put("allocationId", notificationRequestBody.getShipmentModel().getAllocationId());
            String params = JSONObject.valueToString(parameters);
            smsQueueEntity.setParameters(params);
            smsQueueEntity.setUserId(notificationRequestBody.getShipmentModel().getUserId());
            smsQueueEntity.setReferenceId(Long.parseLong(String.valueOf(parameters.get("allocationId"))));
            smsQueueEntity.setSmstype("RIDER_ORDER_DELIVERED");
            smsQueueEntity = smsQueueEntityRepository.save(smsQueueEntity);
            log.info("SMS queue entity created : " + smsQueueEntity.getId());
            String productSpec = orderDao.getProductNameFromDealIdAndLang(notificationRequestBody.getOrder().getOfferId(), "en");
            Integer count = notificationRequestBody.getShipmentModel().getDelivered().size() - 1;
            String text;
            String replaceText = "";
            if(count==0) text = "+ {X} items ";
            else {
                text = "{X}";
                replaceText=String.valueOf(count);
            }
            String message = AppConstants.RIDER_DELIVERED_REVIEW_SMS_TEMPLATE.replace("productName", StringUtils.abbreviate(productSpec, 30));
            message = message.replace(text, replaceText);
            message = message.replace("LINK", AppConstants.RIDER_DELIVERED_SMS_DEEPLINK);
            log.info(message);
            SendSMSModel messageModel = new SendSMSModel();
            messageModel.setMessageText(message);
            messageModel.setMessageUserId(messageUserId);
            messageModel.setMessagePassword(messagePassword);
            messageModel.setPhone(notificationRequestBody.getShipmentModel().getPhone());
            return "Sending msgs stopped";
        }
        catch (Exception e) {
            log.error("Error occurred while triggering sms with exception = {}",e.toString());
        }
        return null;


ðŸ“„ FILE: CancelOrderTrigger.java

--- CancelOrderTrigger | processEvent | CODE | 1/1 ---
    @Override
    @Transactional(transactionManager = "dataSourceTransactionManager")
    public Map<String, Object> processEvent(ShipmentModel shipmentModel) {
        Map<String, Object> errorMessage = new HashMap<>();
        if (CollectionUtils.isEmpty(shipmentModel.getCancelled()))
            return new HashMap<>();

        Optional<Order> order = ordersRepository.findById(shipmentModel.getCancelled().get(0));
        if (!order.isPresent()) {
            errorMessage.put(ERROR_KEY, String.format("Order id %s does not exist .", shipmentModel.getCancelled().get(0)));
            return errorMessage;
        }

        if (!order.get().getUserId().equals(shipmentModel.getUserId())) {
            errorMessage.put(ERROR_KEY, String.format("Order id %s does not belong to user %s .", shipmentModel.getCancelled().get(0), shipmentModel.getUserId()));
            return errorMessage;
        }
        if (!order.get().getStatus().equals("outfordelivery")) {
            errorMessage.put(ERROR_KEY, String.format("Order id %s is not in outfordelivery state.", shipmentModel.getCancelled().get(0)));
            return errorMessage;
        }
        if (Arrays.asList(0, 1).contains(order.get().getSkipBts())) {
            errorMessage.put(ERROR_KEY, "User has already provided response for orders.");
            return errorMessage;
        }
        Long cartID = ordersRepository.getCartIdForOrderId(order.get().getId());

        Map<String, Object> response = new HashMap<>();
        NotificationRequestBody notificationRequestBody = buildNotificationRequestBody(shipmentModel, order.get(), cartID);
        Map<String, Object> notificationResponse = triggerNotification(notificationRequestBody);
        notificationResponse.forEach((k, v) -> response.put(k, v));
        response.put("sms_response", triggerSms(notificationRequestBody));
        return response;

--- CancelOrderTrigger | buildNotificationRequestBody | CODE | 1/1 ---
    private NotificationRequestBody buildNotificationRequestBody(ShipmentModel shipmentModel, Order order, Long cartID){
        NotificationRequestBody notificationRequestBody = new NotificationRequestBody();
        notificationRequestBody.setShipmentModel(shipmentModel);
        notificationRequestBody.setOrder(order);
        notificationRequestBody.setCartId(cartID);
        Map<String, String> smsTypes = new HashMap<>();
        smsTypes.put("messageType", "cancel");
        smsTypes.put("smsType", "RIDER_ORDER_CANCEL");
        notificationRequestBody.setSmsTypes(smsTypes);
        return notificationRequestBody;

--- CancelOrderTrigger | triggerSms | CODE | 1/1 ---
    @Override
    @Transactional(transactionManager = "dataSourceTransactionManager")
    public String triggerSms(NotificationRequestBody notificationRequestBody) {
        try {
            // need to update these orders in sms queue table
            smsService.saveSmsHistory(notificationRequestBody);
            String productSpec = orderDao.getProductNameFromDealIdAndLang(notificationRequestBody.getOrder().getOfferId(), "en");
            Integer count = notificationRequestBody.getShipmentModel().getCancelled().size() - 1;
            String text;
            String replaceText = "";
            if(count==0) text = "+ {X} items ";
            else {
                text = "{X}";
                replaceText=String.valueOf(count);
            }
            String message = AppConstants.RIDER_CANCELLATION_REVIEW_SMS_TEMPLATE.replace("productName", StringUtils.abbreviate(productSpec, 30));
            message = message.replace(text, replaceText);
            message = message.replace("LINK", AppConstants.RIDER_CANCEL_SMS_DEEPLINK);
            log.info(message);
            SendSMSModel messageModel = new SendSMSModel();
            messageModel.setMessageText(message);
            messageModel.setMessageUserId(messageUserId);
            messageModel.setMessagePassword(messagePassword);
            messageModel.setPhone(notificationRequestBody.getShipmentModel().getPhone());
            return "Sending msgs stopped";
        }
        catch (Exception e) {
            log.error("Error occurred while triggering sms with exception = {}",e.toString());
        }
        return null;


ðŸ“„ FILE: LeadServiceImpl.java

--- LeadServiceImpl | getLeadBasicDetails | CODE | 1/1 ---
    private List<LeadBasicAttributes> getLeadBasicDetails(ShipmentDetailsDto shipmentDetails,Long leadId){

        List<LeadBasicAttributes> leadBasicDetails = new ArrayList<>();
        OrderDetailsModel orderDetails = shipmentDetails.getShipmentItemDetails().get(0).getShipmentItemOrderDetails().getOrderDetails();

        leadBasicDetails.add(new LeadBasicAttributes(LeadBasicDetailsKeys.LEAD_ID.getValue(), leadId.toString()));
        leadBasicDetails.add(new LeadBasicAttributes
                (LeadBasicDetailsKeys.CUSTOMER_NAME.getValue(),orderDetails.getName()));
        leadBasicDetails.add(new LeadBasicAttributes
                (LeadBasicDetailsKeys.PHONE_NUMBER.getValue(),orderDetails.getPhone()));
        leadBasicDetails.add(new LeadBasicAttributes
                (LeadBasicDetailsKeys.SHIPMENT_ID.getValue(), shipmentDetails.getDisplayId()));
        UserAddressResponseModel userAddressResponseModel = userAddressServiceClient.getUserAddressDetail(orderDetails.getUserAddressId());
        String address = userAddressResponseModel.getAddress() + ", "+userAddressResponseModel.getCityName();
        leadBasicDetails.add(new LeadBasicAttributes
                (LeadBasicDetailsKeys.ADDRESS.getValue(),address));
        Optional<WarehouseEntity> warehouseEntity = warehouseRepository.findById(shipmentDetails.getWarehouseId().longValue());
        if (warehouseEntity.isPresent()){
            leadBasicDetails.add(new LeadBasicAttributes
                    (LeadBasicDetailsKeys.WAREHOUSE.getValue(), warehouseEntity.get().getWarehouseName()));
        } else {
            leadBasicDetails.add(new LeadBasicAttributes
                    (LeadBasicDetailsKeys.WAREHOUSE.getValue(), "Warehouse Not found"));
        }
        leadBasicDetails.add(new LeadBasicAttributes(
                LeadBasicDetailsKeys.UPDATED_DATE.getValue(),shipmentDetails.getUpdatedAt().format(DateTimeFormatter.ofPattern("dd-MM-yyyy"))));
        leadBasicDetails.add(new LeadBasicAttributes(
                LeadBasicDetailsKeys.UPDATED_TIME.getValue(), shipmentDetails.getUpdatedAt().format(DateTimeFormatter.ofPattern("hh:mm:ss a"))));
        leadBasicDetails.add(new LeadBasicAttributes(
                LeadBasicDetailsKeys.REQUEST_TYPE.getValue(), shipmentDetails.getStatus(),"#E15D5D"));
        leadBasicDetails.add(new LeadBasicAttributes(
                LeadBasicDetailsKeys.AGENT_ACTION.getValue(), getAgentAction(leadId),"#55A447"));
        Leads leads = getLeadById(leadId);
        leadBasicDetails.add(new LeadBasicAttributes(
                LeadBasicDetailsKeys.CALL_STATUS.getValue(),leads==null?null:leads.getTelephonyStatus()));

        return leadBasicDetails;

--- LeadServiceImpl | getLeadItemDetails | CODE | 1/1 ---
    private List<Map<String,Object>> getLeadItemDetails(List<ShipmentItemDetailsDto> shipmentItemDetails){

        List<String> offerIds = new ArrayList<>();
        List<OrderDetailsModel> orderDetailsList = new ArrayList<>();
        for (ShipmentItemDetailsDto itemDetails:shipmentItemDetails){
            if (itemDetails.getShipmentItemOrderDetails()==null)
                continue;
            OrderDetailsModel orderDetails = itemDetails.getShipmentItemOrderDetails().getOrderDetails();
            offerIds.add(orderDetails.getOfferId());
            orderDetailsList.add(orderDetails);
        }

        List<OfferResponseModel> offerResponseModels =  dealIndexServiceClient.getOfferInfoByOfferId(offerIds);

        List<Map<String,Object>> leadItemsDetails = new ArrayList<>();
        for (int i=0;i<offerResponseModels.size();i++){
            Map<String,Object> leadItem = new LinkedHashMap<>();
            String productName = String.format("<div style = display:flex;align-items:center><img src=%s alt='image not present' height = 50px width = 50px /><p>%s</p></div>", offerResponseModels.get(i).getImage(), offerResponseModels.get(i).getTitle().get("en"));
            leadItem.put(LeadItemsSchema.PRODUCT_NAME.getKey(), productName);
            leadItem.put(LeadItemsSchema.ORDER_ID.getKey(), orderDetailsList.get(i).getId().toString());
            leadItem.put(LeadItemsSchema.ORDER_QUANTITY.getKey(), orderDetailsList.get(i).getQuantity());
            leadItem.put(LeadItemsSchema.ORDER_DATE.getKey(), orderDetailsList.get(i).getOrderDate().format(DateTimeFormatter.ofPattern("dd-MM-yyyy")));
            leadItem.put(LeadItemsSchema.ORDER_AMOUNT.getKey(), orderDetailsList.get(i).getAmount().doubleValue());
            leadItemsDetails.add(leadItem);
        }
        return leadItemsDetails;


ðŸŸ¦ SERVICE: cart-service
======================================================================

ðŸ“„ FILE: V1UserPhoneCartIdTest.java

--- V1UserPhoneCartIdTest | testFetchEtaForOrders_IndividualOrderParseException | TEST | 1/2 ---
    @Test
    public void testFetchEtaForOrders_IndividualOrderParseException() throws Exception {
        // Arrange
        List<Long> orderIds = Arrays.asList(101L, 102L);
        
        // Create warehouse delivery ETAs
        List<WarehouseDeliveryEtaEntity> etaEntities = new ArrayList<>();
        
        // Create ETA for order 101 (with valid date)
        WarehouseDeliveryEtaEntity eta1 = new WarehouseDeliveryEtaEntity();
        eta1.setId(1L);
        eta1.setOrderId(101L);
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        Date deliveryDate1 = sdf.parse("2025-01-01");
        eta1.setDeliveryDate(deliveryDate1);
        
        // Create ETA for order 102 
        WarehouseDeliveryEtaEntity eta2 = new WarehouseDeliveryEtaEntity();
        eta2.setId(2L);
        eta2.setOrderId(102L);
        Date deliveryDate2 = sdf.parse("2025-01-02"); // Use a valid date, we'll mock the exception
        eta2.setDeliveryDate(deliveryDate2);
        
        etaEntities.add(eta1);
        etaEntities.add(eta2);
        
        // Mock repository response
        when(warehouseEtaDeliveryRepository.findAllByOrderIdInOrderByDeliveryDateDesc(orderIds))
            .thenReturn(Optional.of(etaEntities));
        
        // Create a partial mock of EtaServiceImpl to capture and validate the calls
        EtaServiceImpl spyEtaService = spy(new EtaServiceImpl());
        ReflectionTestUtils.setField(spyEtaService, "warehouseEtaDeliveryRepository", warehouseEtaDeliveryRepository);
        
        // Make order 101 format successfully
        doReturn("01 January, 2025").when(spyEtaService).fetchEtaForOrder(101L);
        
        // Make order 102 format throw exception - return empty string instead of null
        doReturn("").when(spyEtaService).fetchEtaForOrder(102L);
        
        // Make cart level ETA format successfully
        doReturn("01 January, 2025").when(spyEtaService).fetchEtaForOrder(CART_LEVEL_ETA);
        
        // Act
        Map<Long, String> result = spyEtaService.fetchEtaForOrders(orderIds);
        
        // Assert
        assertNotNull(result);
        assertEquals(3, result.size());  // All entries are included in the result map
        assertTrue(result.containsKey(101L));  // Order 101 has a valid date

--- V1UserPhoneCartIdTest | testFetchEtaForOrders_BothParseExceptions | TEST | 1/2 ---
    @Test
    public void testFetchEtaForOrders_BothParseExceptions() throws Exception {
        // Arrange
        List<Long> orderIds = Arrays.asList(101L, 102L);
        
        // Create warehouse delivery ETAs
        List<WarehouseDeliveryEtaEntity> etaEntities = new ArrayList<>();
        
        // Create ETA for order 101 with valid date
        WarehouseDeliveryEtaEntity eta1 = new WarehouseDeliveryEtaEntity();
        eta1.setId(1L);
        eta1.setOrderId(101L);
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        Date deliveryDate1 = sdf.parse("2025-01-01");
        eta1.setDeliveryDate(deliveryDate1);
        
        // Create ETA for order 102 with valid date
        WarehouseDeliveryEtaEntity eta2 = new WarehouseDeliveryEtaEntity();
        eta2.setId(2L);
        eta2.setOrderId(102L);
        Date deliveryDate2 = sdf.parse("2025-01-02");
        eta2.setDeliveryDate(deliveryDate2);
        
        etaEntities.add(eta1);
        etaEntities.add(eta2);
        
        // Mock repository response
        when(warehouseEtaDeliveryRepository.findAllByOrderIdInOrderByDeliveryDateDesc(orderIds))
            .thenReturn(Optional.of(etaEntities));
        
        // Create a partial mock for EtaServiceImpl
        EtaServiceImpl spyEtaService = spy(new EtaServiceImpl());
        ReflectionTestUtils.setField(spyEtaService, "warehouseEtaDeliveryRepository", warehouseEtaDeliveryRepository);
        
        // Make order 101 throw exception - return empty string
        doReturn("").when(spyEtaService).fetchEtaForOrder(101L);
        
        // Make order 102 throw exception - return empty string
        doReturn("").when(spyEtaService).fetchEtaForOrder(102L);
        
        // Make cart level ETA throw exception - return empty string
        doReturn("").when(spyEtaService).fetchEtaForOrder(CART_LEVEL_ETA);
        
        // Act
        Map<Long, String> result = spyEtaService.fetchEtaForOrders(orderIds);
        
        // Assert
        assertNotNull(result);
        assertEquals(3, result.size());  // All entries included but with empty strings
        assertTrue(result.containsKey(101L));  // Order 101 included with empty string

--- V1UserPhoneCartIdTest | testFetchEtaForOrders_IndividualOrderParseException | TEST | 2/2 ---
        
        // Assert
        assertNotNull(result);
        assertEquals(3, result.size());  // All entries are included in the result map
        assertTrue(result.containsKey(101L));  // Order 101 has a valid date
        assertTrue(result.containsKey(102L));  // Order 102 is included but with empty string
        assertTrue(result.containsKey(CART_LEVEL_ETA));  // Cart level ETA included
        
        // Verify method was called with expected parameters
        verify(spyEtaService).fetchEtaForOrders(orderIds);

--- V1UserPhoneCartIdTest | testFetchEtaForOrders_BothParseExceptions | TEST | 2/2 ---
        
        // Assert
        assertNotNull(result);
        assertEquals(3, result.size());  // All entries included but with empty strings
        assertTrue(result.containsKey(101L));  // Order 101 included with empty string
        assertTrue(result.containsKey(102L));  // Order 102 included with empty string
        assertTrue(result.containsKey(CART_LEVEL_ETA));  // Cart level ETA included with empty string
        
        // Verify method was called with expected parameters
        verify(spyEtaService).fetchEtaForOrders(orderIds);


ðŸ“„ FILE: MyOrderServiceImplTest.java

--- MyOrderServiceImplTest | createTestOrders | TEST | 1/1 ---
    private List<Order> createTestOrders() {
        List<Order> orders = new ArrayList<>();

        Order order1 = new Order();
        order1.setId(1L);
        order1.setOrderId("ORDER001");
        order1.setOfferId("OFFER001");
        order1.setOrderStatus("delivered");
        order1.setOrderType("normal");
        order1.setSource("B2C");
        order1.setPhone(phoneNumber);
        order1.setAmount(100.00);
        order1.setBilledAmount(100.00);
        order1.setQuantity(1L);
        order1.setPaymentType("COD");
        order1.setPaymentStatus("COMPLETED");
        order1.setOrderDate(new Date());
        orders.add(order1);

        Order order2 = new Order();
        order2.setId(2L);
        order2.setOrderId("ORDER002");
        order2.setOfferId("OFFER002");
        order2.setOrderStatus("cancelled");
        order2.setOrderType("normal");
        order2.setSource("B2C");
        order2.setPhone(phoneNumber);
        order2.setAmount(200.00);
        order2.setBilledAmount(200.00);
        order2.setQuantity(1L);
        order2.setPaymentType("COD");
        order2.setPaymentStatus("CANCELLED");
        order2.setOrderDate(new Date());
        orders.add(order2);

        return orders;

--- MyOrderServiceImplTest | createMockOrderForCancellation | TEST | 1/1 ---
    private Order createMockOrderForCancellation() {
        Order order = new Order();
        order.setId(1001L);
        order.setUserId(12345L);
        order.setOrderStatus("processing"); // Cancellable status
        order.setPaymentType("COD"); // Not PAYTM pending to avoid early return
        order.setOfferId("OFFER123");
        order.setAmount(500.0);
        order.setBilledAmount(450.0);
        order.setQuantity(2L);
        order.setUserAddressId(5001L);
        order.setOrderType("main"); // Not ORD to proceed with processing
        return order;


ðŸ“„ FILE: ExpressDeliveryServiceImplTest.java

--- ExpressDeliveryServiceImplTest | testOrderSyncException | TEST | 1/1 ---
    @Test
    public void testOrderSyncException() throws Exception {
        // We need to access the private syncOrdersToIms method
        Method syncOrdersToImsMethod = ExpressDeliveryServiceImpl.class.getDeclaredMethod(
            "syncOrdersToIms", List.class, long.class);
        syncOrdersToImsMethod.setAccessible(true);
        
        // Create test data
        List<DealLevelPromotion> cartItems = new ArrayList<>();
        DealLevelPromotion item1 = new DealLevelPromotion();
        item1.setDeliveryType(DeliveryType.EXPRESS.name());
        item1.setOrderPKId(101L);
        
        DealLevelPromotion item2 = new DealLevelPromotion();
        item2.setDeliveryType(DeliveryType.EXPRESS.name());
        item2.setOrderPKId(102L);
        
        cartItems.add(item1);
        cartItems.add(item2);
        
        // Mock the orderServiceClient to throw an exception
        when(orderServiceClient.syncOrderService(any()))
            .thenThrow(new RuntimeException("Sync Failed"));
        
        // Invoke the private method
        syncOrdersToImsMethod.invoke(expressDeliveryService, cartItems, 1001L);
        
        // Verify that orderServiceClient was called with an OrderPushToImsRequest 
        // containing the correct order IDs and warehouse ID
        ArgumentCaptor<OrderPushToImsRequest> requestCaptor = ArgumentCaptor.forClass(OrderPushToImsRequest.class);
        verify(orderServiceClient).syncOrderService(requestCaptor.capture());
        
        OrderPushToImsRequest capturedRequest = requestCaptor.getValue();
        assertEquals(Long.valueOf(1001L), capturedRequest.getWarehouseId());
        assertEquals(DeliveryType.EXPRESS.name(), capturedRequest.getDeliveryType());
        assertEquals(2, capturedRequest.getOrderIds().size());
        assertTrue(capturedRequest.getOrderIds().contains(101L));
        assertTrue(capturedRequest.getOrderIds().contains(102L));


ðŸ“„ FILE: MyOrderController.java

--- MyOrderController | triggerOrderStatusNotificationBulk | CODE | 1/1 ---
    @Async
    @PostMapping(value = "/v1/order/status-change-noti-bulk")
    public ResponseEntity<?> triggerOrderStatusNotificationBulk(@RequestBody BulkOrderStatusChangeCommModel orderStatusChangeCommModel) {
        log.error("Request received in /v1/order/status-change-noti-bulk, orderStatusChangeCommModel {}", orderStatusChangeCommModel);
        myOrderService.triggerOrderStatusNotificationBulk(orderStatusChangeCommModel);
        return new ResponseEntity<>("Success", HttpStatus.OK);


ðŸ“„ FILE: CartOrderPrivateController.java

--- CartOrderPrivateController | minimartOrderSync | CODE | 1/1 ---
    @PostMapping(value = "/v1/minimart-order-sync")
    public ResponseEntity<?> minimartOrderSync(@RequestBody OrderSyncRequestModel orderSyncRequestModel){
        return new ResponseEntity<>(myOrderService.minimartOrderSync(orderSyncRequestModel), HttpStatus.OK);


ðŸ“„ FILE: ExpressDeliveryServiceImpl.java

--- ExpressDeliveryServiceImpl | syncOrdersToIms | CODE | 1/1 ---
    private void syncOrdersToIms(List<DealLevelPromotion> cartItems, long warehouseId) {
        List<Long> orderIds = cartItems.stream().filter(cartItem ->
                cartItem.getDeliveryType().equalsIgnoreCase(DeliveryType.EXPRESS.name()))
                .map(DealLevelPromotion::getOrderPKId).collect(Collectors.toList());
        OrderPushToImsRequest orderPushToImsRequest = new OrderPushToImsRequest();
        orderPushToImsRequest.setWarehouseId(warehouseId);
        orderPushToImsRequest.setOrderIds(orderIds);
        orderPushToImsRequest.setDeliveryType(DeliveryType.EXPRESS.name());
        try {


ðŸ“„ FILE: MyOrderServiceImpl.java

--- MyOrderServiceImpl | checkMinimumMovPerDay | CODE | 1/1 ---
    @Override
    public OrderMovModel checkMinimumMovPerDay(String phone, String source, String pinCode) throws IOException {
        OrderMovModel orderMovModel = new OrderMovModel();
        orderMovModel.setIsShow(Boolean.FALSE);
        return orderMovModel;

--- MyOrderServiceImpl | orderCancellationBulk | CODE | 1/1 ---
    @Transactional
    public void orderCancellationBulk(List<KafkaCancellationRequestModel> kafkaPayloadList, Boolean cartLevelDeliveryFee) {
        if(kafkaPayloadList.size() > 0) {

--- MyOrderServiceImpl | pushToSellersPanel | CODE | 1/1 ---
    public void pushToSellersPanel(Order order){
        if(!MARKET_PLACE.equalsIgnoreCase(order.getOrderType()))
            return;


        CancelOrderSellerSyncModel cancelOrderSellerSyncModel= new CancelOrderSellerSyncModel();
        cancelOrderSellerSyncModel.setOrderId(order.getId());
        queueProducer.pushOrderCancelToSellerSync(cancelOrderSellerSyncModel);

--- MyOrderServiceImpl | processCancelOrder | CODE | 1/1 ---
    private void processCancelOrder(Order orderData, String source, OrderCancelModel orderCancelModel, Long cartId,
                                    String pinCode, Boolean cartLevelDeliveryFee,Boolean isInternalServiceCall){
        OrderHistory orderHistory = new OrderHistory(orderData, source, orderData.getUserId());
        String orderStatus = CANCEL_STATUS;
        String orderSubStatus = CANCEL_BY_SYSTEM;
        orderData.setOrderStatus(orderStatus);
        orderData.setOrderSubStatus(orderSubStatus);
        if (Optional.ofNullable(orderCancelModel.getCancellationReason()).isPresent()) {
            if(orderCancelModel.getCancellationReason().startsWith(AVP_CANCELLATION_PREFIX)){
                orderData.setOrderSubStatus(orderCancelModel.getCancellationReason());
            }else if(Optional.ofNullable(orderCancelModel.getComments()).isPresent()){
                orderData.setOrderSubStatus(orderCancelModel.getCancellationReason());
                orderData.setComments(orderCancelModel.getComments());
            }
            else {
                String subStatus = fetchReasonForCancellationFromKey(orderCancelModel.getCancellationReasonTag());
                orderData.setOrderSubStatus(subStatus);
                if (subStatus.equals("app_others") && orderCancelModel.getCancellationReason() != null) {
                    orderData.setComments(orderCancelModel.getCancellationReason());
                }
            }
        }
        this.cancelOrderData(orderData, orderCancelModel.getLang(), true,orderHistory, cartId, pinCode, cartLevelDeliveryFee, false, isInternalServiceCall);

--- MyOrderServiceImpl | triggerOrderCancelEventBulk | CODE | 1/1 ---
    private void triggerOrderCancelEventBulk(List<Order> orderDataList) {
        List<Long> orderIds = orderDataList.stream().map(Order::getId).collect(Collectors.toList());
        OrdersStatusUpdateEvent ordersStatusUpdateEvent = new OrdersStatusUpdateEvent();
        ordersStatusUpdateEvent.setOrderIds(orderIds);
        if(!orderIds.isEmpty()) {

--- MyOrderServiceImpl | triggerOrderStatusNotificationBulk | CODE | 1/1 ---
    @Override
    public void triggerOrderStatusNotificationBulk(BulkOrderStatusChangeCommModel bulkOrderStatusChangeCommModel) {
        if (bulkOrderStatusChangeCommModel.getOrderIds().isEmpty()) {
            return;
        }

        List<Order> ordersData = orderRepository.findByIdIn(bulkOrderStatusChangeCommModel.getOrderIds());
        if (ordersData.isEmpty()) {
            log.error("triggerOrderStatusNotificationBulk ordersData not found : {}", bulkOrderStatusChangeCommModel);
            return;
        }

        for (Long orderId : bulkOrderStatusChangeCommModel.getOrderIds()) {

--- MyOrderServiceImpl | triggerOrderCancelEventSyncCall | CODE | 1/1 ---
    @Override
    public void triggerOrderCancelEventSyncCall(Long userId, OrderCancelModel orderCancelModel) {

        if (Objects.isNull(orderCancelModel)  || orderCancelModel.getOrderId() == null) {
            return;
        }

        Optional<Order> optionalOrder = orderRepository.findById(orderCancelModel.getOrderId());
        if(!optionalOrder.isPresent()){
            return;
        }
        Order order = optionalOrder.get();

        OrdersStatusUpdateEvent ordersStatusUpdateEvent = new OrdersStatusUpdateEvent();
        ordersStatusUpdateEvent.setOrderIds(Collections.singletonList(order.getId()));
        String event = order.getPaymentType().equalsIgnoreCase(PAYMENT_TYPE_PAYTM) ?
                APP_CANCEL_ONLINE : APP_CANCEL_COD;
        ordersStatusUpdateEvent.setEvent(event);
        queueProducer.sendOrdersStatusUpdateTopic(ordersStatusUpdateEvent);

        log.error("raised event for order cancellation for dto : {} and event : {} and orderId : {}", ordersStatusUpdateEvent,event,order.getId());

        String flagValue = staticPropertyService.getStaticPropertyCache(SP_USER_RANK_TRANSITION_LIVE,
                SP_USER_RANK_TRANSITION_CANCEL_FLOW, Language.ENG.getValue());
        if (!ObjectUtils.isEmpty(flagValue) && flagValue.equals("true")) {

--- MyOrderServiceImpl | prepareOrderInfo | CODE | 1/1 ---
    private List<OrderInfo> prepareOrderInfo(List<Order> orders, Set<Long> cancelledByCustomerFault,
                                             Map<Long, OrderCancelDiscountUpdateRequest> orderIdToOrderSyncRequestMap,
                                             Map<Long, DealDetail> orderToDealDetailMap){
        return orders.stream().map(o -> {

--- MyOrderServiceImpl | minimartOrderSync | CODE | 1/2 ---
    public OrderSyncResponseModel minimartOrderSync(OrderSyncRequestModel orderSyncRequestModel) {

        List<UserOrderSyncModel> userOrderSyncModelList = orderSyncRequestModel.getUserOrderSyncModelList();
        
        List<String> posOrderIds = userOrderSyncModelList.stream()
                .map(UserOrderSyncModel::getPosOrderId)
                .filter(Objects::nonNull)
                .distinct()
                .collect(Collectors.toList());
        
        List<String> acquiredLocks = new ArrayList<>();
        try {
            for (String posOrderId : posOrderIds.stream().sorted().collect(Collectors.toList())) {
                String lockKey = MINIMART_ORDER_SYNC_LOCK + posOrderId;
                acquireLock(lockKey, posOrderId);
                acquiredLocks.add(lockKey);
            }
        } catch (Exception e) {
            // Release all acquired locks if any lock acquisition fails
            releaseLocks(acquiredLocks);
            throw e;
        }

        OrderSyncResponseModel orderSyncResponseModel = new OrderSyncResponseModel();
        Map<String, List<OrderDealMappingModel>> posOrderOmsOrderMap = new HashMap<>();
        Map<String, String> ordersSyncStatusMap = new HashMap<>();

        List<String> posOrderIdList = userOrderSyncModelList.stream()
                .map(UserOrderSyncModel::getPosOrderId)
                .collect(Collectors.toList());

        List<POSOrderMapping> posOrderMappingList = posOrderMappingRepository.findByPosOrderIdIn(posOrderIdList);

        Set<String> posOrderIdSet = posOrderMappingList.stream()
                .map(POSOrderMapping::getPosOrderId)
                .collect(Collectors.toSet());

        List<UserOrderSyncModel> existingUserOrderSyncModelList = userOrderSyncModelList.stream()
                .filter(userOrderSyncModel -> posOrderIdSet.contains(userOrderSyncModel.getPosOrderId()))
                .collect(Collectors.toList());

        Map<String, List<POSOrderMapping>> posOrderMappingMap = posOrderMappingList.stream()
                .collect(Collectors.groupingBy(POSOrderMapping::getPosOrderId));

        posOrderIdSet.clear();

        for(UserOrderSyncModel userOrderSyncModel : existingUserOrderSyncModelList) {
            List<POSOrderMapping> posOrderMappings = posOrderMappingMap.get(userOrderSyncModel.getPosOrderId());

            List<OrderDealMappingModel> orderDealMappingModelList = getOrderDealMappingForExistingOrder(posOrderMappings,

--- MyOrderServiceImpl | cancelOrder | CODE | 1/6 ---
    @Override
    @Transactional
    public Object cancelOrder(OrderCancelModel orderCancelModel, Long userId, Integer palId, Boolean isInternalServiceCall) {

        log.error("Cancel Order request {} and userId : {}, internalServiceCall : {}", orderCancelModel, userId,isInternalServiceCall);

        allowCancellation(orderCancelModel.getOrderId());
        Optional<User> user = userService.getUserFromId(userId,orderCancelModel.getSource());
        if ( ! user.isPresent()) {
            throw new ValidationException("Auth key not exists");
        }

        Optional<Order> order = orderRepository.findByIdAndUserId(orderCancelModel.getOrderId(), user.get().getId());
        if (!order.isPresent()) {
            throw new ValidationException("Order and user id not matching");
        }

        if (this.setCartOrderCancellationKey(orderCancelModel.getOrderId()) == Boolean.FALSE) {
            log.error("Order cancellation is failed due to unable to acquire lock {}, user Id {}", orderCancelModel.getOrderId(), userId);
            throw new ValidationException("Something went wrong, Please try again.");
        }

        ValidationExceptionV2 message = new ValidationExceptionV2();
        List<OrderMovBreach> movBreaches = new ArrayList<>();
        MovBreachMessage movBreachMessage = new MovBreachMessage();
        if (order.isPresent()) {
            if (UserOrderStatus.NONCANCEBLESTATUS.getValues().stream().anyMatch(s -> s.equalsIgnoreCase(order.get().getOrderStatus()))) {
                message.setMessage(messageSource.getMessage("non.cancellable.status", null, LocaleContextHolder.getLocale()));
                return message;
            }
            if (!orderCancelModel.getDiscard()) {
                if ((order.get().getPaymentType().equalsIgnoreCase(OrderPaymentMode.PAYTM.name()) && order.get().getOrderStatus().equalsIgnoreCase("pending"))) {
                    message.setMessage(messageSource.getMessage("cancel.message", null, LocaleContextHolder.getLocale()));
                    return message;
                }
            }
            if(CANCELLED.getValues().stream().anyMatch(s -> s.equalsIgnoreCase(order.get().getOrderStatus()))) {
                message.setMessage(messageSource.getMessage("already.cancelled", null, LocaleContextHolder.getLocale()));
                return message;
            }

            ValidationExceptionV2 validationExceptionV2;
            try{
                Order orderData = order.get();
                Long cartId = null;
                List<CartOrderMapping> cartOrderMappingList = cartOrderMappingRepository.findCartOrderMappings(orderData.getId());
                if (cartOrderMappingList != null && !cartOrderMappingList.isEmpty()) cartId = cartOrderMappingList.get(0).getCartId();

                Optional<UserAddress> userAddress = userAddressesRepository.findById(orderData.getUserAddressId());
                if(!userAddress.isPresent()) throw new ValidationException("User Address not found for this order");

--- MyOrderServiceImpl | minimartOrderSync | CODE | 2/2 ---

        for(UserOrderSyncModel userOrderSyncModel : existingUserOrderSyncModelList) {
            List<POSOrderMapping> posOrderMappings = posOrderMappingMap.get(userOrderSyncModel.getPosOrderId());

            List<OrderDealMappingModel> orderDealMappingModelList = getOrderDealMappingForExistingOrder(posOrderMappings,
                    userOrderSyncModel.getOfferIdOrderSummaryModelMap());

            if(!ObjectUtils.isEmpty(orderDealMappingModelList)) {
                posOrderIdSet.add(userOrderSyncModel.getPosOrderId());
                posOrderOmsOrderMap.put(userOrderSyncModel.getPosOrderId(), orderDealMappingModelList);
            }
        }

        userOrderSyncModelList = userOrderSyncModelList.stream()
                .filter(userOrderSyncModel -> !posOrderIdSet.contains(userOrderSyncModel.getPosOrderId()))
                .collect(Collectors.toList());

        for (UserOrderSyncModel userOrderSyncModel : userOrderSyncModelList) {

            UserInfoModel userInfoModel = userOrderSyncModel.getUserInfoModel();
            try {
                UserCacheModel userCacheModel = userService.getUser(userInfoModel);

                /** userCacheModel and userInfoModel pincode can be different if user is present in db already*/
                Long userAddressId = userAddressService.getUserAddress(userCacheModel).getId();

                List<OrderDealMappingModel> orderDealMappingModelList = userOrderService.syncOrders(userCacheModel,
                        userOrderSyncModel,
                        userAddressId);

                posOrderOmsOrderMap.put(userOrderSyncModel.getPosOrderId(), orderDealMappingModelList);
            } catch (Exception e) {
//                chatServiceClient.sendEmailToMultiple(CommonUtils.prepareEmailRequestModel(EmailSubject.MINIMART_ORDER_SYNC.getValue(), String.format("userOrderSyncModel : %s, Exception : %s", userOrderSyncModel, e)));
                ordersSyncStatusMap.put(userOrderSyncModel.getPosOrderId(), e.getMessage());
                log.error("Something went wrong in saving order : {}, Exception : {}", userOrderSyncModel, e.getMessage());
            }
        }
        orderSyncResponseModel.setPosOrderOmsOrderMap(posOrderOmsOrderMap);
        posOrderOmsOrderMap.keySet().forEach(posOrderId -> ordersSyncStatusMap.put(posOrderId, "Synced Successfully"));
        orderSyncResponseModel.setOrdersSyncStatusMap(ordersSyncStatusMap);

        releaseLocks(acquiredLocks);

        return orderSyncResponseModel;

--- MyOrderServiceImpl | cancelOrder | CODE | 2/6 ---
                List<CartOrderMapping> cartOrderMappingList = cartOrderMappingRepository.findCartOrderMappings(orderData.getId());
                if (cartOrderMappingList != null && !cartOrderMappingList.isEmpty()) cartId = cartOrderMappingList.get(0).getCartId();

                Optional<UserAddress> userAddress = userAddressesRepository.findById(orderData.getUserAddressId());
                if(!userAddress.isPresent()) throw new ValidationException("User Address not found for this order");

//                LocationV3Model locationV3Model = locationService.getLocationDataFromPinCodeV3(userAddress.get().getPinCode(),
//                                                null, orderCancelModel.getSource(), null);

                Boolean canCancelCentralizedOrder = this.cancelCentralizedOrder(orderData,cartId,cartOrderMappingList);
                Boolean cartLevelDeliveryFee = false;
                if (checkIfCancellationDisabledSingleOrder(user.get().getId(), orderData, isInternalServiceCall,canCancelCentralizedOrder)) {
                    log.error("Cancellation is disabled for this order : {}", orderData.getId());
                    throw new ValidationException(messageSource.getMessage(CANCELLATION_DISABLED_MESSAGE,null, LocaleContextHolder.getLocale()));
                }

                Map<String, Object> cartItemsInfo = this.checkIfCartContainsOrdOrder(orderData, user.get(),
                        orderCancelModel.getOrdSchemeKey(), cartId,orderCancelModel.getDiscard());
                if (cartId == null) {
                    throw new ValidationException("Valid user cart id is missing");
                }
                Boolean cancelOrderBool = (Boolean) cartItemsInfo.get(CART_CONTAINS_ORD);
                /**
                 * First order condition not to put check delivery fee. not handled pop up cancel
                 * from order success screen
                 */
                //scratch card cancellation msg.
                if(!orderCancelModel.getScratchCardKey()) {
                    Map<String, Object> scratchCardRedeemedCheck =
                        this.checkIfScratchCardRedeemed(orderData, cartId);
                    if (scratchCardRedeemedCheck.containsKey(POPUP_MESSAGE_OBJECT)) {
                        return scratchCardRedeemedCheck.get(POPUP_MESSAGE_OBJECT);
                    }
                }
                boolean revertAB = true;
                if(!orderCancelModel.getOrdSchemeKey() && !orderCancelModel.getDeliveryFeeKey()
                    && revertAB) {
                    // Cart Discount Mov breach check
                    OrderMovBreach discountMovBreach =
                        this.getCartDiscountMovBreach(orderData, cartId, orderCancelModel.getLang());
                    log.error("Cancel Order request Cart Discount MovBreach Response  : {}, userId : {},cartId : {}", discountMovBreach,userId,cartId);
                    if (Objects.nonNull(discountMovBreach)) {
                        movBreaches.add(discountMovBreach);
                    }
                }
                Map<String, Object> checkDeliveryFeeInfo = this.checkDeliveryFee(orderData, user.get(), orderCancelModel, cartId);

                log.error("Cancel Order request CheckDeliveryFee Response  : {}, userId : {},cartId : {}", checkDeliveryFeeInfo,userId,cartId);

                cartLevelDeliveryFee = (Boolean) checkDeliveryFeeInfo.get("CART_LEVEL_DELIVERY_FEE") && checkDeliveryFeeInfo.get("CART_LEVEL_DELIVERY_FEE") != null;

--- MyOrderServiceImpl | cancelOrder | CODE | 3/6 ---
                Map<String, Object> checkDeliveryFeeInfo = this.checkDeliveryFee(orderData, user.get(), orderCancelModel, cartId);

                log.error("Cancel Order request CheckDeliveryFee Response  : {}, userId : {},cartId : {}", checkDeliveryFeeInfo,userId,cartId);

                cartLevelDeliveryFee = (Boolean) checkDeliveryFeeInfo.get("CART_LEVEL_DELIVERY_FEE") && checkDeliveryFeeInfo.get("CART_LEVEL_DELIVERY_FEE") != null;
                Boolean deliveryFeeCentralisationFlow = (Boolean) checkDeliveryFeeInfo.get("DELIVERY_FEE_CENTRALISATION_FLOW") && checkDeliveryFeeInfo.get("DELIVERY_FEE_CENTRALISATION_FLOW") != null;
                cancelOrderBool = (Boolean) checkDeliveryFeeInfo.get(DELIVERY_FEES_APPLICABLE_CHECK);
                Boolean lastOrder = checkDeliveryFeeInfo.get("LAST_ORDER") != null && (Boolean) checkDeliveryFeeInfo.get("LAST_ORDER");
                if (!orderCancelModel.getOrdSchemeKey() && !orderCancelModel.getDeliveryFeeKey()
                    && checkDeliveryFeeInfo.containsKey(POPUP_MESSAGE_OBJECT)) {
                    List<StaticPropertiesEntity> staticProperties =
                        staticPropertiesRepository.findAllByPropertyKey(DELIVERY_PROP_KEY);
                    if (Objects.isNull(movBreachMessage.getMessage())) {
                        validationExceptionV2 = objectMapper.convertValue(
                            checkDeliveryFeeInfo.get(POPUP_MESSAGE_OBJECT),
                            ValidationExceptionV2.class);
                        addToMovBreachMessage(movBreachMessage, validationExceptionV2);
                    }
                    movBreaches.add(OrderMovBreach.builder()
                        .icon(
                            !CollectionUtils.isEmpty(staticProperties) ? staticProperties.get(0)
                                .getPropertyValue() : null)
                        .message(messageSource.getMessage(DELIVERY_MSG_KEY,
                            new Object[] {checkDeliveryFeeInfo.get("delivery_fee")},
                            LocaleContextHolder.getLocale()))
                        .type("delivery")
                        .build());
                }

                if(!CollectionUtils.isEmpty(movBreaches)) {
                    Collections.reverse(movBreaches);
                    movBreachMessage.setOrderMovBreach(movBreaches);
                    if (Objects.isNull(movBreachMessage.getMessage())) {
                        OrderMovBreach movBreach = movBreaches.get(0);
                        movBreachMessage.setMessageFooter(messageSource
                            .getMessage(MOV_CHECKBOX_MSG, null, LocaleContextHolder.getLocale()));
                        movBreachMessage.setTitle(messageSource
                            .getMessage(MOV_TITLE_MSG, null, LocaleContextHolder.getLocale()));
                        movBreachMessage.setMessage(movBreach.getMessage().replaceAll("<[/]?font>", ""));
                        movBreachMessage.setInternalId(String.valueOf(orderData.getId()));
                        movBreachMessage.setOrdSchemeKey(true);
                    }
                    return movBreachMessage;
                }

                KafkaCancellationRequestModel kafkaPayload = new KafkaCancellationRequestModel();
                kafkaPayload.setCancelOrderBool(cancelOrderBool);
                kafkaPayload.setCartId(cartId);
                kafkaPayload.setCartConfig((CartConfig) cartItemsInfo.get("cartConfig"));
                kafkaPayload.setOrderData(orderData);

--- MyOrderServiceImpl | cancelOrder | CODE | 4/6 ---
                KafkaCancellationRequestModel kafkaPayload = new KafkaCancellationRequestModel();
                kafkaPayload.setCancelOrderBool(cancelOrderBool);
                kafkaPayload.setCartId(cartId);
                kafkaPayload.setCartConfig((CartConfig) cartItemsInfo.get("cartConfig"));
                kafkaPayload.setOrderData(orderData);
                kafkaPayload.setOrderCancelModel(orderCancelModel);
                kafkaPayload.setCancelOrdOrderBool(orderCancelModel.getOrdSchemeKey());
                kafkaPayload.setUserRank(user.get().getUserRank());
                kafkaPayload.setSource(orderCancelModel.getSource());
                kafkaPayload.setPinCode(user.get().getPincode().toString());
                if(!cancelOrderBool) {
                    if(KafkaConstants.KAFKA_ALLOWED) {
                        queueProducer.produceOrderCancellationSyncEvent(kafkaPayload);
                    } else {
                        log.error("Cancel Order request, payload :{}, cartLevelDeliveryFee : {}, internalCall : {}, userId : {}",
                            kafkaPayload, cartLevelDeliveryFee,isInternalServiceCall, userId);
                        orderCancellation(kafkaPayload, cartLevelDeliveryFee, isInternalServiceCall);

                    }
                }

                if (deliveryFeeCentralisationFlow && (Boolean.TRUE.equals(orderCancelModel.getDeliveryFeeKey()) || lastOrder)){

                        List<UpdateFeesModel> updateModels = new ArrayList<>();
                        UpdateFeesModel updateFeesModel = new UpdateFeesModel();
                        updateFeesModel.setFeeType(FeesType.DELIVERY_FEES.name());

                        if(lastOrder){
                            updateFeesModel.setAppliedFees(0.0);
                            updateFeesModel.setFinalFees(0.0);

                            List<FeeConfiguration> feeConfigurations = feeConfigRepository.findAll();
                            if(!feeConfigurations.isEmpty()) {
                                for(FeeConfiguration feeConfiguration : feeConfigurations){
                                    UpdateFeesModel updateGenericFeeModel = new UpdateFeesModel();
                                    updateGenericFeeModel.setFeeType(feeConfiguration.getCode());
                                    updateGenericFeeModel.setAppliedFees(0.0);
                                    updateGenericFeeModel.setFinalFees(0.0);
                                    updateModels.add(updateGenericFeeModel);
                                }
                            }
                        } else {
                            long deliveryFees = checkDeliveryFeeInfo.get("delivery_fee") != null
                                    ? (Long) checkDeliveryFeeInfo.get("delivery_fee")
                                    : 0L;
                            updateFeesModel.setAppliedFees((double) deliveryFees);
                            updateFeesModel.setFinalFees((double) deliveryFees);
                        }
                        updateModels.add(updateFeesModel);


--- MyOrderServiceImpl | cancelOrder | CODE | 5/6 ---
                            updateFeesModel.setAppliedFees((double) deliveryFees);
                            updateFeesModel.setFinalFees((double) deliveryFees);
                        }
                        updateModels.add(updateFeesModel);


                        UpdateCartFeesDetails updateCartFeesDetails = new UpdateCartFeesDetails();
                        updateCartFeesDetails.setCartId(cartId);
                        updateCartFeesDetails.setUserId(userId);
                        updateCartFeesDetails.setAllOrderCancelled(lastOrder);
                        updateCartFeesDetails.setCartUpdateData(updateModels);

                        UpdateCartFeesRequest updateCartFeesRequest = new UpdateCartFeesRequest();
                        updateCartFeesRequest.setFlow(FlowType.CANCEL_ORDER);
                        updateCartFeesRequest.setUpdateData(Collections.singletonList(updateCartFeesDetails));

                        try {
                            feesService.updateCartFees(updateCartFeesRequest);
                        } catch (Exception ex){
                            log.error("error in updating cart fees during cancel order,updateCartFeesRequest:{}", updateCartFeesRequest);
                        }

                        if (lastOrder) {
                            try {
                                log.error("Request received for creditCartConfigBenefits cartId {} and userId {} orderId {}", cartId, userId, orderCancelModel.getOrderId());
                                feesService.creditCartConfigBenefits(cartId, userId);
                            } catch (Exception ex){
                                log.error("error in cancel-discarded-orders-creditCartConfigBenefits during cancel order cartId : {}", cartId);
                            }
                        }
                }

                try {
                    schemeServiceClient.updateHomePageDiscountUsed(order.get().getUserId());
                } catch (Exception e) {
                    log.error("Something went wrong while updating home page strip discount amount");
                }
                try {
                    int quantity = order.get().getQuantity() == null ? 1 : order.get().getQuantity().intValue();
                    DealInfo dealInfo = DealInfo.builder().offerId(order.get().getOfferId())
                            .quantity(quantity)
                            .build();
                    FrdSoldUpdateModel frdSoldUpdateModel = FrdSoldUpdateModel
                            .builder().dealDetails(Arrays.asList(dealInfo))
                            .userType(user.get().getUserRank())
                            .pincode(userAddress.get().getPalPincode())
                            .palId(userAddress.get().getPalId())
                            .cancelRequest(true).build();
                    dealServiceClient.updateFrdSoldQuantity(frdSoldUpdateModel, userName, password);
                } catch (Exception e) {

--- MyOrderServiceImpl | cancelOrder | CODE | 6/6 ---
                            .pincode(userAddress.get().getPalPincode())
                            .palId(userAddress.get().getPalId())
                            .cancelRequest(true).build();
                    dealServiceClient.updateFrdSoldQuantity(frdSoldUpdateModel, userName, password);
                } catch (Exception e) {
                    log.error("Something went wrong while update frd sold quantity for order cancel {}", e.getMessage());
                }
            } catch (Exception e) {
                log.error("cancelOrder Method Exception: {} , userId : {}", e.getMessage(),userId,e);
                throw new ValidationException("Something went wrong , please try again!!");
            }
        }
        //updating the cache when order is cancelled.
        etaService.updateOrderStatusWidgetCacheAsync(etaService.updateCacheForCancelledOrders(order.get()));
        return true;


ðŸ“„ FILE: UserShipmentServiceImpl.java

--- UserShipmentServiceImpl | calculateShipmentEta | CODE | 1/1 ---
    public void calculateShipmentEta(UserShipmentModel shipment, List<Order> orders){
        Boolean isLive = commonUtils.getEtaFlag(ETA_FLAG,ETA_FLAG);
        String eta = null;
        if(isLive){
            Order latestOrder = orders.stream()
                    .max(Comparator.comparing(Order::getId))
                    .orElse(null);
            eta = etaService.orderEta(latestOrder);
            if (eta != null) {
                try {
                    // Parse the string according to ETA_FORMAT_FROM_CACHE
                    shipment.setEtaFromCache(eta);
                    SimpleDateFormat inputFormat = new SimpleDateFormat(ETA_FORMAT_FROM_CACHE);
                    Date etaDate = inputFormat.parse(eta);
                    eta = commonUtils.formatEtaV2(etaDate);
                } catch (Exception e) {
                    eta = null;
                }
            }
        }
        if(eta == null){
            Optional<List<OrderHistory>> orderHistories = orderHistoryRepository.findByOrderId(orders.get(0).getId());
            eta = orderHistories
                    .flatMap(list -> list.stream()
                            .filter(oh -> OUT_FOR_DELIVERY.equalsIgnoreCase(oh.getStatus()))
                            .map(OrderHistory::getCreatedDate)
                            .filter(Objects::nonNull) // ensure no null date
                            .findFirst()
                    )
                    .map(commonUtils::formatEta)
                    .orElse(null);
        }
        if(eta == null || eta.isEmpty() ){


ðŸ“„ FILE: EtaServiceImpl.java

--- EtaServiceImpl | getStoreTimeConfigFromWarehouseEta | CODE | 1/1 ---
    public StoreTimeConfig getStoreTimeConfigFromWarehouseEta(Integer warehouseId) {
        
        StoreTimeConfig storeTimeConfig = new StoreTimeConfig();
        
        try {
            ResponseEntity<WarehouseEtaConfigResponseModel> response = etaServiceClient.getWarehouseEtaConfig(warehouseId);

            if (response.getStatusCode() == HttpStatus.OK && response.getBody() != null) {
                WarehouseEtaConfigResponseModel responseModel = response.getBody();

                if (Boolean.TRUE.equals(responseModel.getStatus()) && responseModel.getData() != null) {
                    LocalTime orderStartTime = responseModel.getData().getOrderStartTime();
                    LocalTime orderEndTime = responseModel.getData().getOrderEndTime();

                    // Convert time format from "HH:mm:ss" to "HH:mm"
                    String storeOpeningTime = CommonUtils.convertTimeFormat(orderStartTime != null ? orderStartTime.format(DateTimeFormatter.ofPattern("HH:mm:ss")) : null);
                    String storeClosingTime = CommonUtils.convertTimeFormat(orderEndTime != null ? orderEndTime.format(DateTimeFormatter.ofPattern("HH:mm:ss")) : null);

                    storeTimeConfig.setStoreOpeningTime(storeOpeningTime);
                    storeTimeConfig.setStoreClosingTime(storeClosingTime);

                    return storeTimeConfig;
                } else {
                    log.warn("ETA service returned unsuccessful status for warehouseId: {}", warehouseId);
                }
            } else {
                log.warn("Invalid response from ETA service for warehouseId: {}, status: {}", 
                        warehouseId, response.getStatusCode());
            }
        } catch (Exception e) {
            log.error("Error fetching warehouse ETA config for warehouseId: {}, error: {}", 
                    warehouseId, e.getMessage(), e);
        }
        
        // Fallback to default values if warehouse config is not available
        log.warn("Warehouse ETA config not available for warehouseId: {}, using default values", warehouseId);
        storeTimeConfig.setStoreOpeningTime(DELIVERY_STARTING_HOUR_FOR_STORE);
        storeTimeConfig.setStoreClosingTime(DELIVERY_ENDING_HOUR_FOR_STORE);
        
        return storeTimeConfig;

--- EtaServiceImpl | updateCacheForCancelledOrders | CODE | 1/1 ---
    public List<OrderStatusWidgetCacheUpdateModel> updateCacheForCancelledOrders(Order order){
        if(order == null){
            return null;
        }
        OrderStatusWidgetCacheUpdateModel model = new OrderStatusWidgetCacheUpdateModel();
        model.setOrderId(order.getId());
        model.setUserId(order.getUserId());
        model.setStatus(order.getOrderStatus());
        return Collections.singletonList(model);

--- EtaServiceImpl | updateOrderStatusWidgetCacheAsync | CODE | 1/1 ---
    @Async
    public CompletableFuture<Void> updateOrderStatusWidgetCacheAsync(List<OrderStatusWidgetCacheUpdateModel> orderStatusWidgetCacheUpdateModelList) {
        orderServiceClient.updateOrderStatusWidgetCache(orderStatusWidgetCacheUpdateModelList);
        return CompletableFuture.completedFuture(null);


ðŸ“„ FILE: CartServiceV2Impl.java

--- CartServiceV2Impl | triggerOrderPlacedEvent | CODE | 1/1 ---
    private void triggerOrderPlacedEvent(CartOrderModel responseCartOrderModel){
        List<Long> orderIds = new ArrayList<>();
        responseCartOrderModel.getCartItems()
                .forEach(cartItem -> orderIds.add(cartItem.getOrderPKId()));
        OrdersStatusUpdateEvent ordersStatusUpdateEvent = new OrdersStatusUpdateEvent();
        ordersStatusUpdateEvent.setOrderIds(orderIds);
        ordersStatusUpdateEvent.setEvent(UserRankUpdateEvent.ORDER_PLACED.toString());
        queueProducer.sendOrdersStatusUpdateTopic(ordersStatusUpdateEvent);

        UserRankTransitionRequestModel userRankTransitionRequestModel = UserRankTransitionRequestModel.builder()
                .userId(responseCartOrderModel.getUserId())
                .event(UserRankUpdateEvent.ORDER_PLACED.toString())
                .build();

        try {

--- CartServiceV2Impl | getTitleAndGradientFromEtaDateV2 | CODE | 1/2 ---
    private EtaDisplayData getTitleAndGradientFromEtaDateV2(OrderStatusWidgetStaticModel orderStatusWidgetStaticModel,
                                                    LocalDateTime eta, String lang, Integer warehouseId) {
        EtaDisplayData etaDisplayData = new EtaDisplayData();
        try {
            LocalDate orderETADate = eta.toLocalDate();
            LocalTime orderETATime = eta.toLocalTime();
            LocalDate currentDate =  LocalDate.now();
            LocalDate nextDate = currentDate.plusDays(1);

            OrderConfirmationEtaBufferConfig etaBuffer = etaService.getOrderConfirmationEtaBufferConfig(warehouseId);
            if (Objects.isNull(etaBuffer.getHours()) || etaBuffer.getHours().equals(0L)) {
                etaBuffer.setEnable(true);
                etaBuffer.setHours(1L);
            }

            TomorrowEtaWarehouseConfig etaTomorrow = etaService.getTomorrowEtaWarehouseConfig(warehouseId);

            if (orderETADate.isEqual(currentDate)) {
                EtaDisplayData etaDisplayData1 = getETAResponse(orderStatusWidgetStaticModel.getArrivingToday(),
                        orderETATime,orderStatusWidgetStaticModel.getToday()
                        , etaBuffer, lang, orderStatusWidgetStaticModel);
                return etaDisplayData1;
            } else if (orderETADate.isEqual(nextDate)) {
                if (etaTomorrow.isEnable()) {
                    return getETAResponse(orderStatusWidgetStaticModel.getArrivingTomorrow(),
                            orderETATime, orderStatusWidgetStaticModel.getTomorrow(),
                            etaBuffer, lang, orderStatusWidgetStaticModel);
                } else {
                    etaDisplayData.setTitle(CommonUtils.getValueFromMapByLang(orderStatusWidgetStaticModel.getArrivingTomorrow(), lang));
                    etaDisplayData.setEtaTitle(CommonUtils.getValueFromMapByLang(orderStatusWidgetStaticModel.getArrivingTomorrow(), lang));
                    return etaDisplayData;
                }

            } else if (orderETADate.isAfter(nextDate)) {
                // etaString is replaced by etaDate (need to modify etaDate to match etaString format)
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(stringToDateFormat, Locale.ENGLISH); // Adjust format as needed
                etaDisplayData.setEtaTitle(CommonUtils.getValueFromMapByLang(orderStatusWidgetStaticModel.getArrivingOn(), lang)
                        + orderETADate.format(formatter));
                etaDisplayData.setTitle(CommonUtils.getValueFromMapByLang(orderStatusWidgetStaticModel.getArrivingOn(), lang)
                        + orderETADate.format(formatter));
                return etaDisplayData;

            }
        } catch (Exception e) {
            log.error("Fetching title from eta date {}, input- staticModel: {}, deliveryDateTime: {}, lang: {}",
                    e.getMessage(), orderStatusWidgetStaticModel, eta, lang);
        }
        return etaDisplayData;

--- CartServiceV2Impl | getTitleAndGradientFromEtaDateV2 | CODE | 2/2 ---
                    e.getMessage(), orderStatusWidgetStaticModel, eta, lang);
        }
        return etaDisplayData;


ðŸ“„ FILE: UserOrderServiceImpl.java

--- UserOrderServiceImpl | getOrderTracking | CODE | 1/1 ---
    @Override
    public List<OrderTrackingModel> getOrderTracking(Long orderId, String authkey) {
        List<OrderTrackingModel> orderTrackingModels = new ArrayList<>();
        Optional<List<OrderHistory>> orders = orderHistoryRepository.findByOrderId(orderId);
        if (orders.isPresent()) {
            {
                for (OrderTrackingType orderTrackingType : OrderTrackingType.values()) {
                    OrderTrackingModel orderTrackingModel = new OrderTrackingModel();
                    for (OrderHistory orderHistory : orders.get()) {
                        if (orderHistory.getStatus().equalsIgnoreCase(orderTrackingType.toString())) {
                            orderTrackingModel.setStatus(orderTrackingType.toString());
                            orderTrackingModel.setUpdatedAt(setOrderTrackingDate(orderHistory));
                            orderTrackingModel.setStageChanged(true);
                            break;
                        } else {
                            orderTrackingModel.setStatus(orderTrackingType.toString());
                            orderTrackingModel.setUpdatedAt(setOrderTrackingDate(orderHistory));
                            orderTrackingModel.setStageChanged(false);
                        }
                    }
                    orderTrackingModels.add(orderTrackingModel);
                }
            }
        } else {
            throw new ValidationException("Order not found in Order History");
        }
        return orderTrackingModels;

--- UserOrderServiceImpl | createOrderHistory | CODE | 1/1 ---
    private OrderHistory createOrderHistory(Order order, Date cancellationTime) {
        return new OrderHistory(order, cancellationTime,

--- UserOrderServiceImpl | discardFlaggedOrders | CODE | 1/2 ---
    public void discardFlaggedOrders(Long userId, Long cartId) {
        if (cartId > 0) {
//            log.error("Discard is blocked as of now userId {} cartId {}", userId, cartId);
            return;
        }

        cartRepository.findCartByIdAndUserId(cartId, userId)
                .orElseThrow(() -> new ValidationException("Cart not found for the given user."));

        List<CartOrderMapping> cartOrderMappings = cartOrderMappingRepository.findByCartId(cartId)
                .orElseThrow(() -> new ValidationException("No orders found for the given cart."));

        List<Long> orderIds = cartOrderMappings.stream()
                .map(CartOrderMapping::getOrderId)
                .collect(Collectors.toList());

        List<Order> orders = orderRepository.findAllById(orderIds);
        if (orders.isEmpty()) {
            throw new ValidationException("Orders not found for the given cart.");
        }

        for (Order order : orders) {
            if (order.getOrderStatus().equals(DISCARD_STATUS)) {
                log.warn("discardFlaggedOrders Order {} is already in discard status, skipping.", order.getId());
                continue;
            }

            if (order.getOrderStatus().equals(CANCEL_STATUS)) {
                log.warn("discardFlaggedOrders Order {} is already in cancel status, skipping.", order.getId());
                continue;
            }

            OrderCancelModel cancelModel = createOrderCancelModel(
                    order.getId(), order.getUserId(), order.getSource(), CANCEL_BY_SYSTEM, "Flagged Abuse Users"
            );

            try {
                myOrderService.cancelOrder(cancelModel, order.getUserId(), null, true);
                myOrderService.triggerOrderCancelEventSyncCall(order.getUserId(),cancelModel);
            } catch (Exception | ValidationExceptionV2 ex) {
                log.error("discardFlaggedOrders Failed to cancel order {}: {}", order.getId(), ex.getMessage(), ex);
            }

            order.setComments("Flagged Abuse Users");
            order.setOrderSubStatus(CANCEL_BY_SYSTEM);
            order.setOrderStatus(DISCARD_STATUS);
        }

        orderRepository.saveAll(orders);

--- UserOrderServiceImpl | discardFlaggedOrders | CODE | 2/2 ---
            order.setOrderStatus(DISCARD_STATUS);
        }

        orderRepository.saveAll(orders);


ðŸ“„ FILE: KafkaProducer.java

--- KafkaProducer | sendOrdersStatusUpdateTopic | CODE | 1/1 ---
    @Async
    @Override
    public void sendOrdersStatusUpdateTopic(OrdersStatusUpdateEvent ordersStatusUpdateEvent) {
        try {

--- KafkaProducer | sendOrderPlacedUserSMSCommunicationEvent | CODE | 1/1 ---
    @Async
    @Override
    public void sendOrderPlacedUserSMSCommunicationEvent(OrderUpdateEventDetail orderUpdateEventDetail) {
        try {


ðŸ“„ FILE: UserCartServiceImpl.java

--- UserCartServiceImpl | CreateOrderWidgetModel | CODE | 1/1 ---
    public EtaWidgetModel CreateOrderWidgetModel(List <Order> orders, String lang){
        EtaWidgetModel etaWidgetModel = EtaWidgetModel.builder().icon("https://images.dealshare.in/1753346135502fi_17124525.png?tr=f-webp").etaTitle("Arriving Soon").build();
        Boolean isLive = getEtaFlag(ETA_FLAG,ETA_FLAG);
        String eta = null;
        try{
            if(isLive){
                Order latestOrder = orders.stream()
                        .max(Comparator.comparing(Order::getId))
                        .orElse(null);
                eta = etaService.orderEta(latestOrder);
                etaWidgetModel.setEtaFromCache(eta);
                SimpleDateFormat inputFormat = new SimpleDateFormat(ETA_FORMAT_FROM_CACHE);
                try {
                    Date date = inputFormat.parse(eta);
                    eta = commonUtils.formatEtaV2(date);
                } catch (Exception e) {
                    eta = null;
                }
            }
            if(eta != null){
                etaWidgetModel.setEtaTitle(ARRIVING);
                etaWidgetModel.setEtaData(eta);
            }else{
                List<Long> ordersList = orders.stream().map(Order::getId).collect(Collectors.toList());
                OrderStatusWidgetStaticModel staticModel = commonUtils.getOrderStatusWidgetFromStaticProperties(ENGLISH);
                ZonedDateTime cartETA = etaService.getEarliestCeiledDeliveryHour(ordersList);
                String finalTitle = etaService.formatDeliveryEta(staticModel,cartETA, lang);
                etaWidgetModel.setEtaTitle(CommonUtils.getValueFromMapByLang(staticModel.getArrivingBy(), lang));
                etaWidgetModel.setEtaData(finalTitle);
            }

        }catch(Exception e){
            log.error("Exception in CreateOrderWidgetModel: {}", e.getMessage(), e);
        }
        return etaWidgetModel;
