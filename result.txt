Context for question:
will decimal delivery fee fail for this api order/cancellation/panel??

--- WarehouseResponseDto.java | WarehouseResponseDto | buildMetaData | 1/2 ---
    private CartConfigMetaData buildMetaData() {
        ObjectMapper objectMapper = new ObjectMapper();

        Map<String, String> titleMap = new HashMap<>();
        titleMap.put("en", "Order more & Get Free shipping");
        titleMap.put("hi", "ऑर्डर करें और मुफ्त डिलीवरी पाएं");
        titleMap.put("ben", "আরও অর্ডার করুন এবং বিনামূল্যে শিপিং পান");

        String titleJson = "";
        try {
            titleJson = objectMapper.writeValueAsString(titleMap);
        } catch (Exception e) {
            log.error(e.getMessage());
        }

        Map<String, String> messageMap = new HashMap<>();
        messageMap.put("en", "Add items worth ₹${ORDER_VALUE} more to get free delivery");
        messageMap.put("hi", "फ्री डिलीवरी प्राप्त करने के लिए ₹${ORDER_VALUE} के और आइटम जोड़ें");
        messageMap.put("ben", "ফ্ফ্রি ডেলিভারির জন্য আরও ₹${ORDER_VALUE} মূল্যের আইটেম যোগ করুন");

        JsonNode messageNode = objectMapper.valueToTree(messageMap);

        Map<String, String> configMetaMap = new HashMap<>();
        configMetaMap.put("delivery_fee", "19");
        configMetaMap.put("minimum_order_value", "399");

        JsonNode configMetaNode = objectMapper.valueToTree(configMetaMap);

        CartConfigModel deliveryFeeTemplate = new CartConfigModel();
        deliveryFeeTemplate.setId(100319L);
        deliveryFeeTemplate.setAmount(399L);
        deliveryFeeTemplate.setConsumerType("B2C");
        deliveryFeeTemplate.setLocationType("WAREHOUSE");
        deliveryFeeTemplate.setLocationId(519);
        deliveryFeeTemplate.setUserSegment("normal");
        deliveryFeeTemplate.setLocale("en");
        deliveryFeeTemplate.setTitle(titleJson);
        deliveryFeeTemplate.setMessage(messageNode);
        deliveryFeeTemplate.setIsActive(true);
        deliveryFeeTemplate.setConfigName("DELIVERY_FEES");
        deliveryFeeTemplate.setConfigMeta(configMetaNode);
        deliveryFeeTemplate.setStartDate(new Date(2025-1900, 6, 7, 12, 46, 47));
        deliveryFeeTemplate.setEndDate(new Date(2031-1900, 3, 30, 7, 40, 23));
        deliveryFeeTemplate.setCreateDate(null);
        deliveryFeeTemplate.setModifiedDate(null);

        CartConfigFilter cartConfigFilterTemplate = CartConfigFilter.builder()
                .amount(399L)
                .consumerType("B2C")
                .locationType("WAREHOUSE")

--- WarehouseResponseDto.java | WarehouseResponseDto | buildMetaData | 2/2 ---

        CartConfigFilter cartConfigFilterTemplate = CartConfigFilter.builder()
                .amount(399L)
                .consumerType("B2C")
                .locationType("WAREHOUSE")
                .locationId(0)
                .userSegment("ALL")
                .locale("en")
                .isActive(1)
                .configName("DELIVERY_FEES")
                .startDate(null)
                .endDate(null)
                .build();

        Map<String, CartConfigModel> cartConfigModelMap = new HashMap<>();
        cartConfigModelMap.put("DELIVERY_FEES", deliveryFeeTemplate);

        return CartConfigMetaData.builder()

--- FeesController.java | FeesController | computeShipmentFees | 1/1 ---
    public ResponseEntity<?> computeShipmentFees(@Valid @RequestBody ComputeShipmentFeesRequest computeShipmentFeesRequest) {
//        log.error("Centralisation Compute Shipment Fees Request : {}", computeShipmentFeesRequest);
        return new ResponseEntity<>(feesService.computeShipmentFees(computeShipmentFeesRequest), HttpStatus.OK);

--- FeesController.java | FeesController | updateShipmentFees | 1/1 ---
    public ResponseEntity<?> updateShipmentFees(@Valid @RequestBody UpdateShipmentFeesRequest request) {
//        log.error("Centralisation Update Shipment Fees Request : {}", request);
        return new ResponseEntity<>(feesService.updateShipmentFees(request), HttpStatus.OK);

--- FeesController.java | FeesController | revertFees | 1/1 ---
    public ResponseEntity<?> revertFees(@Valid @RequestBody RevertFeesRequest revertFeesRequest) {
        log.error("Centralisation Revert Fees Request : {}", revertFeesRequest);
        return new ResponseEntity<>(feesService.revertFees(revertFeesRequest), HttpStatus.OK);

--- CommonUtils.java | CommonUtils | getFreeDeliveryWithSavingsMessage | 1/1 ---
    private String getFreeDeliveryWithSavingsMessage(BigDecimal savings, BigDecimal deliveryFeeSaved, BigDecimal actualDeliveryFee, Locale locale) {
        // Check if delivery is free and has delivery fee savings
        if (BigDecimal.ZERO.compareTo(actualDeliveryFee) == 0 && BigDecimal.ZERO.compareTo(deliveryFeeSaved) < 0) {
            if (savings.compareTo(deliveryFeeSaved) == 0) {
                // Only delivery fee saved
                return messageSource.getMessage(CHECKOUT_SAVED_ON_DELIVERY_FEES, new Object[]{deliveryFeeSaved.intValue()}, locale);
            } else {
                // Savings including delivery fee
                return messageSource.getMessage(CHECKOUT_SAVED_INCLUDING_DELIVERY_FEES, new Object[]{savings.intValue(), deliveryFeeSaved.intValue()}, locale);
            }
        }
        return null;

--- CommonUtils.java | CommonUtils | getNoSavingsNotEligibleForFreeDeliveryMessage | 1/1 ---
    private String getNoSavingsNotEligibleForFreeDeliveryMessage(BigDecimal savings, BigDecimal cartValue, BigDecimal mov, Locale locale) {
        if (cartValue == null) cartValue = BigDecimal.ZERO;
        if (mov == null) mov = BigDecimal.ZERO;

        // Check if no savings and not eligible for free delivery
        if (BigDecimal.ZERO.compareTo(savings) == 0 && cartValue.compareTo(mov) < 0) {
            BigDecimal amountNeeded = mov.subtract(cartValue);
            return messageSource.getMessage(CHECKOUT_ADD_FOR_FREE_DELIVERY, new Object[]{amountNeeded.intValue()}, locale);
        }
        return null;

--- AppExceptionHandler.java | AppExceptionHandler | PricingService | 1/1 ---
    public ResponseEntity<?> PricingService(final PricingServiceException exception, final WebRequest request){
        ExceptionResponse exceptionResponse = new ExceptionResponse(new Date(), exception.getMessage(), request.getDescription(false));
        return new ResponseEntity<>(exceptionResponse, HttpStatus.BAD_REQUEST);

--- CartTPDataMappingService.java | CartTPDataMappingService | calculateOrderMargins | 1/1 ---
    private void calculateOrderMargins(CartOrderDataDetails.OrderData orderData, OrderEntity order) {
        BigDecimal orderAmount = order.getAmount();
        BigDecimal buyingPrice = getBuyingPrice(order);
        
        BigDecimal rupeeNetMargin = orderAmount.subtract(buyingPrice);
        BigDecimal netMargin = calculatePercentageMargin(rupeeNetMargin, orderAmount);
        
        orderData.setOrderRupeeNetMargin(rupeeNetMargin.setScale(2, RoundingMode.HALF_UP).doubleValue());
        orderData.setOrderNetMargin(netMargin.doubleValue());

--- CartServiceV4Impl.java | CartServiceV4Impl | populateDeliveryFeeNudgeItems | 1/2 ---
    private void populateDeliveryFeeNudgeItems(
            LocationV3Model locationV3Model,
            UserCacheModel userCacheModel,
            CartDetailsCacheModel cartDetailsCacheModel,
            Float cartAmount,
            NudgeDetails nudgeDetails,
            ConfettiDetails confettiDetails
    ) throws IOException {
        Integer clusterId = getFirstClusterId(locationV3Model);
        boolean isCentralisedFlow = cartLevelDeliveryFeeService.centralisationDeliveryFeeConfig(locationV3Model, userCacheModel.getId());
        if (!isCentralisedFlow) return;
        Map<String, Object> feesMap = cartLevelDeliveryFeeService.appendCentralisationDeliveryFeeTitleAndDesc(
                cartAmount.doubleValue(),
                clusterId,
                locationV3Model.getPincode(),
                Objects.nonNull(cartDetailsCacheModel) ? cartDetailsCacheModel.getCartId() : 0,
                Collections.emptyList(),
                locationV3Model.getSpokeWarehouse(),
                userCacheModel.getUserRank(),
                userCacheModel.getId()
        );
        DeliveryFeeDataModel deliveryFeeData = (DeliveryFeeDataModel) feesMap.get(FeesType.DELIVERY_FEES.name());
        if (deliveryFeeData == null) return;
        DeliveryFeeNudgeItem feeNudgeItem = new DeliveryFeeNudgeItem();
        feeNudgeItem.setTncList(Arrays.asList(
                messageSource.getMessage(HOME_NUDGE_DELIVERY_FEE_TNC_ITEM_ONE, new Object[]{deliveryFeeData.getMov()}, LocaleContextHolder.getLocale()),
                messageSource.getMessage(HOME_NUDGE_DELIVERY_FEE_TNC_ITEM_TWO, null, LocaleContextHolder.getLocale())
        ));
        NudgeItemPopUp popUp = createNudgePopUp(
                messageSource.getMessage(HOME_NUDGE_DELIVERY_FEE_POPUP_NAME, null, LocaleContextHolder.getLocale()),
                feeNudgeItem,
                null,"en"
        );
        // Handle fee locked/unlocked case
        if (deliveryFeeData.getDeliveryFee() != null && deliveryFeeData.getDeliveryFee() > 0) {
            feeNudgeItem.setIcon(DELIVERY_FEE_NUDGE_PREE_APPLY_ICON);
            feeNudgeItem.setTitle(messageSource.getMessage(HOME_NUDGE_DELIVERY_FEE_LOCKED_TITLE, null, LocaleContextHolder.getLocale()));
            long remaining = (long) (deliveryFeeData.getMov() - cartAmount);
            feeNudgeItem.setSubTitle(messageSource.getMessage(HOME_NUDGE_DELIVERY_FEE_LOCKED_SUBTITLE, new Object[]{remaining}, LocaleContextHolder.getLocale()));
            if(cartAmount > 0) {
                feeNudgeItem.setProgress((cartAmount * 100) / deliveryFeeData.getMov() + "%");
            }else{
                feeNudgeItem.setSubTitle(messageSource.getMessage(HOME_NUDGE_NO_ITEM_DELIVERY_FEE_SUBTITLE,new Object[]{Math.toIntExact(deliveryFeeData.getMov())},LocaleContextHolder.getLocale()));
            }
        } else {
            feeNudgeItem.setIcon(DELIVERY_FEE_NUDGE_POST_APPLY_ICON);
            feeNudgeItem.setTitle(messageSource.getMessage(HOME_NUDGE_DELIVERY_FEE_UNLOCKED_TITLE, null, LocaleContextHolder.getLocale()));
            feeNudgeItem.setSubTitle(messageSource.getMessage(HOME_NUDGE_DELIVERY_FEE_UNLOCKED_SUBTITLE, new Object[]{deliveryFeeData.getConfigSnapshot().getFees()}, LocaleContextHolder.getLocale()));
            DeliveryFeeConfetti confetti = new DeliveryFeeConfetti();
            confetti.setMessage(messageSource.getMessage(HOME_NUDGE_DELIVERY_FEE_CONFETTI_TITLE, null, LocaleContextHolder.getLocale()));

--- CartServiceV4Impl.java | CartServiceV4Impl | populateDeliveryFeeNudgeItems | 2/2 ---
            feeNudgeItem.setIcon(DELIVERY_FEE_NUDGE_POST_APPLY_ICON);
            feeNudgeItem.setTitle(messageSource.getMessage(HOME_NUDGE_DELIVERY_FEE_UNLOCKED_TITLE, null, LocaleContextHolder.getLocale()));
            feeNudgeItem.setSubTitle(messageSource.getMessage(HOME_NUDGE_DELIVERY_FEE_UNLOCKED_SUBTITLE, new Object[]{deliveryFeeData.getConfigSnapshot().getFees()}, LocaleContextHolder.getLocale()));
            DeliveryFeeConfetti confetti = new DeliveryFeeConfetti();
            confetti.setMessage(messageSource.getMessage(HOME_NUDGE_DELIVERY_FEE_CONFETTI_TITLE, null, LocaleContextHolder.getLocale()));
            confetti.setKey("DELIVERY_FEE_" + clusterId);
            confetti.setImage(DELIVERY_FEE_NUDGE_PREE_APPLY_ICON);
            confetti.setAnimationUrl(ANIMATION_BOX_URL);
            confettiDetails.getConfettiDetails().put("DELIVERY_FEE_" + clusterId, confetti);
        }
        popUp.setTitle(messageSource.getMessage(HOME_NUDGE_DELIVERY_FEE_LOCKED_TITLE, null, LocaleContextHolder.getLocale()));
        feeNudgeItem.setMov(Math.toIntExact(deliveryFeeData.getMov()));
        popUp.setSubTitle("on shopping of items worth ₹" + deliveryFeeData.getMov() + " or more");
        feeNudgeItem.setNudgeItemPopUp(popUp);
        feeNudgeItem.setImage(DELIVERY_FEE_NUDGE_PREE_APPLY_ICON);
        feeNudgeItem.setKey("DELIVERY_FEE_" + clusterId);
        nudgeDetails.getNudgeItemList().add(feeNudgeItem);

--- CartServiceV4Impl.java | CartServiceV4Impl | calculateDeliveryFeeSaved | 1/1 ---
    private BigDecimal calculateDeliveryFeeSaved(DeliveryFeeDataModel delFeeModel, BigDecimal actualDeliveryFee) {
        BigDecimal deliveryFeeSaved = BigDecimal.ZERO;
        if (delFeeModel.getConfigSnapshot() != null && delFeeModel.getConfigSnapshot().getFees() != null) {
            BigDecimal originalFee = BigDecimal.valueOf(delFeeModel.getConfigSnapshot().getFees());
            if (actualDeliveryFee.compareTo(BigDecimal.ZERO) == 0) {
                deliveryFeeSaved = originalFee;
            }
        }
        return deliveryFeeSaved;

--- MyOrderServiceImpl.java | MyOrderServiceImpl | cancelOrder | 1/6 ---
    public Object cancelOrder(OrderCancelModel orderCancelModel, Long userId, Integer palId, Boolean isInternalServiceCall) {

        log.error("Cancel Order request {} and userId : {}, internalServiceCall : {}", orderCancelModel, userId,isInternalServiceCall);

        allowCancellation(orderCancelModel.getOrderId());
        Optional<User> user = userService.getUserFromId(userId,orderCancelModel.getSource());
        if ( ! user.isPresent()) {
            throw new ValidationException("Auth key not exists");
        }

        Optional<Order> order = orderRepository.findByIdAndUserId(orderCancelModel.getOrderId(), user.get().getId());
        if (!order.isPresent()) {
            throw new ValidationException("Order and user id not matching");
        }

        if (this.setCartOrderCancellationKey(orderCancelModel.getOrderId()) == Boolean.FALSE) {
            log.error("Order cancellation is failed due to unable to acquire lock {}, user Id {}", orderCancelModel.getOrderId(), userId);
            throw new ValidationException("Something went wrong, Please try again.");
        }

        ValidationExceptionV2 message = new ValidationExceptionV2();
        List<OrderMovBreach> movBreaches = new ArrayList<>();
        MovBreachMessage movBreachMessage = new MovBreachMessage();
        if (order.isPresent()) {
            if (UserOrderStatus.NONCANCEBLESTATUS.getValues().stream().anyMatch(s -> s.equalsIgnoreCase(order.get().getOrderStatus()))) {
                message.setMessage(messageSource.getMessage("non.cancellable.status", null, LocaleContextHolder.getLocale()));
                return message;
            }
            if (!orderCancelModel.getDiscard()) {
                if ((order.get().getPaymentType().equalsIgnoreCase(OrderPaymentMode.PAYTM.name()) && order.get().getOrderStatus().equalsIgnoreCase("pending"))) {
                    message.setMessage(messageSource.getMessage("cancel.message", null, LocaleContextHolder.getLocale()));
                    return message;
                }
            }
            if(CANCELLED.getValues().stream().anyMatch(s -> s.equalsIgnoreCase(order.get().getOrderStatus()))) {
                message.setMessage(messageSource.getMessage("already.cancelled", null, LocaleContextHolder.getLocale()));
                return message;
            }

            ValidationExceptionV2 validationExceptionV2;
            try{
                Order orderData = order.get();
                Long cartId = null;
                List<CartOrderMapping> cartOrderMappingList = cartOrderMappingRepository.findCartOrderMappings(orderData.getId());
                if (cartOrderMappingList != null && !cartOrderMappingList.isEmpty()) cartId = cartOrderMappingList.get(0).getCartId();

                Optional<UserAddress> userAddress = userAddressesRepository.findById(orderData.getUserAddressId());
                if(!userAddress.isPresent()) throw new ValidationException("User Address not found for this order");

//                LocationV3Model locationV3Model = locationService.getLocationDataFromPinCodeV3(userAddress.get().getPinCode(),

--- MyOrderServiceImpl.java | MyOrderServiceImpl | cancelOrder | 2/6 ---

                Optional<UserAddress> userAddress = userAddressesRepository.findById(orderData.getUserAddressId());
                if(!userAddress.isPresent()) throw new ValidationException("User Address not found for this order");

//                LocationV3Model locationV3Model = locationService.getLocationDataFromPinCodeV3(userAddress.get().getPinCode(),
//                                                null, orderCancelModel.getSource(), null);

                Boolean canCancelCentralizedOrder = this.cancelCentralizedOrder(orderData,cartId,cartOrderMappingList);
                Boolean cartLevelDeliveryFee = false;
                if (checkIfCancellationDisabledSingleOrder(user.get().getId(), orderData, isInternalServiceCall,canCancelCentralizedOrder)) {
                    log.error("Cancellation is disabled for this order : {}", orderData.getId());
                    throw new ValidationException(messageSource.getMessage(CANCELLATION_DISABLED_MESSAGE,null, LocaleContextHolder.getLocale()));
                }

                Map<String, Object> cartItemsInfo = this.checkIfCartContainsOrdOrder(orderData, user.get(),
                        orderCancelModel.getOrdSchemeKey(), cartId,orderCancelModel.getDiscard());
                if (cartId == null) {
                    throw new ValidationException("Valid user cart id is missing");
                }
                Boolean cancelOrderBool = (Boolean) cartItemsInfo.get(CART_CONTAINS_ORD);
                /**
                 * First order condition not to put check delivery fee. not handled pop up cancel
                 * from order success screen
                 */
                //scratch card cancellation msg.
                if(!orderCancelModel.getScratchCardKey()) {
                    Map<String, Object> scratchCardRedeemedCheck =
                        this.checkIfScratchCardRedeemed(orderData, cartId);
                    if (scratchCardRedeemedCheck.containsKey(POPUP_MESSAGE_OBJECT)) {
                        return scratchCardRedeemedCheck.get(POPUP_MESSAGE_OBJECT);
                    }
                }
                boolean revertAB = true;
                if(!orderCancelModel.getOrdSchemeKey() && !orderCancelModel.getDeliveryFeeKey()
                    && revertAB) {
                    // Cart Discount Mov breach check
                    OrderMovBreach discountMovBreach =
                        this.getCartDiscountMovBreach(orderData, cartId, orderCancelModel.getLang());
                    log.error("Cancel Order request Cart Discount MovBreach Response  : {}, userId : {},cartId : {}", discountMovBreach,userId,cartId);
                    if (Objects.nonNull(discountMovBreach)) {
                        movBreaches.add(discountMovBreach);
                    }
                }
                Map<String, Object> checkDeliveryFeeInfo = this.checkDeliveryFee(orderData, user.get(), orderCancelModel, cartId);

                log.error("Cancel Order request CheckDeliveryFee Response  : {}, userId : {},cartId : {}", checkDeliveryFeeInfo,userId,cartId);

                cartLevelDeliveryFee = (Boolean) checkDeliveryFeeInfo.get("CART_LEVEL_DELIVERY_FEE") && checkDeliveryFeeInfo.get("CART_LEVEL_DELIVERY_FEE") != null;
                Boolean deliveryFeeCentralisationFlow = (Boolean) checkDeliveryFeeInfo.get("DELIVERY_FEE_CENTRALISATION_FLOW") && checkDeliveryFeeInfo.get("DELIVERY_FEE_CENTRALISATION_FLOW") != null;
                cancelOrderBool = (Boolean) checkDeliveryFeeInfo.get(DELIVERY_FEES_APPLICABLE_CHECK);

--- MyOrderServiceImpl.java | MyOrderServiceImpl | cancelOrder | 3/6 ---
                log.error("Cancel Order request CheckDeliveryFee Response  : {}, userId : {},cartId : {}", checkDeliveryFeeInfo,userId,cartId);

                cartLevelDeliveryFee = (Boolean) checkDeliveryFeeInfo.get("CART_LEVEL_DELIVERY_FEE") && checkDeliveryFeeInfo.get("CART_LEVEL_DELIVERY_FEE") != null;
                Boolean deliveryFeeCentralisationFlow = (Boolean) checkDeliveryFeeInfo.get("DELIVERY_FEE_CENTRALISATION_FLOW") && checkDeliveryFeeInfo.get("DELIVERY_FEE_CENTRALISATION_FLOW") != null;
                cancelOrderBool = (Boolean) checkDeliveryFeeInfo.get(DELIVERY_FEES_APPLICABLE_CHECK);
                Boolean lastOrder = checkDeliveryFeeInfo.get("LAST_ORDER") != null && (Boolean) checkDeliveryFeeInfo.get("LAST_ORDER");
                if (!orderCancelModel.getOrdSchemeKey() && !orderCancelModel.getDeliveryFeeKey()
                    && checkDeliveryFeeInfo.containsKey(POPUP_MESSAGE_OBJECT)) {
                    List<StaticPropertiesEntity> staticProperties =
                        staticPropertiesRepository.findAllByPropertyKey(DELIVERY_PROP_KEY);
                    if (Objects.isNull(movBreachMessage.getMessage())) {
                        validationExceptionV2 = objectMapper.convertValue(
                            checkDeliveryFeeInfo.get(POPUP_MESSAGE_OBJECT),
                            ValidationExceptionV2.class);
                        addToMovBreachMessage(movBreachMessage, validationExceptionV2);
                    }
                    movBreaches.add(OrderMovBreach.builder()
                        .icon(
                            !CollectionUtils.isEmpty(staticProperties) ? staticProperties.get(0)
                                .getPropertyValue() : null)
                        .message(messageSource.getMessage(DELIVERY_MSG_KEY,
                            new Object[] {checkDeliveryFeeInfo.get("delivery_fee")},
                            LocaleContextHolder.getLocale()))
                        .type("delivery")
                        .build());
                }

                if(!CollectionUtils.isEmpty(movBreaches)) {
                    Collections.reverse(movBreaches);
                    movBreachMessage.setOrderMovBreach(movBreaches);
                    if (Objects.isNull(movBreachMessage.getMessage())) {
                        OrderMovBreach movBreach = movBreaches.get(0);
                        movBreachMessage.setMessageFooter(messageSource
                            .getMessage(MOV_CHECKBOX_MSG, null, LocaleContextHolder.getLocale()));
                        movBreachMessage.setTitle(messageSource
                            .getMessage(MOV_TITLE_MSG, null, LocaleContextHolder.getLocale()));
                        movBreachMessage.setMessage(movBreach.getMessage().replaceAll("<[/]?font>", ""));
                        movBreachMessage.setInternalId(String.valueOf(orderData.getId()));
                        movBreachMessage.setOrdSchemeKey(true);
                    }
                    return movBreachMessage;
                }

                KafkaCancellationRequestModel kafkaPayload = new KafkaCancellationRequestModel();
                kafkaPayload.setCancelOrderBool(cancelOrderBool);
                kafkaPayload.setCartId(cartId);
                kafkaPayload.setCartConfig((CartConfig) cartItemsInfo.get("cartConfig"));
                kafkaPayload.setOrderData(orderData);
                kafkaPayload.setOrderCancelModel(orderCancelModel);
                kafkaPayload.setCancelOrdOrderBool(orderCancelModel.getOrdSchemeKey());

--- MyOrderServiceImpl.java | MyOrderServiceImpl | cancelOrder | 4/6 ---
                kafkaPayload.setCartId(cartId);
                kafkaPayload.setCartConfig((CartConfig) cartItemsInfo.get("cartConfig"));
                kafkaPayload.setOrderData(orderData);
                kafkaPayload.setOrderCancelModel(orderCancelModel);
                kafkaPayload.setCancelOrdOrderBool(orderCancelModel.getOrdSchemeKey());
                kafkaPayload.setUserRank(user.get().getUserRank());
                kafkaPayload.setSource(orderCancelModel.getSource());
                kafkaPayload.setPinCode(user.get().getPincode().toString());
                if(!cancelOrderBool) {
                    if(KafkaConstants.KAFKA_ALLOWED) {
                        queueProducer.produceOrderCancellationSyncEvent(kafkaPayload);
                    } else {
                        log.error("Cancel Order request, payload :{}, cartLevelDeliveryFee : {}, internalCall : {}, userId : {}",
                            kafkaPayload, cartLevelDeliveryFee,isInternalServiceCall, userId);
                        orderCancellation(kafkaPayload, cartLevelDeliveryFee, isInternalServiceCall);

                    }
                }

                if (deliveryFeeCentralisationFlow && (Boolean.TRUE.equals(orderCancelModel.getDeliveryFeeKey()) || lastOrder)){

                        List<UpdateFeesModel> updateModels = new ArrayList<>();
                        UpdateFeesModel updateFeesModel = new UpdateFeesModel();
                        updateFeesModel.setFeeType(FeesType.DELIVERY_FEES.name());

                        if(lastOrder){
                            updateFeesModel.setAppliedFees(0.0);
                            updateFeesModel.setFinalFees(0.0);

                            List<FeeConfiguration> feeConfigurations = feeConfigRepository.findAll();
                            if(!feeConfigurations.isEmpty()) {
                                for(FeeConfiguration feeConfiguration : feeConfigurations){
                                    UpdateFeesModel updateGenericFeeModel = new UpdateFeesModel();
                                    updateGenericFeeModel.setFeeType(feeConfiguration.getCode());
                                    updateGenericFeeModel.setAppliedFees(0.0);
                                    updateGenericFeeModel.setFinalFees(0.0);
                                    updateModels.add(updateGenericFeeModel);
                                }
                            }
                        } else {
                            long deliveryFees = checkDeliveryFeeInfo.get("delivery_fee") != null
                                    ? (Long) checkDeliveryFeeInfo.get("delivery_fee")
                                    : 0L;
                            updateFeesModel.setAppliedFees((double) deliveryFees);
                            updateFeesModel.setFinalFees((double) deliveryFees);
                        }
                        updateModels.add(updateFeesModel);


                        UpdateCartFeesDetails updateCartFeesDetails = new UpdateCartFeesDetails();

--- MyOrderServiceImpl.java | MyOrderServiceImpl | cancelOrder | 5/6 ---
                        }
                        updateModels.add(updateFeesModel);


                        UpdateCartFeesDetails updateCartFeesDetails = new UpdateCartFeesDetails();
                        updateCartFeesDetails.setCartId(cartId);
                        updateCartFeesDetails.setUserId(userId);
                        updateCartFeesDetails.setAllOrderCancelled(lastOrder);
                        updateCartFeesDetails.setCartUpdateData(updateModels);

                        UpdateCartFeesRequest updateCartFeesRequest = new UpdateCartFeesRequest();
                        updateCartFeesRequest.setFlow(FlowType.CANCEL_ORDER);
                        updateCartFeesRequest.setUpdateData(Collections.singletonList(updateCartFeesDetails));

                        try {
                            feesService.updateCartFees(updateCartFeesRequest);
                        } catch (Exception ex){
                            log.error("error in updating cart fees during cancel order,updateCartFeesRequest:{}", updateCartFeesRequest);
                        }

                        if (lastOrder) {
                            try {
                                log.error("Request received for creditCartConfigBenefits cartId {} and userId {} orderId {}", cartId, userId, orderCancelModel.getOrderId());
                                feesService.creditCartConfigBenefits(cartId, userId);
                            } catch (Exception ex){
                                log.error("error in cancel-discarded-orders-creditCartConfigBenefits during cancel order cartId : {}", cartId);
                            }
                        }
                }

                try {
                    schemeServiceClient.updateHomePageDiscountUsed(order.get().getUserId());
                } catch (Exception e) {
                    log.error("Something went wrong while updating home page strip discount amount");
                }
                try {
                    int quantity = order.get().getQuantity() == null ? 1 : order.get().getQuantity().intValue();
                    DealInfo dealInfo = DealInfo.builder().offerId(order.get().getOfferId())
                            .quantity(quantity)
                            .build();
                    FrdSoldUpdateModel frdSoldUpdateModel = FrdSoldUpdateModel
                            .builder().dealDetails(Arrays.asList(dealInfo))
                            .userType(user.get().getUserRank())
                            .pincode(userAddress.get().getPalPincode())
                            .palId(userAddress.get().getPalId())
                            .cancelRequest(true).build();
                    dealServiceClient.updateFrdSoldQuantity(frdSoldUpdateModel, userName, password);
                } catch (Exception e) {
                    log.error("Something went wrong while update frd sold quantity for order cancel {}", e.getMessage());
                }

--- MyOrderServiceImpl.java | MyOrderServiceImpl | cancelOrder | 6/6 ---
                            .cancelRequest(true).build();
                    dealServiceClient.updateFrdSoldQuantity(frdSoldUpdateModel, userName, password);
                } catch (Exception e) {
                    log.error("Something went wrong while update frd sold quantity for order cancel {}", e.getMessage());
                }
            } catch (Exception e) {
                log.error("cancelOrder Method Exception: {} , userId : {}", e.getMessage(),userId,e);
                throw new ValidationException("Something went wrong , please try again!!");
            }
        }
        //updating the cache when order is cancelled.
        etaService.updateOrderStatusWidgetCacheAsync(etaService.updateCacheForCancelledOrders(order.get()));
        return true;

--- MyOrderServiceImpl.java | MyOrderServiceImpl | getComputeCartFeesRequest | 1/2 ---
    private ComputeCartFeesResponse getComputeCartFeesRequest(Order cancelledOrder, OrderCancelModel orderCancelModel, Long cartId){

        List<Order> orderList = orderRepository.findAllOrdersByCartId(cartId);
        List<ComputeFeesOrderDetails> computeFeesOrderDetailsList = new ArrayList<>();
        orderList.forEach(order -> {
            ComputeFeesOrderDetails computeFeesOrderDetails = new ComputeFeesOrderDetails();
            computeFeesOrderDetails.setOrderId(order.getId());
            computeFeesOrderDetails.setQuantity(order.getQuantity());
            computeFeesOrderDetails.setDealPrice(order.getAmount());
            computeFeesOrderDetails.setStatus(order.getOrderStatus());
            computeFeesOrderDetailsList.add(computeFeesOrderDetails);
        });

        List<Long> orderIds = orderList.stream().map(Order::getId).collect(Collectors.toList());

        List<OrderDiscountingHistory> orderDiscountingHistoryList = orderDiscountingHistoryRepository.findAllByOrderIdIn(orderIds);
        List<OrderDiscountingDataModel> orderDiscountingDataModelList = new ArrayList<>();
        orderDiscountingHistoryList.forEach(orderDiscountingHistory -> {
            OrderDiscountingDataModel orderDiscountingDataModel = new OrderDiscountingDataModel();
            orderDiscountingDataModel.setOrderId(orderDiscountingHistory.getOrderId());
            orderDiscountingDataModel.setDiscountAmount(orderDiscountingHistory.getDiscountAmount());
            orderDiscountingDataModel.setDiscountPlanId(orderDiscountingHistory.getDiscountPlanId());
            orderDiscountingDataModel.setDiscountType(orderDiscountingHistory.getDiscountType());
            orderDiscountingDataModelList.add(orderDiscountingDataModel);
        });

        ComputeFeesCancelOrderDetails computeFeesCancelOrderDetails = new ComputeFeesCancelOrderDetails();
        computeFeesCancelOrderDetails.setOrderId(cancelledOrder.getId());
        computeFeesCancelOrderDetails.setQuantity(cancelledOrder.getQuantity().intValue());
        computeFeesCancelOrderDetails.setApplyDeliveryFeeFlag(orderCancelModel.getDeliveryFeeKey());

        ComputeFeesCartDetails computeFeesCartDetails = new ComputeFeesCartDetails();
        computeFeesCartDetails.setCartAmount(orderList.stream().mapToDouble(Order::getAmount).sum());
        computeFeesCartDetails.setOrderDetails(computeFeesOrderDetailsList);
        computeFeesCartDetails.setOrderDiscountDetails(orderDiscountingDataModelList);

        ComputeFeesDetails computeFeesDetails = new ComputeFeesDetails();
        computeFeesDetails.setCartId(cartId);
        computeFeesDetails.setCartDetails(computeFeesCartDetails);
        computeFeesDetails.setCancelOrderDetails(Collections.singletonList(computeFeesCancelOrderDetails));

        ComputeCartFeesRequest computeCartFeesRequest = new ComputeCartFeesRequest();
        computeCartFeesRequest.setFlow(FlowType.CANCEL_ORDER);
        computeCartFeesRequest.setCartData(Collections.singletonList(computeFeesDetails));

        return feesService.computeCartFees(computeCartFeesRequest);

--- MyOrderServiceImpl.java | MyOrderServiceImpl | getComputeCartFeesRequest | 2/2 ---
        return feesService.computeCartFees(computeCartFeesRequest);

--- MyOrderServiceImpl.java | MyOrderServiceImpl | cancelAllOrder | 1/3 ---
    public Object cancelAllOrder(List<OrderCancelModel> orderCancelModelList, Long userId, Integer palId) throws Exception {
        // todo : cart id not same
        // todo : all orders present check
        if (orderCancelModelList == null || orderCancelModelList.isEmpty()) {
            throw new ValidationException("Order cancel list is empty");
        }

        String source = null;
        List<KafkaCancellationRequestModel> kafkaCancellationRequestModelList = new ArrayList<>();

        for (OrderCancelModel orderCancelModel : orderCancelModelList) {
            if (orderCancelModel.getSource() != null) {
                source = orderCancelModel.getSource();
                break;
            }
        }
        if (source == null) {
            throw new ValidationException("Source is null");
        }

        Optional<User> userOptional = userService.getUserFromId(userId, source);
        if (!userOptional.isPresent()) {
            throw new ValidationException("Auth key does not exist");
        }

        User user = userOptional.get();
        List<Long> orderIds = getOrderIds(orderCancelModelList);

        List<Order> orderList = orderRepository.findAllByUserIdAndIdIn(user.getId(), orderIds);
        if (orderList.isEmpty()) {
            throw new ValidationException("No matching orders for this user");
        }

        Map<Long, Order> orderMap = orderList.stream().collect(Collectors.toMap(Order::getId, Function.identity()));

        Map<Long,CartOrderMapping> cartOrderMappingMap = getCartIdsFromOrder(orderList);
        List<Long> cartIds = getCartIds(cartOrderMappingMap);
        if(cartIds.size() > 1){
            log.error("More than 1 cart id present : {}", cartOrderMappingMap);
            throw new ValidationException("More than 1 cart id present");
        }

        Boolean allOrdersPresent  = allOrdersPresent(cartIds.get(0),orderIds);
        if(!allOrdersPresent){
            log.error("Not all orders present for cart id : {} , orderIds : {}", cartIds.get(0),orderIds);
            throw new ValidationException("Not all orders present cart id");
        }

        ValidationExceptionV2 message = new ValidationExceptionV2();
        List<OrderMovBreach> movBreaches = new ArrayList<>();

--- MyOrderServiceImpl.java | MyOrderServiceImpl | cancelAllOrder | 2/3 ---
            throw new ValidationException("Not all orders present cart id");
        }

        ValidationExceptionV2 message = new ValidationExceptionV2();
        List<OrderMovBreach> movBreaches = new ArrayList<>();

        for (OrderCancelModel orderCancelModel : orderCancelModelList) {
            ValidationExceptionV2 messageResponse = OrderStatusCheck(orderMap.get(orderCancelModel.getOrderId()), orderCancelModel, message);
            if (messageResponse != null) {
                return messageResponse;
            }
        }

        try {
            for (OrderCancelModel orderCancelModel : orderCancelModelList) {
                Order orderData = orderMap.get(orderCancelModel.getOrderId());
                Long cartId = getCartIdForOrder(orderData);
                if (checkIfCancellationDisabled(user.getId(), orderData, true)) {
                    log.error("Cancellation is disabled for order: {}", orderData.getId());
                    throw new ValidationException(messageSource.getMessage(CANCELLATION_DISABLED_MESSAGE, null, LocaleContextHolder.getLocale()));
                }
                Map<String, Object> cartItemsInfo = checkIfCartContainsOrdOrder(orderData, user, orderCancelModel.getOrdSchemeKey(), cartId,false);

                // todo : can remove
                if (!orderCancelModel.getScratchCardKey()) {
                    Map<String, Object> scratchCardRedeemedCheck = checkIfScratchCardRedeemed(orderData, cartId);
                    if (scratchCardRedeemedCheck.containsKey(POPUP_MESSAGE_OBJECT)) {
                        return scratchCardRedeemedCheck.get(POPUP_MESSAGE_OBJECT);
                    }
                }

                if (!orderCancelModel.getOrdSchemeKey() && !orderCancelModel.getDeliveryFeeKey()) {
                    OrderMovBreach discountMovBreach = getCartDiscountMovBreach(orderData, cartId, orderCancelModel.getLang());
                    if (discountMovBreach != null) {
                        movBreaches.add(discountMovBreach);
                    }
                }
                KafkaCancellationRequestModel kafkaPayload = createKafkaCancellationPayload(orderData, orderCancelModel, cartId, user, cartItemsInfo);
                kafkaCancellationRequestModelList.add(kafkaPayload);
            }
        } catch (Exception e) {
            log.error("Exception in cancelOrder: {}", e.getMessage());
            throw new ValidationException("Something went wrong, please try again!");
        }

        try {
            // Process bulk order cancellations via Kafka
            orderCancellationBulk(kafkaCancellationRequestModelList, false); // todo : check cart level delivery fee flag
            kafkaCancellationRequestModelList.forEach(order -> {
                try {

--- MyOrderServiceImpl.java | MyOrderServiceImpl | cancelAllOrder | 3/3 ---
        try {
            // Process bulk order cancellations via Kafka
            orderCancellationBulk(kafkaCancellationRequestModelList, false); // todo : check cart level delivery fee flag
            kafkaCancellationRequestModelList.forEach(order -> {
                try {
                    processPostCancellationActions(order.getOrderData(), user);
                } catch (Exception e) {
                    log.error("Error during post-cancellation actions for order {}: {}", order.getOrderData().getId(), e.getMessage());
                }
            });
        } catch (Exception e) {
            log.error("Error in cancelOrder method: {}", e.getMessage());
            throw new ValidationException("Something went wrong, please try again!");
        }

        return true;

--- PointsServiceImpl.java | PointsServiceImpl | creditReturnOrderCustomerPoints | 1/2 ---
    public Map<Long, Float> creditReturnOrderCustomerPoints(List<Order> ordersData) {
        Map<Long, Float> refundMap = new HashMap<>();
        List<CustomerPoints> customerPointsList = new ArrayList<>();

        List<Long> orderIds = ordersData.stream()
                .map(Order::getId)
                .collect(Collectors.toList());

        List<CustomerPoints> orderCreditedCustomerPoints = customerPointsRepository.findByOrderIdInAndTypeAndIncentivePlanId(orderIds, AppConstant.CREDITED, REFUND_PLAN_ID);
        Map<Long, List<CustomerPoints>> alreadyCreditedCustomerPointsMap = new HashMap<>();
        if ( ! orderCreditedCustomerPoints.isEmpty()) {
            alreadyCreditedCustomerPointsMap = orderCreditedCustomerPoints.stream().collect(Collectors.groupingBy(CustomerPoints::getOrderId));
        }

        for (Order order : ordersData) {
            float creditedCustomerPoints = 0f;
            if ( ! ObjectUtils.isEmpty(alreadyCreditedCustomerPointsMap) && alreadyCreditedCustomerPointsMap.containsKey(order.getId())) {
                List<CustomerPoints> existingCustomerPoints = alreadyCreditedCustomerPointsMap.get(order.getId());
                creditedCustomerPoints = existingCustomerPoints.stream()
                        .map(CustomerPoints::getPoints)
                        .filter(points -> points != null)
                        .reduce(0f, Float::sum);
            }

            Date expiryDate = Date.from(new Date().toInstant().atZone(ZoneId.systemDefault()).toLocalDate().plusDays(DEFAULT_REFUND_EXPIRY_DAYS).atStartOfDay(ZoneId.systemDefault()).toInstant());
            try {
                Optional<StaticPropertiesEntity> staticProperties = staticPropertiesRepository.findAllByPropertyKey(REFUND_EXPIRY_DAYS).stream().findFirst();
                Integer days = staticProperties.isPresent() && Integer.valueOf(staticProperties.get().getPropertyValue()) >= 0 ? Integer.valueOf(staticProperties.get().getPropertyValue()) : DEFAULT_REFUND_EXPIRY_DAYS;
                expiryDate = getExpiryDate(days);
            } catch (ParseException e) {
                log.error("Error while fetching refund expiry days from DB: {}", e.getMessage());
            }

            List<OrderDiscountingHistory> orderDiscountingHistories = orderDiscountingHistoryRepository.findByOrderId(order.getId());

            int refundAndWalletDiscountAmount = 0;
            if(orderDiscountingHistories != null && !orderDiscountingHistories.isEmpty()) {
                refundAndWalletDiscountAmount = orderDiscountingHistories.stream()
                        .filter(orderDiscountingHistory ->
                                REFUND_DISCOUNT_TYPE.equalsIgnoreCase(orderDiscountingHistory.getDiscountType()) ||
                                        WALLET_DISCOUNT_TYPE.equalsIgnoreCase(orderDiscountingHistory.getDiscountType())
                        )
                        .map(orderDiscountingHistory ->
                                orderDiscountingHistory.getDiscountAmount() != null ? orderDiscountingHistory.getDiscountAmount() : 0
                        )
                        .reduce(0, Integer::sum);
            }
            log.error("refundAndWalletDiscountAmount : {}, creditedCustomerPoints : {} and amount :{} while creating customerPoints in return refund  for orderId : {}", refundAndWalletDiscountAmount, creditedCustomerPoints,order.getAmount(),order.getId());

            float requiredCustomerPoints = order.getAmount().floatValue() + refundAndWalletDiscountAmount - creditedCustomerPoints;

--- PointsServiceImpl.java | PointsServiceImpl | creditReturnOrderCustomerPoints | 2/2 ---
                        .reduce(0, Integer::sum);
            }
            log.error("refundAndWalletDiscountAmount : {}, creditedCustomerPoints : {} and amount :{} while creating customerPoints in return refund  for orderId : {}", refundAndWalletDiscountAmount, creditedCustomerPoints,order.getAmount(),order.getId());

            float requiredCustomerPoints = order.getAmount().floatValue() + refundAndWalletDiscountAmount - creditedCustomerPoints;
            if (requiredCustomerPoints > 0) {
                CustomerPoints saveCustomerPoints = new CustomerPoints();
                saveCustomerPoints.setExpiryDate(expiryDate);
                saveCustomerPoints.setRemarks(ORDER_RETURN_REFUND_REMARKS);
                saveCustomerPoints.setOrderId(order.getId());
                saveCustomerPoints.setPriority(1L);
                saveCustomerPoints.setType(CREDITED);
                saveCustomerPoints.setStatus(1L);
                saveCustomerPoints.setUserId(order.getUserId());
                saveCustomerPoints.setIncentivePlanId((long) REFUND_PLAN_ID);
                saveCustomerPoints.setPoints(requiredCustomerPoints);
                customerPointsList.add(saveCustomerPoints);
            }

            refundMap.put(order.getId(), requiredCustomerPoints);
            try {
                if (requiredCustomerPoints > 0) {
                    OrderStatusChangeCommModel orderStatusChangeCommModel = new OrderStatusChangeCommModel();
                    orderStatusChangeCommModel.setOrderId(order.getId());
                    orderStatusChangeCommModel.setTemplateName(WALLET_CREDIT_COMM);
                    orderStatusChangeCommModel.setRefundAmount(requiredCustomerPoints);
                    myOrderService.triggerOrderStatusNotification(orderStatusChangeCommModel);
                }
            } catch (Exception ex) {
                log.error("Credit refund points API creditReturnOrderCustomerPoints : {} ex {}", ordersData, ex.getMessage());
            }
        }

        customerPointsRepository.saveAll(customerPointsList);
        raiseThirdPartyEvents(customerPointsList);
        return refundMap;

--- PointsServiceImpl.java | PointsServiceImpl | creditOrderCustomerPoints | 1/3 ---
    public Map<Long, Float> creditOrderCustomerPoints(Order orderData, WalletRefundCreditModel walletRefundCreditModel) {
        if (walletRefundCreditModel.getAmount() > orderData.getAmount().longValue() + orderData.getDiscountAmount()) {
            throw new ValidationException("Refund amount Rs." + walletRefundCreditModel.getAmount()
                    + " is greater than order amount Rs." + orderData.getAmount().longValue() + " and discount amount Rs." + orderData.getDiscountAmount());
        }

        Map<Long, Float> refundMap = new HashMap<>();
        List<CustomerPoints> customerPointsList = new ArrayList<>();

        List<CustomerPoints> orderCreditedCustomerPoints = customerPointsRepository.findByOrderIdInAndTypeInAndStatusAndIncentivePlanId(
                Collections.singletonList(orderData.getId()), Arrays.asList(CREDITED, WALLET_POINTS_PENDING), 1, REFUND_PLAN_ID);
        Map<Long, List<CustomerPoints>> alreadyCreditedCustomerPointsMap = new HashMap<>();
        if ( ! orderCreditedCustomerPoints.isEmpty()) {
            alreadyCreditedCustomerPointsMap = orderCreditedCustomerPoints.stream().collect(Collectors.groupingBy(CustomerPoints::getOrderId));
        }

        float creditedCustomerPoints = 0f;
        if ( ! ObjectUtils.isEmpty(alreadyCreditedCustomerPointsMap) && alreadyCreditedCustomerPointsMap.containsKey(orderData.getId())) {
            List<CustomerPoints> existingCustomerPoints = alreadyCreditedCustomerPointsMap.get(orderData.getId());
            creditedCustomerPoints = existingCustomerPoints.stream()
                    .map(CustomerPoints::getPoints)
                    .filter(points -> points != null)
                    .reduce(0f, Float::sum);
        }

        Date expiryDate = Date.from(new Date().toInstant().atZone(ZoneId.systemDefault()).toLocalDate().plusDays(DEFAULT_REFUND_EXPIRY_DAYS).atStartOfDay(ZoneId.systemDefault()).toInstant());
        try {
            Optional<StaticPropertiesEntity> staticProperties = staticPropertiesRepository.findAllByPropertyKey(REFUND_EXPIRY_DAYS).stream().findFirst();
            Integer days = staticProperties.isPresent() && Integer.valueOf(staticProperties.get().getPropertyValue()) >= 0 ? Integer.valueOf(staticProperties.get().getPropertyValue()) : DEFAULT_REFUND_EXPIRY_DAYS;
            expiryDate = getExpiryDate(days);
        } catch (ParseException e) {
            log.error("Error while fetching refund expiry days from DB: {}", e.getMessage());
        }

        List<OrderDiscountingHistory> orderDiscountingHistories = orderDiscountingHistoryRepository.findByOrderId(orderData.getId());

        int refundAndWalletDiscountAmount = 0;
//        if(orderDiscountingHistories != null && !orderDiscountingHistories.isEmpty()) {
//            refundAndWalletDiscountAmount = orderDiscountingHistories.stream()
//                    .filter(orderDiscountingHistory ->
//                            REFUND_DISCOUNT_TYPE.equalsIgnoreCase(orderDiscountingHistory.getDiscountType()) ||
//                                    WALLET_DISCOUNT_TYPE.equalsIgnoreCase(orderDiscountingHistory.getDiscountType())
//                    )
//                    .map(orderDiscountingHistory ->
//                            orderDiscountingHistory.getDiscountAmount() != null ? orderDiscountingHistory.getDiscountAmount() : 0
//                    )
//                    .reduce(0, Integer::sum);
//        }

        log.error("refundAndWalletDiscountAmount : {}, creditedCustomerPoints : {} and amount :{} while creating customerPoints in return refund  for orderId : {}",

--- PointsServiceImpl.java | PointsServiceImpl | creditOrderCustomerPoints | 2/3 ---
//                    )
//                    .reduce(0, Integer::sum);
//        }

        log.error("refundAndWalletDiscountAmount : {}, creditedCustomerPoints : {} and amount :{} while creating customerPoints in return refund  for orderId : {}",
                refundAndWalletDiscountAmount, creditedCustomerPoints,orderData.getAmount(),orderData.getId());
        if (orderData.getAmount().floatValue() + orderData.getDiscountAmount() <
                refundAndWalletDiscountAmount + creditedCustomerPoints + walletRefundCreditModel.getAmount()) {
            throw new ValidationException("Current refund amount Rs." + walletRefundCreditModel.getAmount() + " and already credited Customer Points " + creditedCustomerPoints + ""
                    + " is greater than order amount Rs." + orderData.getAmount().longValue() + " and discount amount Rs." + orderData.getDiscountAmount());
        }

        int walletRefundsAmount = schemeServiceClient.getUserRefundedValueWallets(walletRefundCreditModel.getUserName());
        int onlineRefundsAmount = paymentServiceClient.getUserRefundedValue(walletRefundCreditModel.getUserName());

        DsUserModel dsUserModel = null;
        try {
            dsUserModel = userServiceClient.searchDsUser(walletRefundCreditModel.getUserName());
        } catch (Exception ex) {
            log.error("creditOrderCustomerPoints user service - user does not exist for {}", walletRefundCreditModel.getUserName());
        }

        boolean creatorAllowedToRefund = true;
        CustomerPoints saveCustomerPoints = new CustomerPoints();
        for (String r : walletRefundCreditModel.getUserRoles()) {
            String trimmedRole = r.trim();
            try {
                PaymentDashboardRoles role = PaymentDashboardRoles.valueOf(trimmedRole);
                if (role.equals(PaymentDashboardRoles.REFUND_CREATER)) {
                    if (ObjectUtils.isEmpty(dsUserModel) || ObjectUtils.isEmpty(dsUserModel.getUserRefundLimit())) {
                        throw new ValidationException("Refund limit not set for the user - " + walletRefundCreditModel.getUserName() + ". Please update from CS Panel");
                    }

                    if ((walletRefundsAmount + onlineRefundsAmount + walletRefundCreditModel.getAmount()) > dsUserModel.getUserRefundLimit()) {
                        creatorAllowedToRefund = false;
                        saveCustomerPoints.setType(WALLET_POINTS_PENDING);
                    } else {
                        saveCustomerPoints.setType(CREDITED);
                    }
                } else if (role.equals(PaymentDashboardRoles.REFUND_INITIATER) || role.equals(PaymentDashboardRoles.REFUND_ADMIN)) {
                    saveCustomerPoints.setType(CREDITED);
                }
            } catch (IllegalArgumentException e) {

            }
        }

        if (ObjectUtils.isEmpty(saveCustomerPoints.getStatus())) {
            throw new ValidationException("You don't have access to create a refund, please contact the dashboard admin");
        }

--- PointsServiceImpl.java | PointsServiceImpl | creditOrderCustomerPoints | 3/3 ---
        }

        if (ObjectUtils.isEmpty(saveCustomerPoints.getStatus())) {
            throw new ValidationException("You don't have access to create a refund, please contact the dashboard admin");
        }

        saveCustomerPoints.setExpiryDate(expiryDate);
        saveCustomerPoints.setRemarks(ORDER_RETURN_REFUND_REMARKS);
        saveCustomerPoints.setOrderId(orderData.getId());
        saveCustomerPoints.setPriority(1L);
        saveCustomerPoints.setStatus(1L);
        saveCustomerPoints.setUserId(orderData.getUserId());
        saveCustomerPoints.setIncentivePlanId((long) REFUND_PLAN_ID);
        saveCustomerPoints.setPoints(walletRefundCreditModel.getAmount());
        saveCustomerPoints.setRemarks(walletRefundCreditModel.getReason());
        saveCustomerPoints.setSupportTicketId(walletRefundCreditModel.getSupportTicketId());
        saveCustomerPoints.setCreatedBy(walletRefundCreditModel.getUserName());
        saveCustomerPoints.setUpdatedBy(walletRefundCreditModel.getUserName());
        saveCustomerPoints.setApprovalFlow(1L);
        customerPointsList.add(saveCustomerPoints);

        refundMap.put(orderData.getId(), walletRefundCreditModel.getAmount());
        try {
            if (walletRefundCreditModel.getAmount() > 0 && saveCustomerPoints.getType().equalsIgnoreCase(CREDITED)) {
                OrderStatusChangeCommModel orderStatusChangeCommModel = new OrderStatusChangeCommModel();
                orderStatusChangeCommModel.setOrderId(orderData.getId());
                orderStatusChangeCommModel.setTemplateName(WALLET_CREDIT_COMM);
                orderStatusChangeCommModel.setRefundAmount(walletRefundCreditModel.getAmount());
                myOrderService.triggerOrderStatusNotification(orderStatusChangeCommModel);
            }
        } catch (Exception ex) {
            log.error("Credit refund points API creditReturnOrderCustomerPoints : {} ex {}", orderData, ex.getMessage());
        }

        customerPointsRepository.saveAll(customerPointsList);
        raiseThirdPartyEvents(customerPointsList);

        if ( ! creatorAllowedToRefund) {
            throw new ValidationException("Your refund is pending. Your refund limit of " + dsUserModel.getUserRefundLimit() + " has been reached. "
                    + "You have already refunded offline amount " + walletRefundsAmount + " and online amount " + onlineRefundsAmount + ".");
        }
        return refundMap;

--- PointsServiceImpl.java | PointsServiceImpl | debitedMyDiscountCart | 1/1 ---
    public void debitedMyDiscountCart(DebitedMyDiscountCartRequestModel debitedMyDiscountCartRequest, OrderEntity order) {
        if (debitedMyDiscountCartRequest.getConfirmIncentive() <= 0) {
            log.error(" debitedMyDiscountCart confirm incentive amount is :{}", debitedMyDiscountCartRequest.getConfirmIncentive());
            return;
        }

        if (debitedMyDiscountCartRequest.getConfirmIncentive() > debitedMyDiscountCartRequest.getBilledAmount()) {
            debitedMyDiscountCartRequest.setConfirmIncentive(debitedMyDiscountCartRequest.getBilledAmount());
        }
        Integer discountPlanId = Integer.parseInt(debitedMyDiscountCartRequest.getPlanId());
        order.setDiscountPlanId(discountPlanId);
//        log.error(" debitedMyDiscountCart get order discount type is :{}", debitedMyDiscountCartRequest.getOrderDiscountType());
        String[] availableDiscountTypes = {"WALLET", "wallet", "walletcashback"};
        if (Arrays.stream(availableDiscountTypes).anyMatch(debitedMyDiscountCartRequest.getOrderDiscountType()::contains)) {

--- UserCartServiceImpl.java | UserCartServiceImpl | prepareCartModel | 1/3 ---
    private UserCartModel prepareCartModel(UserCartType userCartType, Cart cart, Order order, String lang) {
        final UserCartModel userCartModel = new UserCartModel();
        userCartModel.setCartType(userCartType);
        userCartModel.setImages(new ArrayList<>());
        final List<Order> cartOrders = new ArrayList<>();

        Map<String, FeesData> feesMap = new HashMap<>();
        if(checkIfCartIsCentralisation(cart)) {
            feesMap = fetchDeliveryFee(cart.getId());
        }
        List<AmountBreakUp> amountBreakUps = new ArrayList<>();
        AmountBreakUp amountBreakUp = new AmountBreakUp();
        amountBreakUp.setType(AmountBreakUpType.FEES);
        amountBreakUp.setLabel("FEES");


        switch (userCartType) {
            case Cart:
                userCartModel.setId(cart.getId());
                userCartModel.setDeliveryFee(cart.getDeliveryFee() != null ? cart.getDeliveryFee() : 0); // what need to be done for platForm Fees
                cartOrders.addAll(this.orderRepository.getOrdersByCartIdForGetCarts(cart.getId()));
                break;
            case Order:
                userCartModel.setId(order.getId());
                cartOrders.add(order);
                break;
        }
        if(!CollectionUtils.isEmpty(cartOrders)) {
            Map<String, OfferResponseModel> offerResponseModelMap = cartItemService
                    .getOfferMapByOfferIds(cartOrders.stream().map(Order::getOfferId)
                            .collect(Collectors.toList()));
            this.setCartModelDate(userCartModel, cartOrders.get(0), lang);
            this.setCartModelPaymentDetails(userCartModel, cartOrders.get(0), lang);
            cartOrders.forEach(cartOrder -> {
                if(cartOrder.getBilledAmount() == null){
                    log.error("UserCartServiceImpl prepareCartModel -> cartOrder : {}", cartOrder);
                    cartOrder.setBilledAmount(0.0);
                }
                String offerId = cartOrder.getOfferId();
                if (offerResponseModelMap.containsKey(offerId)) {
                    userCartModel.getImages().add(offerResponseModelMap.get(offerId).getImage());
                } else {
                    this.setCartModelImage(userCartModel, cartOrder);
                }
                userCartModel.setQuantity(userCartModel.getQuantity() + 1);
                userCartModel.setOriginalAmount(userCartModel.getOriginalAmount() + cartOrder.getBilledAmount().longValue());
                userCartModel.setFinalAmount(userCartModel.getFinalAmount() + cartOrder.getAmount().longValue());
                final UserOrderStatus orderStatus = UserOrderStatus.getUserOrderStatus(cartOrder.getOrderStatus());

                if (!ObjectUtils.isEmpty(orderStatus)) {

--- UserCartServiceImpl.java | UserCartServiceImpl | prepareCartModel | 2/3 ---
                userCartModel.setOriginalAmount(userCartModel.getOriginalAmount() + cartOrder.getBilledAmount().longValue());
                userCartModel.setFinalAmount(userCartModel.getFinalAmount() + cartOrder.getAmount().longValue());
                final UserOrderStatus orderStatus = UserOrderStatus.getUserOrderStatus(cartOrder.getOrderStatus());

                if (!ObjectUtils.isEmpty(orderStatus)) {
                    switch (orderStatus) {
                        case ONGOING:
                        case OUTFORDELIVERY:
                        case DELIVERED:
                            if(orderStatus.equals(UserOrderStatus.DELIVERED)) {
                                userCartModel.setDeliveredQuantity(userCartModel.getDeliveredQuantity() + 1);
                            } else {
                                userCartModel.setActiveQuantity(userCartModel.getActiveQuantity() + 1);
                            }
                            break;
                        case CANCELLED:
                        case REFUNDED:
                        case RETURNED:
                            userCartModel.setCancelledQuantity(userCartModel.getCancelledQuantity() + 1);
                            break;

                    }
                }
            });

            userCartModel.setFinalAmount(userCartModel.getFinalAmount() + userCartModel.getDeliveryFee());
            if(feesMap != null) {
                for (Map.Entry<String, FeesData> entry : feesMap.entrySet()) {
                    if (entry.getKey().equals(FeesType.DELIVERY_FEES.name())) {
                        userCartModel.setDeliveryFee(entry.getValue().getFeesFinal().longValue());
                        continue;
                    }

                    FeeConfiguration feeConfiguration = feeConfigRepository.findByCode(entry.getKey());

                    Double genericFees = entry.getValue().getFeesFinal();
                    AmountBreakUpDetails amountBreakUpDetails = new AmountBreakUpDetails();
                    amountBreakUpDetails.setType(entry.getKey());
                    amountBreakUpDetails.setLabel(Objects.nonNull(feeConfiguration) ? feeConfiguration.getDisplayName() : entry.getKey());
                    amountBreakUpDetails.setAmountLabel(String.format(AppConstant.FEE_AMOUNT_LABEL_FORMAT, genericFees.intValue()));
                    amountBreakUpDetails.setAmount(genericFees);
                    amountBreakUpDetails.setPriority(entry.getValue().getPriority());

                    if (Objects.isNull(amountBreakUp.getDetails())) {
                        amountBreakUp.setDetails(new ArrayList<>());
                    }
                    amountBreakUp.getDetails().add(amountBreakUpDetails);
                    amountBreakUp.setAmount(amountBreakUp.getAmount() + amountBreakUpDetails.getAmount());

                    userCartModel.setFinalAmount(userCartModel.getFinalAmount() + genericFees.longValue());

--- UserCartServiceImpl.java | UserCartServiceImpl | prepareCartModel | 3/3 ---
                    }
                    amountBreakUp.getDetails().add(amountBreakUpDetails);
                    amountBreakUp.setAmount(amountBreakUp.getAmount() + amountBreakUpDetails.getAmount());

                    userCartModel.setFinalAmount(userCartModel.getFinalAmount() + genericFees.longValue());
                }
            }
            this.setCartStatus(userCartModel, cartOrders, lang);
        }



        AmountBreakUpDetails delFeeAmountBreakUpDetails = new AmountBreakUpDetails();
        delFeeAmountBreakUpDetails.setType(AmountBreakUpDetailType.DELIVERY_FEE.name());
        delFeeAmountBreakUpDetails.setLabel(DELIVERY_FEE);
        delFeeAmountBreakUpDetails.setAmount(userCartModel.getDeliveryFee());
        delFeeAmountBreakUpDetails.setAmountLabel(String.format(AppConstant.FEE_AMOUNT_LABEL_FORMAT, Math.toIntExact(userCartModel.getDeliveryFee())));
        amountBreakUp.setAmount(amountBreakUp.getAmount() + delFeeAmountBreakUpDetails.getAmount());
        if(Objects.isNull(amountBreakUp.getDetails())){
            amountBreakUp.setDetails(new ArrayList<>());
        }
        amountBreakUp.getDetails().add(delFeeAmountBreakUpDetails);

        amountBreakUps.add(amountBreakUp);
        userCartModel.setUserCartAmountBreakUp(amountBreakUps);
        return userCartModel;

--- UserCartServiceImpl.java | UserCartServiceImpl | getCartDiscountItems | 1/5 ---
    private List<DiscountSummaryItem> getCartDiscountItems(List<Order> orders, String authKey,
                                                           String lang, UserCartDetailsModel cartDetailsModel,
                                                           Map<String, FeesData> feesMap){
        List<DiscountSummaryItem> discountSummaryItems = new ArrayList<>();

        BigDecimal totalMrp = BigDecimal.ZERO;
        BigDecimal totalProductDiscount = BigDecimal.ZERO;
        BigDecimal totalBilledAmount = BigDecimal.ZERO;

        List<String> offerIds = orders.stream()
            .map(Order::getOfferId)
            .filter(Objects::nonNull)
            .collect(Collectors.toList());

        List<ProductOffer> productOffers = productOfferRepository.findByOfferIdIn(offerIds);

        Map<String, ProductOffer> offerMap = productOffers.stream()
            .collect(Collectors.toMap(ProductOffer::getOfferId, Function.identity()));

        for (Order order : orders) {
            if (order.getOfferId() != null) {
                ProductOffer productOffer = offerMap.get(order.getOfferId());
                if (productOffer != null) {
                    BigDecimal orderMrp = BigDecimal.valueOf(productOffer.getMrp()).multiply(BigDecimal.valueOf(order.getQuantity()));
                    totalMrp = totalMrp.add(orderMrp);

                    // Calculate product discount (MRP - billedAmount)
                    if (order.getBilledAmount() != null) {
                        BigDecimal orderBilledAmount = BigDecimal.valueOf(order.getBilledAmount());
                        totalBilledAmount = totalBilledAmount.add(orderBilledAmount);

                        BigDecimal orderProductDiscount = orderMrp.subtract(orderBilledAmount);
                        if (orderProductDiscount.compareTo(BigDecimal.ZERO) > 0) {
                            totalProductDiscount = totalProductDiscount.add(orderProductDiscount);
                        }
                    }
                }
            }
        }

        // Create Item Total section if there are products with discounts
        if (totalMrp.compareTo(BigDecimal.ZERO) > 0) {
            // Create Item Total discount summary item
            DiscountSummaryItem itemTotalSummary = DiscountSummaryItem.builder()
                    .discountType(DiscountConstants.ITEM_TOTAL)
                    .discountLabel(messageSource.getMessage(AppConstant.ITEM_TOTAL_LABEL_KEY, null, LocaleContextHolder.getLocale()))
                    .amountAppliedLabel(String.format(AppConstant.ITEM_TOTAL_FORMAT, totalMrp.intValue(), totalBilledAmount.intValue()))
                    .build();

            // Create discount details for Item Total

--- UserCartServiceImpl.java | UserCartServiceImpl | getCartDiscountItems | 2/5 ---
                    .discountLabel(messageSource.getMessage(AppConstant.ITEM_TOTAL_LABEL_KEY, null, LocaleContextHolder.getLocale()))
                    .amountAppliedLabel(String.format(AppConstant.ITEM_TOTAL_FORMAT, totalMrp.intValue(), totalBilledAmount.intValue()))
                    .build();

            // Create discount details for Item Total
            List<DiscountSummaryItemV2> discountDetails = new ArrayList<>();

            // Add MRP detail
            DiscountSummaryItemV2 mrpDetail = new DiscountSummaryItemV2();
            mrpDetail.setDiscountType(DiscountConstants.MRP);
            mrpDetail.setDiscountLabel(messageSource.getMessage(AppConstant.SUMMARY_MRP_LABEL_KEY, null, LocaleContextHolder.getLocale()));
            mrpDetail.setAmountAppliedLabel(String.format(AppConstant.MRP_FORMAT_NO_STRIKE, totalMrp.intValue()));
            discountDetails.add(mrpDetail);

            // Add Product Discount detail if there's any discount
            if (totalProductDiscount.compareTo(BigDecimal.ZERO) > 0) {
                DiscountSummaryItemV2 productDiscountDetail = new DiscountSummaryItemV2();
                productDiscountDetail.setDiscountType(DiscountConstants.PRODUCT_DISCOUNT);
                productDiscountDetail.setDiscountLabel(messageSource.getMessage("product.discount.label", null, LocaleContextHolder.getLocale()));
                productDiscountDetail.setAmountApplied( totalProductDiscount.intValue());
                productDiscountDetail.setAmountAppliedLabel(String.format(AppConstant.DISCOUNT_FORMAT, totalProductDiscount.intValue()));
                discountDetails.add(productDiscountDetail);
            }

            itemTotalSummary.setDiscountDetails(discountDetails);
            discountSummaryItems.add(itemTotalSummary);
        } else {
            // Fallback to original Order Value if we can't calculate MRP
            discountSummaryItems.add(DiscountSummaryItem.builder()
                    .discountLabel(messageSource.getMessage(ORDER_VALUE_KEY, null,LocaleContextHolder.getLocale()))
                    .amountApplied((int) cartDetailsModel.getOriginalAmount())
                    .icon(ORDER_VALUE_ICON)
                    .build());
        }

        List<Long> orderIds = orders.stream().map(Order::getId).collect(Collectors.toList());
        List<DiscountSummaryItem> fromDiscountServiceSummary =
            discountServiceClientWrapper.getOrderDiscountSummaryResponse(orderIds,authKey,lang).getDiscountSummaryItems();

        fromDiscountServiceSummary.forEach(item -> {
            if (item.getAmountAppliedLabel() == null && item.getAmountApplied() != null && item.getAmountApplied() > 0) {
                item.setAmountAppliedLabel(String.format(AppConstant.DISCOUNT_FORMAT, item.getAmountApplied()));
            }
        });

        discountSummaryItems.addAll(fromDiscountServiceSummary);
        List<OrderDiscountingHistory> orderDiscountingHistories = discountService.getAllOrderDiscount(orderIds);
        Map<String,List<OrderDiscountingHistory>> refundAndCashbackMap =
                orderDiscountingHistories.stream().collect(Collectors.groupingBy(OrderDiscountingHistory::getDiscountType));


--- UserCartServiceImpl.java | UserCartServiceImpl | getCartDiscountItems | 3/5 ---
        discountSummaryItems.addAll(fromDiscountServiceSummary);
        List<OrderDiscountingHistory> orderDiscountingHistories = discountService.getAllOrderDiscount(orderIds);
        Map<String,List<OrderDiscountingHistory>> refundAndCashbackMap =
                orderDiscountingHistories.stream().collect(Collectors.groupingBy(OrderDiscountingHistory::getDiscountType));

        Integer walletCashback = refundAndCashbackMap.getOrDefault(DiscountConstants.WALLET_CASHBACK, new ArrayList<>())
            .stream().mapToInt(OrderDiscountingHistory::getDiscountAmount).sum();
        addWalletSummary(walletCashback,discountSummaryItems,DiscountConstants.WALLET_CASHBACK,
                WALLET_CASHBACK_LABEL_KEY, CASHBACK_ICON);

        Integer refundCashback = refundAndCashbackMap.getOrDefault(DiscountConstants.REFUND, new ArrayList<>())
            .stream().mapToInt(OrderDiscountingHistory::getDiscountAmount).sum();
        addWalletSummary(refundCashback,discountSummaryItems,DiscountConstants.REFUND,
                WALLET_REFUND_LABEL_KEY, REFUND_ICON);

        long totalFees = 0L;
        if(!feesMap.isEmpty()){
            List<Map.Entry<String, FeesData>> feesDataList = feesMap.entrySet().stream().sorted((a,b) -> a.getValue().getPriority() - b.getValue().getPriority()).collect(Collectors.toList());
            for(Map.Entry<String, FeesData> entry:feesDataList){
                if(entry.getKey().equals(FeesType.DELIVERY_FEES.name())){
                    FeesData deliveryFeeDataModel = entry.getValue();
                    totalFees = totalFees+deliveryFeeDataModel.getFeesFinal().longValue();

                    DiscountSummaryItem.DiscountSummaryItemBuilder deliveryFeeBuilder = DiscountSummaryItem.builder()
                            .discountType(DiscountConstants.DELIVERY_FEE)
                            .discountLabel(messageSource.getMessage(DELIVERY_FEE_LABEL_KEY, null,LocaleContextHolder.getLocale()))
                            .amountApplied(deliveryFeeDataModel.getFeesFinal().intValue())
                            .icon(DELIVERY_FEE_ICON);

                    Double originalFee = deliveryFeeDataModel.getOriginalDelFee();
                    setDeliveryFeeDisplayLabel(deliveryFeeBuilder, deliveryFeeDataModel.getFeesFinal().intValue(), originalFee);

                    discountSummaryItems.add(deliveryFeeBuilder.build());
                } else {
                    FeeConfiguration feeConfiguration = feeConfigRepository.findByCode(entry.getKey());
                    FeesData platformFeeDataModel = entry.getValue();
                    totalFees = totalFees+platformFeeDataModel.getFeesFinal().longValue();

                    String feesValue;

                    if(Objects.nonNull(platformFeeDataModel.getStrikeOffValue())){
                        feesValue = ZERO.equals(platformFeeDataModel.getFeesFinal().intValue()) ?
                                String.format(PLATFORM_FEE_FREE_STRIKE_FORMAT,platformFeeDataModel.getStrikeOffValue().longValue()) : String.format(PLATFORM_FEE_STRIKE_FORMAT, platformFeeDataModel.getStrikeOffValue().longValue(), platformFeeDataModel.getFeesFinal().intValue());
                    }else{
                        feesValue = ZERO.equals(platformFeeDataModel.getFeesFinal().intValue()) ?
                                PLATFORM_FEE_FREE : String.format(PLATFORM_FEE_FORMAT, platformFeeDataModel.getFeesFinal().intValue());
                    }

                    discountSummaryItems.add(DiscountSummaryItem.builder()
                            .discountLabel(feeConfiguration.getDisplayName())

--- UserCartServiceImpl.java | UserCartServiceImpl | getCartDiscountItems | 4/5 ---
                                PLATFORM_FEE_FREE : String.format(PLATFORM_FEE_FORMAT, platformFeeDataModel.getFeesFinal().intValue());
                    }

                    discountSummaryItems.add(DiscountSummaryItem.builder()
                            .discountLabel(feeConfiguration.getDisplayName())
                            .amountApplied(platformFeeDataModel.getFeesFinal().intValue())
                            .amountAppliedLabel(feesValue)
                            .icon(DELIVERY_FEE_ICON)
                            .build());
                }
            }
        } else {
            totalFees = cartDetailsModel.getDeliveryFee();
            // For non-centralized delivery fee, check if we can get original fee from cart config
            Double originalFee = getOriginalDeliveryFeeFromCartConfig(cartDetailsModel.getId());

            DiscountSummaryItem.DiscountSummaryItemBuilder deliveryFeeBuilder = DiscountSummaryItem.builder()
                    .discountType(DiscountConstants.DELIVERY_FEE)
                    .discountLabel(messageSource.getMessage(DELIVERY_FEE_LABEL_KEY, null,LocaleContextHolder.getLocale()))
                    .amountApplied((int) cartDetailsModel.getDeliveryFee())
                    .icon(DELIVERY_FEE_ICON);

            setDeliveryFeeDisplayLabel(deliveryFeeBuilder, (int) cartDetailsModel.getDeliveryFee(), originalFee);

            discountSummaryItems.add(deliveryFeeBuilder.build());
        }

        Integer bankDiscount = refundAndCashbackMap.getOrDefault(DiscountConstants.BANK_OFFER, new ArrayList<>())
            .stream().mapToInt(OrderDiscountingHistory::getDiscountAmount).sum();

        discountSummaryItems.add(DiscountSummaryItem.builder()
            .discountLabel(messageSource.getMessage(DISCOUNT_TYPE+DEFAULT_DISCOUNT_TYPE, null,LocaleContextHolder.getLocale()))
            .amountApplied(bankDiscount)
            .amountAppliedLabel(String.format(AppConstant.DISCOUNT_FORMAT, bankDiscount))
            .icon(ORDER_VALUE_ICON)
            .build());

        int finalDiscountAmount = walletCashback + refundCashback + bankDiscount +
            fromDiscountServiceSummary.stream().mapToInt(DiscountSummaryItem::getAmountApplied).sum();

        cartDetailsModel.setFinalDiscount(finalDiscountAmount);

        long finalAmount = cartDetailsModel.getOriginalAmount() - cartDetailsModel.getFinalDiscount() + totalFees;
        cartDetailsModel.setFinalAmount(finalAmount);
        cartDetailsModel.setTotalPrice(finalAmount); // Set totalPrice for backward compatibility

        return discountSummaryItems;

--- UserCartServiceImpl.java | UserCartServiceImpl | getCartDiscountItems | 5/5 ---

        return discountSummaryItems;