Context for question:
/v1/minimart-order-sync

--- MyOrderController.java | MyOrderController | triggerOrderStatusNotificationBulk | CODE | 1/1 ---
    @Async
    @PostMapping(value = "/v1/order/status-change-noti-bulk")
    public ResponseEntity<?> triggerOrderStatusNotificationBulk(@RequestBody BulkOrderStatusChangeCommModel orderStatusChangeCommModel) {
        log.error("Request received in /v1/order/status-change-noti-bulk, orderStatusChangeCommModel {}", orderStatusChangeCommModel);
        myOrderService.triggerOrderStatusNotificationBulk(orderStatusChangeCommModel);
        return new ResponseEntity<>("Success", HttpStatus.OK);

--- CartOrderPrivateController.java | CartOrderPrivateController | minimartOrderSync | CODE | 1/1 ---
    @PostMapping(value = "/v1/minimart-order-sync")
    public ResponseEntity<?> minimartOrderSync(@RequestBody OrderSyncRequestModel orderSyncRequestModel){
        return new ResponseEntity<>(myOrderService.minimartOrderSync(orderSyncRequestModel), HttpStatus.OK);

--- ExpressDeliveryServiceImpl.java | ExpressDeliveryServiceImpl | syncOrdersToIms | CODE | 1/1 ---
    private void syncOrdersToIms(List<DealLevelPromotion> cartItems, long warehouseId) {
        List<Long> orderIds = cartItems.stream().filter(cartItem ->
                cartItem.getDeliveryType().equalsIgnoreCase(DeliveryType.EXPRESS.name()))
                .map(DealLevelPromotion::getOrderPKId).collect(Collectors.toList());
        OrderPushToImsRequest orderPushToImsRequest = new OrderPushToImsRequest();
        orderPushToImsRequest.setWarehouseId(warehouseId);
        orderPushToImsRequest.setOrderIds(orderIds);
        orderPushToImsRequest.setDeliveryType(DeliveryType.EXPRESS.name());
        try {

--- TransactionServiceHelper.java | TransactionServiceHelper | addToOrderAndOrderHistoryModels | CODE | 1/1 ---
    private void addToOrderAndOrderHistoryModels(OrderPromotion orderPromotion, Integer discountAmount,
                                                 List<Order> orderList, List<OrderHistory> orderHistoryList, Long cancelledOrderId) {
        Optional<Order> orderOptional = orderRepository.findById(orderPromotion.getOrderId());
        if (orderOptional.isPresent()) {

--- MyOrderServiceImpl.java | MyOrderServiceImpl | getOrdersBasedOnPhone | CODE | 1/4 ---
    @Override
    public MyOrderResponseModel getOrdersBasedOnPhone(Integer pageNo, Integer pageSize, String phone, String lang, String pinCode, String source) {
        Pageable pageable = PageRequest.of(pageNo, pageSize);
        MyOrderResponseModel myOrderResponseModel = new MyOrderResponseModel();
        JsonNode shareData = null;
        if (pageNo == 0) {
            try {
                shareData = schemeServiceClient.getShareData(userName, password, lang, pinCode, "B2C", phone, "ORDER");
            } catch (Exception e) {
                log.error(e.getMessage());
            }
        }
        myOrderResponseModel.setShareData(shareData);
        final List<String> sources = new ArrayList<>(
                AppSource.B2C.getValues().contains(source)
                        ? AppSource.B2C.getValues()
                        : AppSource.B2B.getValues()
        );
        List<Order> orderList = orderRepository.findByPhoneAndSourceInOrderByOrderDateDesc(phone, sources, pageable);
        List<OrderModel> resultList = new ArrayList<>();
        orderList.forEach(orderEntity -> {
            OrderModel orderModel = new OrderModel();
            Optional<ProductOffer> productOffer = productOfferRepository.findByOfferId(orderEntity.getOfferId());
            if (productOffer.isPresent()) {
                List<ProductOfferTranslation> productTranslations = productTranslationsRepository.findAllByOfferId(productOffer.get().getDealId());
                if (!CollectionUtils.isEmpty(productTranslations)) {
                    Map<String, String> productTitles = new HashMap<>();
                    productTranslations.forEach(productTranslation -> productTitles.put(productTranslation.getLang(), productTranslation.getName()));
                    orderModel.setProductTitle(productTitles);
                }
                orderModel.setProductImage(this.fetchDealImage(productOffer.get().getDealId()));
                orderModel.setProductId(productOffer.get().getProductId());
            }
            Optional<List<BtocInvoiceDetails>> invoiceDetails = btocInvoiceDetailsRepository.findByOrderId(orderEntity.getId());
            if (invoiceDetails.isPresent() && invoiceDetails.get().size() != 0) {
                orderModel.setInvoiceUrl(invoiceUrl + orderEntity.getId());
            }
            orderModel.setIsCancelAllowed(MyOrderPinEncryption.getCancelAllowed(orderEntity.getOrderStatus()));
            if(orderEntity.getOrderStatus().equalsIgnoreCase("pending") && !orderEntity.getPaymentType().equalsIgnoreCase(PAYMENT_TYPE_PAYTM)){
                orderModel.setIsCancelAllowed(Boolean.TRUE);
            }
            if (orderEntity.getAmount() != 0.00) {
                orderModel.setShareMessageAmount(orderEntity.getAmount().longValue());
            } else {
                if(orderEntity.getBilledAmount() == null) {
                    log.error("MyOrderServiceImpl getOrdersBasedOnPhone-> orderEntity :{}", orderEntity);
                    orderEntity.setBilledAmount(0.0);
                }
                orderModel.setShareMessageAmount(orderEntity.getBilledAmount().longValue());
            }

--- MyOrderServiceImpl.java | MyOrderServiceImpl | getOrdersBasedOnPhone | CODE | 2/4 ---
                    log.error("MyOrderServiceImpl getOrdersBasedOnPhone-> orderEntity :{}", orderEntity);
                    orderEntity.setBilledAmount(0.0);
                }
                orderModel.setShareMessageAmount(orderEntity.getBilledAmount().longValue());
            }
            if (orderEntity.getOrderStatus().equalsIgnoreCase(DELIVERED)
                    || orderEntity.getOrderStatus().equalsIgnoreCase(ORDER_REPLACED)) {
                orderModel.setDriverContactNo(helplinePhone);
            }
            if (!ObjectUtils.isEmpty(orderEntity.getDeliveryInfo()) && orderEntity.getOrderStatus().equalsIgnoreCase("outfordelivery")) {
                String[] result = orderEntity.getDeliveryInfo().split("/");
                if (result.length != 0) {
                    orderModel.setDriverName(result[0]);
                    if (result.length == 2) {
                        orderModel.setDriverContactNo(result[1]);
                    } else {
                        orderModel.setDriverContactNo(helplinePhone);
                    }
                }
            }

            String orderStatusText = staticPropertyService.getStaticPropertyCache(
                StaticPropertiesKeyName.SP_ORDER_STATUS.getValue(),
                orderEntity.getOrderStatus(),
                lang
            );

            if (!ObjectUtils.isEmpty(orderStatusText)) {
                orderModel.setOrderStatusDes(orderStatusText);
            } else {
                orderModel.setOrderStatusDes(orderEntity.getOrderStatus());
            }

            if (!orderEntity.getPaymentType().equalsIgnoreCase(OrderPaymentMode.COD.name())) {
                if (orderEntity.getPaymentStatus().equalsIgnoreCase(PaymentStatus.INITIATE_REFUND.name())) {
                    String refundMessageText = staticPropertyService.getStaticPropertyCache (
                        StaticPropertiesKeyName.SP_REFUND_MESSAGE.getValue(),
                        orderEntity.getPaymentStatus(),
                        lang
                    );

                    if (!ObjectUtils.isEmpty(refundMessageText)) {
                        orderModel.setOrderStatusDes(refundMessageText);
                    } else {
                        orderModel.setOrderStatusDes(orderEntity.getPaymentStatus());
                    }

                    String orderStatusTextCOD = staticPropertyService.getStaticPropertyCache (
                        StaticPropertiesKeyName.SP_ORDER_STATUS.getValue(),
                        orderEntity.getPaymentStatus(),

--- MyOrderServiceImpl.java | MyOrderServiceImpl | getOrdersBasedOnPhone | CODE | 3/4 ---
                    }

                    String orderStatusTextCOD = staticPropertyService.getStaticPropertyCache (
                        StaticPropertiesKeyName.SP_ORDER_STATUS.getValue(),
                        orderEntity.getPaymentStatus(),
                        lang
                    );

                    if (!ObjectUtils.isEmpty(orderStatusTextCOD)) {
                        orderModel.setRefundMessage(orderStatusTextCOD);
                    } else {
                        orderModel.setRefundMessage(orderEntity.getPaymentStatus());
                    }
                }

                if (orderEntity.getPaymentStatus().equalsIgnoreCase(PaymentStatus.REFUND_DONE.name())) {
                    String refundMessageText = staticPropertyService.getStaticPropertyCache (
                        StaticPropertiesKeyName.SP_ORDER_STATUS.getValue(),
                        orderEntity.getPaymentStatus(),
                        lang
                    );

                    if (!ObjectUtils.isEmpty(refundMessageText)) {
                        orderModel.setOrderStatusDes(refundMessageText);
                    } else {
                        orderModel.setOrderStatusDes(orderEntity.getPaymentStatus());
                    }
                }
            }

            String orderPaymentStatus = staticPropertyService.getStaticPropertyCache (
                StaticPropertiesKeyName.SP_PAYMENT_TYPE_TEXT.getValue(),
                orderEntity.getPaymentType(),
                lang
            );

            if (!ObjectUtils.isEmpty(orderPaymentStatus)) {
                orderModel.setPaymentType(orderPaymentStatus);
            } else {
                orderModel.setPaymentType(orderEntity.getPaymentType());
            }

            orderModel.setPaymentStatus(orderEntity.getPaymentStatus());
            orderModel.setOrderStatus(orderEntity.getOrderStatus());
            orderModel.setSource(orderEntity.getSource());
            orderModel.setId(orderEntity.getId());
            orderModel.setDeliveryDate(orderEntity.getDeliveryDate());
            orderModel.setOfferId(orderEntity.getOfferId());
            orderModel.setOfferType(orderEntity.getOrderType());


--- MyOrderServiceImpl.java | MyOrderServiceImpl | getOrdersBasedOnPhone | CODE | 4/4 ---
            orderModel.setId(orderEntity.getId());
            orderModel.setDeliveryDate(orderEntity.getDeliveryDate());
            orderModel.setOfferId(orderEntity.getOfferId());
            orderModel.setOfferType(orderEntity.getOrderType());

            orderModel.setOrderDate(orderEntity.getOrderDate());
            orderModel.setQuantity(orderEntity.getQuantity());
            orderModel.setUserId(orderEntity.getUserId());
            orderModel.setOrderId(orderEntity.getOrderId());
            orderModel.setDeliveryFee(new BigDecimal(0));
            orderModel.setPin(MyOrderPinEncryption.getEncryption(orderEntity.getPhone(), orderEntity.getOrderId()));
            resultList.add(orderModel);
        });

        myOrderResponseModel.setOrders(resultList);
        if(resultList.stream().anyMatch(orderModel -> orderModel.getOrderStatus().equalsIgnoreCase("pending"))){
            myOrderResponseModel.setPendingOrders(true);
        }else{
            myOrderResponseModel.setPendingOrders(false);
        }

        if (myOrderResponseModel.getPendingOrders()) {
            String rtgsPaymentStatusText = staticPropertyService.getStaticPropertyCache (
                StaticPropertiesKeyName.SP_RTGS_ADVANCE_PAYMENT_PENDING.getValue(),
                StaticPropertiesPropertyName.SP_SUCCESS_MESSAGE.getValue(),
                lang
            );

            if (!ObjectUtils.isEmpty(rtgsPaymentStatusText)) {
                myOrderResponseModel.setPendingPaymentMessage(rtgsPaymentStatusText);
            }
        }

        return this.setDeliveryFeeInfoInOrders(myOrderResponseModel);

--- MyOrderServiceImpl.java | MyOrderServiceImpl | checkMinimumMovPerDay | CODE | 1/1 ---
    @Override
    public OrderMovModel checkMinimumMovPerDay(String phone, String source, String pinCode) throws IOException {
        OrderMovModel orderMovModel = new OrderMovModel();
        orderMovModel.setIsShow(Boolean.FALSE);
        return orderMovModel;

--- MyOrderServiceImpl.java | MyOrderServiceImpl | getCartIdForOrder | CODE | 1/1 ---
    private Long getCartIdForOrder(Order orderData) {
        Optional<CartOrderMapping> cartOrderMapping = cartOrderMappingRepository.findFirstByOrderId(orderData.getId());
        return cartOrderMapping.map(CartOrderMapping::getCartId).orElse(null);

--- MyOrderServiceImpl.java | MyOrderServiceImpl | pushToSellersPanel | CODE | 1/1 ---
    public void pushToSellersPanel(Order order){
        if(!MARKET_PLACE.equalsIgnoreCase(order.getOrderType()))
            return;


        CancelOrderSellerSyncModel cancelOrderSellerSyncModel= new CancelOrderSellerSyncModel();
        cancelOrderSellerSyncModel.setOrderId(order.getId());
        queueProducer.pushOrderCancelToSellerSync(cancelOrderSellerSyncModel);

--- MyOrderServiceImpl.java | MyOrderServiceImpl | triggerOrderCancelEventBulk | CODE | 1/1 ---
    private void triggerOrderCancelEventBulk(List<Order> orderDataList) {
        List<Long> orderIds = orderDataList.stream().map(Order::getId).collect(Collectors.toList());
        OrdersStatusUpdateEvent ordersStatusUpdateEvent = new OrdersStatusUpdateEvent();
        ordersStatusUpdateEvent.setOrderIds(orderIds);
        if(!orderIds.isEmpty()) {

--- MyOrderServiceImpl.java | MyOrderServiceImpl | addToOrderAndOrderHistoryModels | CODE | 1/1 ---
    private void addToOrderAndOrderHistoryModels(OrderPromotion orderPromotion, Integer discountAmount,
                                                 List<Order> orderList, List<OrderHistory> orderHistoryList, Long cancelledOrderId) {
        Optional<Order> orderOptional = orderRepository.findById(orderPromotion.getOrderId());
        if (orderOptional.isPresent()) {

--- MyOrderServiceImpl.java | MyOrderServiceImpl | bulkReturnWalletUpdate | CODE | 1/1 ---
    @Override
    public BulkOrderReturnWalletUpdate bulkReturnWalletUpdate(BulkCancelWalletCreditModel bulkCancelWalletCreditModel) {
        BulkOrderReturnWalletUpdate bulkOrderReturnWalletUpdate = new BulkOrderReturnWalletUpdate();

        List<Order> ordersData = orderRepository.findByIdIn(bulkCancelWalletCreditModel.getOrderIds());
        if (ordersData.isEmpty()) {
            log.error("bulkReturnWalletUpdate ordersData not found : {}", bulkCancelWalletCreditModel);
            return bulkOrderReturnWalletUpdate;
        }

        bulkOrderReturnWalletUpdate.setBulkCancelWalletUpdate(this.bulkCancelWalletUpdate(bulkCancelWalletCreditModel));

        List<Order> codOrdersData = orderRepository.findByIdInAndPaymentType(bulkCancelWalletCreditModel.getOrderIds(), COD_TYPE);
        if (codOrdersData.isEmpty()) {
            log.error("bulkReturnWalletUpdate codOrdersData ordersData not found : {}", bulkCancelWalletCreditModel);
            return bulkOrderReturnWalletUpdate;
        }

        bulkOrderReturnWalletUpdate.setCreditReturnOrderCustomerPoints(pointsService.creditReturnOrderCustomerPoints(codOrdersData));
        return bulkOrderReturnWalletUpdate;

--- MyOrderServiceImpl.java | MyOrderServiceImpl | triggerOrderStatusNotificationBulk | CODE | 1/1 ---
    @Override
    public void triggerOrderStatusNotificationBulk(BulkOrderStatusChangeCommModel bulkOrderStatusChangeCommModel) {
        if (bulkOrderStatusChangeCommModel.getOrderIds().isEmpty()) {
            return;
        }

        List<Order> ordersData = orderRepository.findByIdIn(bulkOrderStatusChangeCommModel.getOrderIds());
        if (ordersData.isEmpty()) {
            log.error("triggerOrderStatusNotificationBulk ordersData not found : {}", bulkOrderStatusChangeCommModel);
            return;
        }

        for (Long orderId : bulkOrderStatusChangeCommModel.getOrderIds()) {

--- MyOrderServiceImpl.java | MyOrderServiceImpl | triggerOrderCancelEventSyncCall | CODE | 1/1 ---
    @Override
    public void triggerOrderCancelEventSyncCall(Long userId, OrderCancelModel orderCancelModel) {

        if (Objects.isNull(orderCancelModel)  || orderCancelModel.getOrderId() == null) {
            return;
        }

        Optional<Order> optionalOrder = orderRepository.findById(orderCancelModel.getOrderId());
        if(!optionalOrder.isPresent()){
            return;
        }
        Order order = optionalOrder.get();

        OrdersStatusUpdateEvent ordersStatusUpdateEvent = new OrdersStatusUpdateEvent();
        ordersStatusUpdateEvent.setOrderIds(Collections.singletonList(order.getId()));
        String event = order.getPaymentType().equalsIgnoreCase(PAYMENT_TYPE_PAYTM) ?
                APP_CANCEL_ONLINE : APP_CANCEL_COD;
        ordersStatusUpdateEvent.setEvent(event);
        queueProducer.sendOrdersStatusUpdateTopic(ordersStatusUpdateEvent);

        log.error("raised event for order cancellation for dto : {} and event : {} and orderId : {}", ordersStatusUpdateEvent,event,order.getId());

        String flagValue = staticPropertyService.getStaticPropertyCache(SP_USER_RANK_TRANSITION_LIVE,
                SP_USER_RANK_TRANSITION_CANCEL_FLOW, Language.ENG.getValue());
        if (!ObjectUtils.isEmpty(flagValue) && flagValue.equals("true")) {

--- MyOrderServiceImpl.java | MyOrderServiceImpl | minimartOrderSync | CODE | 1/2 ---
    public OrderSyncResponseModel minimartOrderSync(OrderSyncRequestModel orderSyncRequestModel) {

        List<UserOrderSyncModel> userOrderSyncModelList = orderSyncRequestModel.getUserOrderSyncModelList();
        
        List<String> posOrderIds = userOrderSyncModelList.stream()
                .map(UserOrderSyncModel::getPosOrderId)
                .filter(Objects::nonNull)
                .distinct()
                .collect(Collectors.toList());
        
        List<String> acquiredLocks = new ArrayList<>();
        try {
            for (String posOrderId : posOrderIds.stream().sorted().collect(Collectors.toList())) {
                String lockKey = MINIMART_ORDER_SYNC_LOCK + posOrderId;
                acquireLock(lockKey, posOrderId);
                acquiredLocks.add(lockKey);
            }
        } catch (Exception e) {
            // Release all acquired locks if any lock acquisition fails
            releaseLocks(acquiredLocks);
            throw e;
        }

        OrderSyncResponseModel orderSyncResponseModel = new OrderSyncResponseModel();
        Map<String, List<OrderDealMappingModel>> posOrderOmsOrderMap = new HashMap<>();
        Map<String, String> ordersSyncStatusMap = new HashMap<>();

        List<String> posOrderIdList = userOrderSyncModelList.stream()
                .map(UserOrderSyncModel::getPosOrderId)
                .collect(Collectors.toList());

        List<POSOrderMapping> posOrderMappingList = posOrderMappingRepository.findByPosOrderIdIn(posOrderIdList);

        Set<String> posOrderIdSet = posOrderMappingList.stream()
                .map(POSOrderMapping::getPosOrderId)
                .collect(Collectors.toSet());

        List<UserOrderSyncModel> existingUserOrderSyncModelList = userOrderSyncModelList.stream()
                .filter(userOrderSyncModel -> posOrderIdSet.contains(userOrderSyncModel.getPosOrderId()))
                .collect(Collectors.toList());

        Map<String, List<POSOrderMapping>> posOrderMappingMap = posOrderMappingList.stream()
                .collect(Collectors.groupingBy(POSOrderMapping::getPosOrderId));

        posOrderIdSet.clear();

        for(UserOrderSyncModel userOrderSyncModel : existingUserOrderSyncModelList) {
            List<POSOrderMapping> posOrderMappings = posOrderMappingMap.get(userOrderSyncModel.getPosOrderId());

            List<OrderDealMappingModel> orderDealMappingModelList = getOrderDealMappingForExistingOrder(posOrderMappings,

--- MyOrderServiceImpl.java | MyOrderServiceImpl | minimartOrderSync | CODE | 2/2 ---

        for(UserOrderSyncModel userOrderSyncModel : existingUserOrderSyncModelList) {
            List<POSOrderMapping> posOrderMappings = posOrderMappingMap.get(userOrderSyncModel.getPosOrderId());

            List<OrderDealMappingModel> orderDealMappingModelList = getOrderDealMappingForExistingOrder(posOrderMappings,
                    userOrderSyncModel.getOfferIdOrderSummaryModelMap());

            if(!ObjectUtils.isEmpty(orderDealMappingModelList)) {
                posOrderIdSet.add(userOrderSyncModel.getPosOrderId());
                posOrderOmsOrderMap.put(userOrderSyncModel.getPosOrderId(), orderDealMappingModelList);
            }
        }

        userOrderSyncModelList = userOrderSyncModelList.stream()
                .filter(userOrderSyncModel -> !posOrderIdSet.contains(userOrderSyncModel.getPosOrderId()))
                .collect(Collectors.toList());

        for (UserOrderSyncModel userOrderSyncModel : userOrderSyncModelList) {

            UserInfoModel userInfoModel = userOrderSyncModel.getUserInfoModel();
            try {
                UserCacheModel userCacheModel = userService.getUser(userInfoModel);

                /** userCacheModel and userInfoModel pincode can be different if user is present in db already*/
                Long userAddressId = userAddressService.getUserAddress(userCacheModel).getId();

                List<OrderDealMappingModel> orderDealMappingModelList = userOrderService.syncOrders(userCacheModel,
                        userOrderSyncModel,
                        userAddressId);

                posOrderOmsOrderMap.put(userOrderSyncModel.getPosOrderId(), orderDealMappingModelList);
            } catch (Exception e) {
//                chatServiceClient.sendEmailToMultiple(CommonUtils.prepareEmailRequestModel(EmailSubject.MINIMART_ORDER_SYNC.getValue(), String.format("userOrderSyncModel : %s, Exception : %s", userOrderSyncModel, e)));
                ordersSyncStatusMap.put(userOrderSyncModel.getPosOrderId(), e.getMessage());
                log.error("Something went wrong in saving order : {}, Exception : {}", userOrderSyncModel, e.getMessage());
            }
        }
        orderSyncResponseModel.setPosOrderOmsOrderMap(posOrderOmsOrderMap);
        posOrderOmsOrderMap.keySet().forEach(posOrderId -> ordersSyncStatusMap.put(posOrderId, "Synced Successfully"));
        orderSyncResponseModel.setOrdersSyncStatusMap(ordersSyncStatusMap);

        releaseLocks(acquiredLocks);

        return orderSyncResponseModel;

--- MyOrderServiceImpl.java | MyOrderServiceImpl | prepareOrderInfo | CODE | 1/1 ---
    private List<OrderInfo> prepareOrderInfo(List<Order> orders, Set<Long> cancelledByCustomerFault,
                                             Map<Long, OrderCancelDiscountUpdateRequest> orderIdToOrderSyncRequestMap,
                                             Map<Long, DealDetail> orderToDealDetailMap){
        return orders.stream().map(o -> {

--- UserShipmentServiceImpl.java | UserShipmentServiceImpl | calculateShipmentEta | CODE | 1/1 ---
    public void calculateShipmentEta(UserShipmentModel shipment, List<Order> orders){
        Boolean isLive = commonUtils.getEtaFlag(ETA_FLAG,ETA_FLAG);
        String eta = null;
        if(isLive){
            Order latestOrder = orders.stream()
                    .max(Comparator.comparing(Order::getId))
                    .orElse(null);
            eta = etaService.orderEta(latestOrder);
            if (eta != null) {
                try {
                    // Parse the string according to ETA_FORMAT_FROM_CACHE
                    shipment.setEtaFromCache(eta);
                    SimpleDateFormat inputFormat = new SimpleDateFormat(ETA_FORMAT_FROM_CACHE);
                    Date etaDate = inputFormat.parse(eta);
                    eta = commonUtils.formatEtaV2(etaDate);
                } catch (Exception e) {
                    eta = null;
                }
            }
        }
        if(eta == null){
            Optional<List<OrderHistory>> orderHistories = orderHistoryRepository.findByOrderId(orders.get(0).getId());
            eta = orderHistories
                    .flatMap(list -> list.stream()
                            .filter(oh -> OUT_FOR_DELIVERY.equalsIgnoreCase(oh.getStatus()))
                            .map(OrderHistory::getCreatedDate)
                            .filter(Objects::nonNull) // ensure no null date
                            .findFirst()
                    )
                    .map(commonUtils::formatEta)
                    .orElse(null);
        }
        if(eta == null || eta.isEmpty() ){

--- EtaServiceImpl.java | EtaServiceImpl | updateCacheForCancelledOrders | CODE | 1/1 ---
    public List<OrderStatusWidgetCacheUpdateModel> updateCacheForCancelledOrders(Order order){
        if(order == null){
            return null;
        }
        OrderStatusWidgetCacheUpdateModel model = new OrderStatusWidgetCacheUpdateModel();
        model.setOrderId(order.getId());
        model.setUserId(order.getUserId());
        model.setStatus(order.getOrderStatus());
        return Collections.singletonList(model);

--- EtaServiceImpl.java | EtaServiceImpl | updateOrderStatusWidgetCacheAsync | CODE | 1/1 ---
    @Async
    public CompletableFuture<Void> updateOrderStatusWidgetCacheAsync(List<OrderStatusWidgetCacheUpdateModel> orderStatusWidgetCacheUpdateModelList) {
        orderServiceClient.updateOrderStatusWidgetCache(orderStatusWidgetCacheUpdateModelList);
        return CompletableFuture.completedFuture(null);

--- CartServiceV2Impl.java | CartServiceV2Impl | getTitleAndGradientFromEtaDateV2 | CODE | 1/2 ---
    private EtaDisplayData getTitleAndGradientFromEtaDateV2(OrderStatusWidgetStaticModel orderStatusWidgetStaticModel,
                                                    LocalDateTime eta, String lang, Integer warehouseId) {
        EtaDisplayData etaDisplayData = new EtaDisplayData();
        try {
            LocalDate orderETADate = eta.toLocalDate();
            LocalTime orderETATime = eta.toLocalTime();
            LocalDate currentDate =  LocalDate.now();
            LocalDate nextDate = currentDate.plusDays(1);

            OrderConfirmationEtaBufferConfig etaBuffer = etaService.getOrderConfirmationEtaBufferConfig(warehouseId);
            if (Objects.isNull(etaBuffer.getHours()) || etaBuffer.getHours().equals(0L)) {
                etaBuffer.setEnable(true);
                etaBuffer.setHours(1L);
            }

            TomorrowEtaWarehouseConfig etaTomorrow = etaService.getTomorrowEtaWarehouseConfig(warehouseId);

            if (orderETADate.isEqual(currentDate)) {
                EtaDisplayData etaDisplayData1 = getETAResponse(orderStatusWidgetStaticModel.getArrivingToday(),
                        orderETATime,orderStatusWidgetStaticModel.getToday()
                        , etaBuffer, lang, orderStatusWidgetStaticModel);
                return etaDisplayData1;
            } else if (orderETADate.isEqual(nextDate)) {
                if (etaTomorrow.isEnable()) {
                    return getETAResponse(orderStatusWidgetStaticModel.getArrivingTomorrow(),
                            orderETATime, orderStatusWidgetStaticModel.getTomorrow(),
                            etaBuffer, lang, orderStatusWidgetStaticModel);
                } else {
                    etaDisplayData.setTitle(CommonUtils.getValueFromMapByLang(orderStatusWidgetStaticModel.getArrivingTomorrow(), lang));
                    etaDisplayData.setEtaTitle(CommonUtils.getValueFromMapByLang(orderStatusWidgetStaticModel.getArrivingTomorrow(), lang));
                    return etaDisplayData;
                }

            } else if (orderETADate.isAfter(nextDate)) {
                // etaString is replaced by etaDate (need to modify etaDate to match etaString format)
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(stringToDateFormat, Locale.ENGLISH); // Adjust format as needed
                etaDisplayData.setEtaTitle(CommonUtils.getValueFromMapByLang(orderStatusWidgetStaticModel.getArrivingOn(), lang)
                        + orderETADate.format(formatter));
                etaDisplayData.setTitle(CommonUtils.getValueFromMapByLang(orderStatusWidgetStaticModel.getArrivingOn(), lang)
                        + orderETADate.format(formatter));
                return etaDisplayData;

            }
        } catch (Exception e) {
            log.error("Fetching title from eta date {}, input- staticModel: {}, deliveryDateTime: {}, lang: {}",
                    e.getMessage(), orderStatusWidgetStaticModel, eta, lang);
        }
        return etaDisplayData;

--- CartServiceV2Impl.java | CartServiceV2Impl | getTitleAndGradientFromEtaDateV2 | CODE | 2/2 ---
                    e.getMessage(), orderStatusWidgetStaticModel, eta, lang);
        }
        return etaDisplayData;

--- CartServiceV2Impl.java | CartServiceV2Impl | triggerOrderPlacedEvent | CODE | 1/1 ---
    private void triggerOrderPlacedEvent(CartOrderModel responseCartOrderModel){
        List<Long> orderIds = new ArrayList<>();
        responseCartOrderModel.getCartItems()
                .forEach(cartItem -> orderIds.add(cartItem.getOrderPKId()));
        OrdersStatusUpdateEvent ordersStatusUpdateEvent = new OrdersStatusUpdateEvent();
        ordersStatusUpdateEvent.setOrderIds(orderIds);
        ordersStatusUpdateEvent.setEvent(UserRankUpdateEvent.ORDER_PLACED.toString());
        queueProducer.sendOrdersStatusUpdateTopic(ordersStatusUpdateEvent);

        UserRankTransitionRequestModel userRankTransitionRequestModel = UserRankTransitionRequestModel.builder()
                .userId(responseCartOrderModel.getUserId())
                .event(UserRankUpdateEvent.ORDER_PLACED.toString())
                .build();

        try {

--- CartServiceV2Impl.java | CartServiceV2Impl | setPostOrderEtaDeliveryDate | CODE | 1/1 ---
    private void setPostOrderEtaDeliveryDate(List<OrderETAModel> ordersETA, List<DealLevelPromotion> responseDealLevelPromotions) {
            Map<String, OrderETAModel> orderETAMap =
                    ordersETA.stream().collect(
                            Collectors.toMap(OrderETAModel::getOrderId, Function.identity()));
            responseDealLevelPromotions.forEach(dealLevelPromotion -> {

--- UserOrderCartServiceImpl.java | UserOrderCartServiceImpl | setModifiedDate | CODE | 1/1 ---
    private void setModifiedDate(OrderListModel orderListModel, Order order){
        DateFormat dateFormat = new SimpleDateFormat("dd MMM");
        String fetchModifiedDate = dateFormat.format(order.getModifiedDate());
        orderListModel.setDeliveryDate(fetchModifiedDate);

--- UserOrderServiceImpl.java | UserOrderServiceImpl | getOrderTracking | CODE | 1/1 ---
    @Override
    public List<OrderTrackingModel> getOrderTracking(Long orderId, String authkey) {
        List<OrderTrackingModel> orderTrackingModels = new ArrayList<>();
        Optional<List<OrderHistory>> orders = orderHistoryRepository.findByOrderId(orderId);
        if (orders.isPresent()) {
            {
                for (OrderTrackingType orderTrackingType : OrderTrackingType.values()) {
                    OrderTrackingModel orderTrackingModel = new OrderTrackingModel();
                    for (OrderHistory orderHistory : orders.get()) {
                        if (orderHistory.getStatus().equalsIgnoreCase(orderTrackingType.toString())) {
                            orderTrackingModel.setStatus(orderTrackingType.toString());
                            orderTrackingModel.setUpdatedAt(setOrderTrackingDate(orderHistory));
                            orderTrackingModel.setStageChanged(true);
                            break;
                        } else {
                            orderTrackingModel.setStatus(orderTrackingType.toString());
                            orderTrackingModel.setUpdatedAt(setOrderTrackingDate(orderHistory));
                            orderTrackingModel.setStageChanged(false);
                        }
                    }
                    orderTrackingModels.add(orderTrackingModel);
                }
            }
        } else {
            throw new ValidationException("Order not found in Order History");
        }
        return orderTrackingModels;

--- UserOrderServiceImpl.java | UserOrderServiceImpl | setDeliveryDetails | CODE | 1/1 ---
    private void setDeliveryDetails(UserOrderModel userOrder, Order order) {
        if (userOrder.getOrderStatus() == null) {
            return;
        }

        if (!ObjectUtils.isEmpty(userOrder)) {

--- UserOrderServiceImpl.java | UserOrderServiceImpl | createOrderHistory | CODE | 1/1 ---
    private OrderHistory createOrderHistory(Order order, Date cancellationTime) {
        return new OrderHistory(order, cancellationTime,

--- UserOrderServiceImpl.java | UserOrderServiceImpl | discardOrders | CODE | 1/2 ---
    public byte[] discardOrders(MultipartFile file) throws Exception {
        List<OrderStatusUpdateDTO> orderDTOs = parseOrderFile(file);
        if(orderDTOs.size() >= 100 ){
            throw new ValidationException("You can only update 100 orders at a time, can you please update a new file.");
        }
        List<Long> orderIds = orderDTOs.stream()
                .map(OrderStatusUpdateDTO::getOrderId)
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
        List<Order> orders = orderRepository.findByIdIn(orderIds);
        Map<Long, Order> orderIdToOrder = orders.stream()
                .filter(Objects::nonNull)
                .collect(Collectors.toMap(Order::getId, order -> order));
        Map<Long, Order> result = orderIds.stream()
                .filter(orderIdToOrder::containsKey)
                .collect(Collectors.toMap(
                        id -> id,
                        orderIdToOrder::get
                ));
        List<Order> orderToUpdate = new ArrayList<>();
        for(OrderStatusUpdateDTO orderDTO : orderDTOs){
            if(orderDTO.getOrderId() == null){
                orderDTO.setTechRemarks("Order id is null");
            }
            else if(!orderDTO.getStatus().equalsIgnoreCase("discarded")){
                orderDTO.setTechRemarks("Cannot update the status to : "+orderDTO.getStatus());
            }
            else if(orderDTO.getComments() == null || orderDTO.getComments().isEmpty()){
                orderDTO.setTechRemarks("Reason / Remark cannot be empty to discard the order, Please try again with Valid Reason");
            }
            else if(orderDTO.getSubStatus() == null || orderDTO.getSubStatus().isEmpty()){
                orderDTO.setTechRemarks("Substatus cannot be empty to discard the order, Please try again with Valid subStatus");
            }
            else{
                if (result == null || result.get(orderDTO.getOrderId()) == null){
                    orderDTO.setTechRemarks("Order doesn't exist with this id");
                    continue;
                }
                Order order = result.get(orderDTO.getOrderId());
                if(!order.getOrderStatus().equals(CANCEL_STATUS)){
                    if(order.getOrderStatus().equals(DISCARD_STATUS)){
                        orderDTO.setTechRemarks("Order is already in Discard status");
                    }else{
                        orderDTO.setTechRemarks("Order is not in cancel state");
                    }
                }else{
                    order.setOrderStatus(DISCARD_STATUS);
                    order.setOrderSubStatus(orderDTO.getSubStatus());
                    order.setComments(orderDTO.getComments());
                    orderDTO.setTechRemarks(DONE);

--- UserOrderServiceImpl.java | UserOrderServiceImpl | discardOrders | CODE | 2/2 ---
                }else{
                    order.setOrderStatus(DISCARD_STATUS);
                    order.setOrderSubStatus(orderDTO.getSubStatus());
                    order.setComments(orderDTO.getComments());
                    orderDTO.setTechRemarks(DONE);
                    orderToUpdate.add(order);
                }
            }
        }
        orderRepository.saveAll(orderToUpdate);
        byte[] bite = generateCsvFile(orderDTOs);
        emailSenderService.sendEmailWithAttachment(
                DISCARD_ORDER_EMAIL_LIST,
                DISCARD_ORDER_SUBJECT,
                DISCARD_ORDER_CONTENT,
                DISCARD_ORDER_FILE_NAME,
                bite
        );
        return bite;

--- UserOrderServiceImpl.java | UserOrderServiceImpl | discardFlaggedOrders | CODE | 1/2 ---
    public void discardFlaggedOrders(Long userId, Long cartId) {
        if (cartId > 0) {
//            log.error("Discard is blocked as of now userId {} cartId {}", userId, cartId);
            return;
        }

        cartRepository.findCartByIdAndUserId(cartId, userId)
                .orElseThrow(() -> new ValidationException("Cart not found for the given user."));

        List<CartOrderMapping> cartOrderMappings = cartOrderMappingRepository.findByCartId(cartId)
                .orElseThrow(() -> new ValidationException("No orders found for the given cart."));

        List<Long> orderIds = cartOrderMappings.stream()
                .map(CartOrderMapping::getOrderId)
                .collect(Collectors.toList());

        List<Order> orders = orderRepository.findAllById(orderIds);
        if (orders.isEmpty()) {
            throw new ValidationException("Orders not found for the given cart.");
        }

        for (Order order : orders) {
            if (order.getOrderStatus().equals(DISCARD_STATUS)) {
                log.warn("discardFlaggedOrders Order {} is already in discard status, skipping.", order.getId());
                continue;
            }

            if (order.getOrderStatus().equals(CANCEL_STATUS)) {
                log.warn("discardFlaggedOrders Order {} is already in cancel status, skipping.", order.getId());
                continue;
            }

            OrderCancelModel cancelModel = createOrderCancelModel(
                    order.getId(), order.getUserId(), order.getSource(), CANCEL_BY_SYSTEM, "Flagged Abuse Users"
            );

            try {
                myOrderService.cancelOrder(cancelModel, order.getUserId(), null, true);
                myOrderService.triggerOrderCancelEventSyncCall(order.getUserId(),cancelModel);
            } catch (Exception | ValidationExceptionV2 ex) {
                log.error("discardFlaggedOrders Failed to cancel order {}: {}", order.getId(), ex.getMessage(), ex);
            }

            order.setComments("Flagged Abuse Users");
            order.setOrderSubStatus(CANCEL_BY_SYSTEM);
            order.setOrderStatus(DISCARD_STATUS);
        }

        orderRepository.saveAll(orders);

--- UserOrderServiceImpl.java | UserOrderServiceImpl | discardFlaggedOrders | CODE | 2/2 ---
            order.setOrderStatus(DISCARD_STATUS);
        }

        orderRepository.saveAll(orders);

--- KafkaProducer.java | KafkaProducer | sendOrdersStatusUpdateTopic | CODE | 1/1 ---
    @Async
    @Override
    public void sendOrdersStatusUpdateTopic(OrdersStatusUpdateEvent ordersStatusUpdateEvent) {
        try {

--- KafkaProducer.java | KafkaProducer | sendOrderPlacedUserSMSCommunicationEvent | CODE | 1/1 ---
    @Async
    @Override
    public void sendOrderPlacedUserSMSCommunicationEvent(OrderUpdateEventDetail orderUpdateEventDetail) {
        try {

--- UserCartServiceImpl.java | UserCartServiceImpl | CreateOrderWidgetModel | CODE | 1/1 ---
    public EtaWidgetModel CreateOrderWidgetModel(List <Order> orders, String lang){
        EtaWidgetModel etaWidgetModel = EtaWidgetModel.builder().icon("https://images.dealshare.in/1753346135502fi_17124525.png?tr=f-webp").etaTitle("Arriving Soon").build();
        Boolean isLive = getEtaFlag(ETA_FLAG,ETA_FLAG);
        String eta = null;
        try{
            if(isLive){
                Order latestOrder = orders.stream()
                        .max(Comparator.comparing(Order::getId))
                        .orElse(null);
                eta = etaService.orderEta(latestOrder);
                etaWidgetModel.setEtaFromCache(eta);
                SimpleDateFormat inputFormat = new SimpleDateFormat(ETA_FORMAT_FROM_CACHE);
                try {
                    Date date = inputFormat.parse(eta);
                    eta = commonUtils.formatEtaV2(date);
                } catch (Exception e) {
                    eta = null;
                }
            }
            if(eta != null){
                etaWidgetModel.setEtaTitle(ARRIVING);
                etaWidgetModel.setEtaData(eta);
            }else{
                List<Long> ordersList = orders.stream().map(Order::getId).collect(Collectors.toList());
                OrderStatusWidgetStaticModel staticModel = commonUtils.getOrderStatusWidgetFromStaticProperties(ENGLISH);
                ZonedDateTime cartETA = etaService.getEarliestCeiledDeliveryHour(ordersList);
                String finalTitle = etaService.formatDeliveryEta(staticModel,cartETA, lang);
                etaWidgetModel.setEtaTitle(CommonUtils.getValueFromMapByLang(staticModel.getArrivingBy(), lang));
                etaWidgetModel.setEtaData(finalTitle);
            }

        }catch(Exception e){
            log.error("Exception in CreateOrderWidgetModel: {}", e.getMessage(), e);
        }
        return etaWidgetModel;

--- V1UserPhoneCartIdTest.java | V1UserPhoneCartIdTest | testFetchEtaForOrders_IndividualOrderParseException | TEST | 1/2 ---
    @Test
    public void testFetchEtaForOrders_IndividualOrderParseException() throws Exception {
        // Arrange
        List<Long> orderIds = Arrays.asList(101L, 102L);
        
        // Create warehouse delivery ETAs
        List<WarehouseDeliveryEtaEntity> etaEntities = new ArrayList<>();
        
        // Create ETA for order 101 (with valid date)
        WarehouseDeliveryEtaEntity eta1 = new WarehouseDeliveryEtaEntity();
        eta1.setId(1L);
        eta1.setOrderId(101L);
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        Date deliveryDate1 = sdf.parse("2025-01-01");
        eta1.setDeliveryDate(deliveryDate1);
        
        // Create ETA for order 102 
        WarehouseDeliveryEtaEntity eta2 = new WarehouseDeliveryEtaEntity();
        eta2.setId(2L);
        eta2.setOrderId(102L);
        Date deliveryDate2 = sdf.parse("2025-01-02"); // Use a valid date, we'll mock the exception
        eta2.setDeliveryDate(deliveryDate2);
        
        etaEntities.add(eta1);
        etaEntities.add(eta2);
        
        // Mock repository response
        when(warehouseEtaDeliveryRepository.findAllByOrderIdInOrderByDeliveryDateDesc(orderIds))
            .thenReturn(Optional.of(etaEntities));
        
        // Create a partial mock of EtaServiceImpl to capture and validate the calls
        EtaServiceImpl spyEtaService = spy(new EtaServiceImpl());
        ReflectionTestUtils.setField(spyEtaService, "warehouseEtaDeliveryRepository", warehouseEtaDeliveryRepository);
        
        // Make order 101 format successfully
        doReturn("01 January, 2025").when(spyEtaService).fetchEtaForOrder(101L);
        
        // Make order 102 format throw exception - return empty string instead of null
        doReturn("").when(spyEtaService).fetchEtaForOrder(102L);
        
        // Make cart level ETA format successfully
        doReturn("01 January, 2025").when(spyEtaService).fetchEtaForOrder(CART_LEVEL_ETA);
        
        // Act
        Map<Long, String> result = spyEtaService.fetchEtaForOrders(orderIds);
        
        // Assert
        assertNotNull(result);
        assertEquals(3, result.size());  // All entries are included in the result map
        assertTrue(result.containsKey(101L));  // Order 101 has a valid date

--- V1UserPhoneCartIdTest.java | V1UserPhoneCartIdTest | testFetchEtaForOrders_IndividualOrderParseException | TEST | 2/2 ---
        
        // Assert
        assertNotNull(result);
        assertEquals(3, result.size());  // All entries are included in the result map
        assertTrue(result.containsKey(101L));  // Order 101 has a valid date
        assertTrue(result.containsKey(102L));  // Order 102 is included but with empty string
        assertTrue(result.containsKey(CART_LEVEL_ETA));  // Cart level ETA included
        
        // Verify method was called with expected parameters
        verify(spyEtaService).fetchEtaForOrders(orderIds);

--- KafkaProducerTest.java | KafkaProducerTest | testPushOrderCancelToSellerSync | TEST | 1/1 ---
    @Test
    public void testPushOrderCancelToSellerSync() {
        // Arrange
        CancelOrderSellerSyncModel payload = new CancelOrderSellerSyncModel(123L);
        
        // Act
        kafkaProducer.pushOrderCancelToSellerSync(payload);
        
        // Assert
        verify(cancelOrderSellerSyncModelKafkaTemplate).send(eq(CANCEL_ORDER_SELLER_SYNC_TOPIC), eq(payload));

--- CreateOrderServiceAdditionalTest.java | CreateOrderServiceAdditionalTest | testCheckOfflineToOnlineConversion_OfflineSource_ReturnsFalse | TEST | 1/1 ---
    @Test
    public void testCheckOfflineToOnlineConversion_OfflineSource_ReturnsFalse() throws Exception {
        // Setup - Current order is from an offline source (MINIMART)
        User user = createTestUser();
        String currentOrderSource = "MINIMART"; // This is in OFFLINE_SOURCES
        
        // Execute
        Method method = CreateOrderServiceImpl.class.getDeclaredMethod("checkOfflineToOnlineConversion", User.class, String.class);
        method.setAccessible(true);
        Boolean result = (Boolean) method.invoke(createOrderService, user, currentOrderSource);
        
        // Verify
        assertFalse(result, "Should return false when current order source is offline");

--- CreateOrderServiceAdditionalTest.java | CreateOrderServiceAdditionalTest | testCheckOfflineToOnlineConversion_HasMinimartOrdersAndHasPreviousOnlineOrder_ReturnsFalse | TEST | 1/1 ---
    @Test
    public void testCheckOfflineToOnlineConversion_HasMinimartOrdersAndHasPreviousOnlineOrder_ReturnsFalse() throws Exception {
        // Setup - User has MINIMART orders and a previous online order
        User user = createTestUser();
        String currentOrderSource = "app"; // This is in ONLINE_SOURCES
        
        // Reset mocks
        reset(orderRepository);
        
        // Mock list with one MINIMART order
        List<Order> minimartOrders = new ArrayList<>();
        Order minimartOrder = new Order();
        minimartOrders.add(minimartOrder);
        
        // Setup the mocks with correct arguments
        when(orderRepository.findByUserIdAndSourceIn(
                eq(user.getId()),
                eq(OFFLINE_SOURCES),
                any(PageRequest.class)))
                .thenReturn(minimartOrders);
        
        // Setup the user to have a previous COD order (not a first purchase)
        when(orderRepository.findFirstByUserIdAndPaymentType(
                eq(user.getId()), eq(COD_TYPE)))
                .thenReturn(Optional.of(new Order()));
        
        // Execute
        Method method = CreateOrderServiceImpl.class.getDeclaredMethod("checkOfflineToOnlineConversion", User.class, String.class);
        method.setAccessible(true);
        Boolean result = (Boolean) method.invoke(createOrderService, user, currentOrderSource);
        
        // Verify repository calls
        verify(orderRepository).findByUserIdAndSourceIn(
                eq(user.getId()),
                eq(OFFLINE_SOURCES),
                any(PageRequest.class));
                
        verify(orderRepository).findFirstByUserIdAndPaymentType(eq(user.getId()), eq(COD_TYPE));
        
        assertFalse(result, "Should return false when user has previous online orders");

--- CreateOrderServiceAdditionalTest.java | CreateOrderServiceAdditionalTest | testCheckOfflineToOnlineConversion_HasMinimartOrdersAndIsFirstOnlinePurchase_ReturnsTrue | TEST | 1/2 ---
    @Test
    public void testCheckOfflineToOnlineConversion_HasMinimartOrdersAndIsFirstOnlinePurchase_ReturnsTrue() throws Exception {
        // Setup - User has MINIMART orders and this is their first online purchase
        User user = createTestUser();
        String currentOrderSource = "app"; // This is in ONLINE_SOURCES
        
        // Reset mocks
        reset(orderRepository);
        
        // Mock list with one MINIMART order
        List<Order> minimartOrders = new ArrayList<>();
        Order minimartOrder = new Order();
        minimartOrders.add(minimartOrder);
        
        // Setup the mocks with correct arguments
        when(orderRepository.findByUserIdAndSourceIn(
                eq(user.getId()),
                eq(OFFLINE_SOURCES),
                any(PageRequest.class)))
                .thenReturn(minimartOrders);
        
        // Setup the user to have no previous COD order
        when(orderRepository.findFirstByUserIdAndPaymentType(
                eq(user.getId()), eq(COD_TYPE)))
                .thenReturn(Optional.empty());
                
        // Setup the user to have no previous successful PAYTM order
        when(orderRepository.findFirstByUserIdAndPaymentTypeAndPaymentStatus(
                eq(user.getId()), eq(PAYMENT_TYPE_PAYTM), eq(PAYMENT_SUCCESSFUL)))
                .thenReturn(Optional.empty());
                
        // Setup the user to have no previous refunded PAYTM order
        when(orderRepository.findFirstByUserIdAndPaymentTypeAndPaymentStatus(
                eq(user.getId()), eq(PAYMENT_TYPE_PAYTM), eq(PaymentStatus.REFUND_DONE.name())))
                .thenReturn(Optional.empty());
        
        // Execute
        Method method = CreateOrderServiceImpl.class.getDeclaredMethod("checkOfflineToOnlineConversion", User.class, String.class);
        method.setAccessible(true);
        Boolean result = (Boolean) method.invoke(createOrderService, user, currentOrderSource);
        
        // Verify repository calls
        verify(orderRepository).findByUserIdAndSourceIn(
                eq(user.getId()),
                eq(OFFLINE_SOURCES),
                any(PageRequest.class));
                
        verify(orderRepository).findFirstByUserIdAndPaymentType(eq(user.getId()), eq(COD_TYPE));
        verify(orderRepository).findFirstByUserIdAndPaymentTypeAndPaymentStatus(
                eq(user.getId()), eq(PAYMENT_TYPE_PAYTM), eq(PAYMENT_SUCCESSFUL));

--- CreateOrderServiceAdditionalTest.java | CreateOrderServiceAdditionalTest | testCheckOfflineToOnlineConversion_HasMinimartOrdersAndIsFirstOnlinePurchase_ReturnsTrue | TEST | 2/2 ---
                any(PageRequest.class));
                
        verify(orderRepository).findFirstByUserIdAndPaymentType(eq(user.getId()), eq(COD_TYPE));
        verify(orderRepository).findFirstByUserIdAndPaymentTypeAndPaymentStatus(
                eq(user.getId()), eq(PAYMENT_TYPE_PAYTM), eq(PAYMENT_SUCCESSFUL));
        verify(orderRepository).findFirstByUserIdAndPaymentTypeAndPaymentStatus(
                eq(user.getId()), eq(PAYMENT_TYPE_PAYTM), eq(PaymentStatus.REFUND_DONE.name()));
                
        assertTrue(result, "Should return true when user has MINIMART orders and this is their first online purchase");