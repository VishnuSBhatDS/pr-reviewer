Question: how do we sync minimart orders ? /v1/minimart-order-sync


=== ðŸ§© UnknownRepo â†’ FeesServiceImplTest.java ===

--- FeesServiceImplTest | testUpdateCartConfigBenefits_EmptyOrderIds | TEST | 1/1 ---
    @Test
    public void testUpdateCartConfigBenefits_EmptyOrderIds() {
        // Arrange
        SyncCartConfigUsesModel request = new SyncCartConfigUsesModel();
        request.setOrderIds(new ArrayList<>());
        
        // Act
        Boolean result = feesService.updateCartConfigBenefits(request);
        
        // Assert
        assertTrue(result);
        verify(myOrderService, never()).prepareCartOrdersMap(anyList());

--- FeesServiceImplTest | testUpdateCartConfigBenefits_Success | TEST | 1/1 ---
    @Test
    public void testUpdateCartConfigBenefits_Success() {
        // Arrange
        SyncCartConfigUsesModel request = new SyncCartConfigUsesModel();
        request.setOrderIds(Arrays.asList(1L, 2L));
        
        Map<Long, List<Long>> cartOrdersMap = new HashMap<>();
        cartOrdersMap.put(123L, Arrays.asList(1L, 2L));
        
        UserCartConfigBenefitsHistory debitHistory = new UserCartConfigBenefitsHistory();
        debitHistory.setCartId(123L);
        debitHistory.setTxType("debit");
        debitHistory.setCartConfigBenefitId(456L);
        
        when(myOrderService.prepareCartOrdersMap(Arrays.asList(1L, 2L))).thenReturn(cartOrdersMap);
        when(myOrderService.completeCartCancelledWithoutCustomerFault(anyList(), anyList(), anyList()))
                .thenReturn(Arrays.asList(new com.dealshare.service.cartservice.entities.Order()));
        when(userCartConfigBenefitsHistoryRepository.findByCartIdAndTxType(123L, "credit"))
                .thenReturn(Optional.empty());
        when(userCartConfigBenefitsHistoryRepository.findByCartIdAndTxType(123L, "debit"))
                .thenReturn(Optional.of(debitHistory));
        when(userCartConfigBenefitsRepository.creditUsedBenefitsIfNotInHistory(123L)).thenReturn(1);
        when(userCartConfigBenefitsHistoryRepository.saveAndFlush(any(UserCartConfigBenefitsHistory.class)))
                .thenReturn(new UserCartConfigBenefitsHistory());
        
        // Act
        Boolean result = feesService.updateCartConfigBenefits(request);
        
        // Assert
        assertTrue(result);
        verify(myOrderService).prepareCartOrdersMap(Arrays.asList(1L, 2L));
        verify(userCartConfigBenefitsRepository).creditUsedBenefitsIfNotInHistory(123L);
        verify(userCartConfigBenefitsHistoryRepository).saveAndFlush(any(UserCartConfigBenefitsHistory.class));


=== ðŸ§© UnknownRepo â†’ V1UserPhoneCartIdTest.java ===

--- V1UserPhoneCartIdTest | testFetchEtaForOrders_IndividualOrderParseException | TEST | 1/2 ---
    @Test
    public void testFetchEtaForOrders_IndividualOrderParseException() throws Exception {
        // Arrange
        List<Long> orderIds = Arrays.asList(101L, 102L);
        
        // Create warehouse delivery ETAs
        List<WarehouseDeliveryEtaEntity> etaEntities = new ArrayList<>();
        
        // Create ETA for order 101 (with valid date)
        WarehouseDeliveryEtaEntity eta1 = new WarehouseDeliveryEtaEntity();
        eta1.setId(1L);
        eta1.setOrderId(101L);
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        Date deliveryDate1 = sdf.parse("2025-01-01");
        eta1.setDeliveryDate(deliveryDate1);
        
        // Create ETA for order 102 
        WarehouseDeliveryEtaEntity eta2 = new WarehouseDeliveryEtaEntity();
        eta2.setId(2L);
        eta2.setOrderId(102L);
        Date deliveryDate2 = sdf.parse("2025-01-02"); // Use a valid date, we'll mock the exception
        eta2.setDeliveryDate(deliveryDate2);
        
        etaEntities.add(eta1);
        etaEntities.add(eta2);
        
        // Mock repository response
        when(warehouseEtaDeliveryRepository.findAllByOrderIdInOrderByDeliveryDateDesc(orderIds))
            .thenReturn(Optional.of(etaEntities));
        
        // Create a partial mock of EtaServiceImpl to capture and validate the calls
        EtaServiceImpl spyEtaService = spy(new EtaServiceImpl());
        ReflectionTestUtils.setField(spyEtaService, "warehouseEtaDeliveryRepository", warehouseEtaDeliveryRepository);
        
        // Make order 101 format successfully
        doReturn("01 January, 2025").when(spyEtaService).fetchEtaForOrder(101L);
        
        // Make order 102 format throw exception - return empty string instead of null
        doReturn("").when(spyEtaService).fetchEtaForOrder(102L);
        
        // Make cart level ETA format successfully
        doReturn("01 January, 2025").when(spyEtaService).fetchEtaForOrder(CART_LEVEL_ETA);
        
        // Act
        Map<Long, String> result = spyEtaService.fetchEtaForOrders(orderIds);
        
        // Assert
        assertNotNull(result);
        assertEquals(3, result.size());  // All entries are included in the result map
        assertTrue(result.containsKey(101L));  // Order 101 has a valid date

--- V1UserPhoneCartIdTest | testFetchEtaForOrders_BothParseExceptions | TEST | 1/2 ---
    @Test
    public void testFetchEtaForOrders_BothParseExceptions() throws Exception {
        // Arrange
        List<Long> orderIds = Arrays.asList(101L, 102L);
        
        // Create warehouse delivery ETAs
        List<WarehouseDeliveryEtaEntity> etaEntities = new ArrayList<>();
        
        // Create ETA for order 101 with valid date
        WarehouseDeliveryEtaEntity eta1 = new WarehouseDeliveryEtaEntity();
        eta1.setId(1L);
        eta1.setOrderId(101L);
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        Date deliveryDate1 = sdf.parse("2025-01-01");
        eta1.setDeliveryDate(deliveryDate1);
        
        // Create ETA for order 102 with valid date
        WarehouseDeliveryEtaEntity eta2 = new WarehouseDeliveryEtaEntity();
        eta2.setId(2L);
        eta2.setOrderId(102L);
        Date deliveryDate2 = sdf.parse("2025-01-02");
        eta2.setDeliveryDate(deliveryDate2);
        
        etaEntities.add(eta1);
        etaEntities.add(eta2);
        
        // Mock repository response
        when(warehouseEtaDeliveryRepository.findAllByOrderIdInOrderByDeliveryDateDesc(orderIds))
            .thenReturn(Optional.of(etaEntities));
        
        // Create a partial mock for EtaServiceImpl
        EtaServiceImpl spyEtaService = spy(new EtaServiceImpl());
        ReflectionTestUtils.setField(spyEtaService, "warehouseEtaDeliveryRepository", warehouseEtaDeliveryRepository);
        
        // Make order 101 throw exception - return empty string
        doReturn("").when(spyEtaService).fetchEtaForOrder(101L);
        
        // Make order 102 throw exception - return empty string
        doReturn("").when(spyEtaService).fetchEtaForOrder(102L);
        
        // Make cart level ETA throw exception - return empty string
        doReturn("").when(spyEtaService).fetchEtaForOrder(CART_LEVEL_ETA);
        
        // Act
        Map<Long, String> result = spyEtaService.fetchEtaForOrders(orderIds);
        
        // Assert
        assertNotNull(result);
        assertEquals(3, result.size());  // All entries included but with empty strings
        assertTrue(result.containsKey(101L));  // Order 101 included with empty string

--- V1UserPhoneCartIdTest | testFetchEtaForOrders_IndividualOrderParseException | TEST | 2/2 ---
        
        // Assert
        assertNotNull(result);
        assertEquals(3, result.size());  // All entries are included in the result map
        assertTrue(result.containsKey(101L));  // Order 101 has a valid date
        assertTrue(result.containsKey(102L));  // Order 102 is included but with empty string
        assertTrue(result.containsKey(CART_LEVEL_ETA));  // Cart level ETA included
        
        // Verify method was called with expected parameters
        verify(spyEtaService).fetchEtaForOrders(orderIds);

--- V1UserPhoneCartIdTest | testFetchEtaForOrders_BothParseExceptions | TEST | 2/2 ---
        
        // Assert
        assertNotNull(result);
        assertEquals(3, result.size());  // All entries included but with empty strings
        assertTrue(result.containsKey(101L));  // Order 101 included with empty string
        assertTrue(result.containsKey(102L));  // Order 102 included with empty string
        assertTrue(result.containsKey(CART_LEVEL_ETA));  // Cart level ETA included with empty string
        
        // Verify method was called with expected parameters
        verify(spyEtaService).fetchEtaForOrders(orderIds);


=== ðŸ§© UnknownRepo â†’ KafkaProducerTest.java ===

--- KafkaProducerTest | setUp | TEST | 1/1 ---
    @Before
    public void setUp() {
        // Set up the values for the topics using ReflectionTestUtils
        ReflectionTestUtils.setField(kafkaProducer, "topicName", ORDER_CANCEL_TOPIC);
        ReflectionTestUtils.setField(kafkaProducer, "thirdPartyKafkaTopicName", THIRD_PARTY_TOPIC);
        ReflectionTestUtils.setField(kafkaProducer, "cacnelOrderSellerSyncTopic", CANCEL_ORDER_SELLER_SYNC_TOPIC);

--- KafkaProducerTest | testPushOrderCancelToSellerSync | TEST | 1/1 ---
    @Test
    public void testPushOrderCancelToSellerSync() {
        // Arrange
        CancelOrderSellerSyncModel payload = new CancelOrderSellerSyncModel(123L);
        
        // Act
        kafkaProducer.pushOrderCancelToSellerSync(payload);
        
        // Assert
        verify(cancelOrderSellerSyncModelKafkaTemplate).send(eq(CANCEL_ORDER_SELLER_SYNC_TOPIC), eq(payload));


=== ðŸ§© UnknownRepo â†’ CreateOrderServiceAdditionalTest.java ===

--- CreateOrderServiceAdditionalTest | testCheckOfflineToOnlineConversion_OfflineSource_ReturnsFalse | TEST | 1/1 ---
    @Test
    public void testCheckOfflineToOnlineConversion_OfflineSource_ReturnsFalse() throws Exception {
        // Setup - Current order is from an offline source (MINIMART)
        User user = createTestUser();
        String currentOrderSource = "MINIMART"; // This is in OFFLINE_SOURCES
        
        // Execute
        Method method = CreateOrderServiceImpl.class.getDeclaredMethod("checkOfflineToOnlineConversion", User.class, String.class);
        method.setAccessible(true);
        Boolean result = (Boolean) method.invoke(createOrderService, user, currentOrderSource);
        
        // Verify
        assertFalse(result, "Should return false when current order source is offline");

--- CreateOrderServiceAdditionalTest | testCheckOfflineToOnlineConversion_NoMinimartOrders_ReturnsFalse | TEST | 1/1 ---
    @Test
    public void testCheckOfflineToOnlineConversion_NoMinimartOrders_ReturnsFalse() throws Exception {
        // Setup - User has no MINIMART orders
        User user = createTestUser();
        String currentOrderSource = "app"; // This is in ONLINE_SOURCES
        
        // Reset mocks and set up behavior
        reset(orderRepository);
        
        // When asked for orders from offline sources, return empty list
        when(orderRepository.findByUserIdAndSourceIn(
                eq(user.getId()),
                eq(OFFLINE_SOURCES),  // Directly use the constant
                any(PageRequest.class)))
                .thenReturn(Collections.emptyList());
        
        // Execute
        Method method = CreateOrderServiceImpl.class.getDeclaredMethod("checkOfflineToOnlineConversion", User.class, String.class);
        method.setAccessible(true);
        Boolean result = (Boolean) method.invoke(createOrderService, user, currentOrderSource);
        
        // Verify - repository was called with the right arguments
        verify(orderRepository).findByUserIdAndSourceIn(
                eq(user.getId()),
                eq(OFFLINE_SOURCES),
                any(PageRequest.class));
        
        assertFalse(result, "Should return false when user has no MINIMART orders");

--- CreateOrderServiceAdditionalTest | testCheckOfflineToOnlineConversion_HasMinimartOrdersAndHasPreviousOnlineOrder_ReturnsFalse | TEST | 1/1 ---
    @Test
    public void testCheckOfflineToOnlineConversion_HasMinimartOrdersAndHasPreviousOnlineOrder_ReturnsFalse() throws Exception {
        // Setup - User has MINIMART orders and a previous online order
        User user = createTestUser();
        String currentOrderSource = "app"; // This is in ONLINE_SOURCES
        
        // Reset mocks
        reset(orderRepository);
        
        // Mock list with one MINIMART order
        List<Order> minimartOrders = new ArrayList<>();
        Order minimartOrder = new Order();
        minimartOrders.add(minimartOrder);
        
        // Setup the mocks with correct arguments
        when(orderRepository.findByUserIdAndSourceIn(
                eq(user.getId()),
                eq(OFFLINE_SOURCES),
                any(PageRequest.class)))
                .thenReturn(minimartOrders);
        
        // Setup the user to have a previous COD order (not a first purchase)
        when(orderRepository.findFirstByUserIdAndPaymentType(
                eq(user.getId()), eq(COD_TYPE)))
                .thenReturn(Optional.of(new Order()));
        
        // Execute
        Method method = CreateOrderServiceImpl.class.getDeclaredMethod("checkOfflineToOnlineConversion", User.class, String.class);
        method.setAccessible(true);
        Boolean result = (Boolean) method.invoke(createOrderService, user, currentOrderSource);
        
        // Verify repository calls
        verify(orderRepository).findByUserIdAndSourceIn(
                eq(user.getId()),
                eq(OFFLINE_SOURCES),
                any(PageRequest.class));
                
        verify(orderRepository).findFirstByUserIdAndPaymentType(eq(user.getId()), eq(COD_TYPE));
        
        assertFalse(result, "Should return false when user has previous online orders");

--- CreateOrderServiceAdditionalTest | testCheckOfflineToOnlineConversion_HasMinimartOrdersAndIsFirstOnlinePurchase_ReturnsTrue | TEST | 1/2 ---
    @Test
    public void testCheckOfflineToOnlineConversion_HasMinimartOrdersAndIsFirstOnlinePurchase_ReturnsTrue() throws Exception {
        // Setup - User has MINIMART orders and this is their first online purchase
        User user = createTestUser();
        String currentOrderSource = "app"; // This is in ONLINE_SOURCES
        
        // Reset mocks
        reset(orderRepository);
        
        // Mock list with one MINIMART order
        List<Order> minimartOrders = new ArrayList<>();
        Order minimartOrder = new Order();
        minimartOrders.add(minimartOrder);
        
        // Setup the mocks with correct arguments
        when(orderRepository.findByUserIdAndSourceIn(
                eq(user.getId()),
                eq(OFFLINE_SOURCES),
                any(PageRequest.class)))
                .thenReturn(minimartOrders);
        
        // Setup the user to have no previous COD order
        when(orderRepository.findFirstByUserIdAndPaymentType(
                eq(user.getId()), eq(COD_TYPE)))
                .thenReturn(Optional.empty());
                
        // Setup the user to have no previous successful PAYTM order
        when(orderRepository.findFirstByUserIdAndPaymentTypeAndPaymentStatus(
                eq(user.getId()), eq(PAYMENT_TYPE_PAYTM), eq(PAYMENT_SUCCESSFUL)))
                .thenReturn(Optional.empty());
                
        // Setup the user to have no previous refunded PAYTM order
        when(orderRepository.findFirstByUserIdAndPaymentTypeAndPaymentStatus(
                eq(user.getId()), eq(PAYMENT_TYPE_PAYTM), eq(PaymentStatus.REFUND_DONE.name())))
                .thenReturn(Optional.empty());
        
        // Execute
        Method method = CreateOrderServiceImpl.class.getDeclaredMethod("checkOfflineToOnlineConversion", User.class, String.class);
        method.setAccessible(true);
        Boolean result = (Boolean) method.invoke(createOrderService, user, currentOrderSource);
        
        // Verify repository calls
        verify(orderRepository).findByUserIdAndSourceIn(
                eq(user.getId()),
                eq(OFFLINE_SOURCES),
                any(PageRequest.class));
                
        verify(orderRepository).findFirstByUserIdAndPaymentType(eq(user.getId()), eq(COD_TYPE));
        verify(orderRepository).findFirstByUserIdAndPaymentTypeAndPaymentStatus(
                eq(user.getId()), eq(PAYMENT_TYPE_PAYTM), eq(PAYMENT_SUCCESSFUL));

--- CreateOrderServiceAdditionalTest | testCheckOfflineToOnlineConversion_HasMinimartOrdersAndIsFirstOnlinePurchase_ReturnsTrue | TEST | 2/2 ---
                any(PageRequest.class));
                
        verify(orderRepository).findFirstByUserIdAndPaymentType(eq(user.getId()), eq(COD_TYPE));
        verify(orderRepository).findFirstByUserIdAndPaymentTypeAndPaymentStatus(
                eq(user.getId()), eq(PAYMENT_TYPE_PAYTM), eq(PAYMENT_SUCCESSFUL));
        verify(orderRepository).findFirstByUserIdAndPaymentTypeAndPaymentStatus(
                eq(user.getId()), eq(PAYMENT_TYPE_PAYTM), eq(PaymentStatus.REFUND_DONE.name()));
                
        assertTrue(result, "Should return true when user has MINIMART orders and this is their first online purchase");


=== ðŸ§© UnknownRepo â†’ FeesServiceImpl.java ===

--- FeesServiceImpl | updateCartConfigBenefits | CODE | 1/2 ---
    @Transactional
    @Override
    public Boolean updateCartConfigBenefits(SyncCartConfigUsesModel request) {
        log.error("Request received for updateCartConfigBenefits SyncCartConfigUsesModel {} ", request);
        if (request.getOrderIds().isEmpty()) {
            return true;
        }

        Map<Long, List<Long>> cartOrdersMap = myOrderService.prepareCartOrdersMap(request.getOrderIds());
        if (cartOrdersMap.isEmpty()) {
            return true;
        }

        for (Map.Entry<Long, List<Long>> entry : cartOrdersMap.entrySet()) {
            List<Order> completeCartCancelledOrders = myOrderService.completeCartCancelledWithoutCustomerFault(
                    entry.getValue(),
                    UserOrderStatus.CANCELLED_ORDER_STATUES.getValues(),
                    UserOrderStatus.CUSTOMER_FAULT_CANCELLED_SUB_STATUS.getValues());

            if (completeCartCancelledOrders.isEmpty()) {
                continue;
            }

            Optional<UserCartConfigBenefitsHistory> userCartConfigBenefitsHistory
                    = userCartConfigBenefitsHistoryRepository.findByCartIdAndTxType(entry.getKey(), "credit");
            if (userCartConfigBenefitsHistory.isPresent()) {
                log.error("creditUsedBenefitsIfNotInHistory - credit already exist for cartId {}", entry.getKey());
                continue;
            }

            Optional<UserCartConfigBenefitsHistory> userCartConfigBenefitsDebitHistory
                    = userCartConfigBenefitsHistoryRepository.findByCartIdAndTxType(entry.getKey(), "debit");
            if ( ! userCartConfigBenefitsDebitHistory.isPresent()) {
                log.error("creditUsedBenefitsIfNotInHistory - debit history does not exist for cartId {}", entry.getKey());
                continue;
            }

            try {
                userCartConfigBenefitsRepository.creditUsedBenefitsIfNotInHistory(entry.getKey());

                UserCartConfigBenefitsHistory newUserCartConfigBenefitsHistory = new UserCartConfigBenefitsHistory();
                newUserCartConfigBenefitsHistory.setBenefitCount(1L);
                newUserCartConfigBenefitsHistory.setCartId(entry.getKey());
                newUserCartConfigBenefitsHistory.setTxType("credit");
                newUserCartConfigBenefitsHistory.setCartConfigBenefitId(userCartConfigBenefitsDebitHistory.get().getCartConfigBenefitId());
                userCartConfigBenefitsHistoryRepository.saveAndFlush(newUserCartConfigBenefitsHistory);
            } catch (Exception ex) {
                log.error("Exception in creditUsedBenefitsIfNotInHistory {} cartId {}", ex.getMessage(), entry.getKey());
            }
        }

--- FeesServiceImpl | updateCartConfigBenefits | CODE | 2/2 ---
                userCartConfigBenefitsHistoryRepository.saveAndFlush(newUserCartConfigBenefitsHistory);
            } catch (Exception ex) {
                log.error("Exception in creditUsedBenefitsIfNotInHistory {} cartId {}", ex.getMessage(), entry.getKey());
            }
        }

        return true;


=== ðŸ§© UnknownRepo â†’ OrderServiceClientWrapper.java ===

--- OrderServiceClientWrapper | updateInventoryOnOrderCancellation | CODE | 1/1 ---
    public void updateInventoryOnOrderCancellation(Long orderId, Long quantity, Long offerPkId, String offerId){
        orderServiceClient.updateInventoryOnOrderCancellation(orderId, quantity, offerPkId, offerId);


=== ðŸ§© UnknownRepo â†’ MyOrderController.java ===

--- MyOrderController | triggerOrderStatusNotification | CODE | 1/1 ---
    @Async
    @PostMapping(value = "/v1/order/status-change-noti")
    public ResponseEntity<?> triggerOrderStatusNotification(@RequestBody OrderStatusChangeCommModel orderStatusChangeCommModel) {
        log.error("Request received in /v1/order/status-change-notification, {}", orderStatusChangeCommModel);
        myOrderService.triggerOrderStatusNotification(orderStatusChangeCommModel);
        return new ResponseEntity<>("Success", HttpStatus.OK);

--- MyOrderController | triggerOrderStatusNotificationBulk | CODE | 1/1 ---
    @Async
    @PostMapping(value = "/v1/order/status-change-noti-bulk")
    public ResponseEntity<?> triggerOrderStatusNotificationBulk(@RequestBody BulkOrderStatusChangeCommModel orderStatusChangeCommModel) {
        log.error("Request received in /v1/order/status-change-noti-bulk, orderStatusChangeCommModel {}", orderStatusChangeCommModel);
        myOrderService.triggerOrderStatusNotificationBulk(orderStatusChangeCommModel);
        return new ResponseEntity<>("Success", HttpStatus.OK);


=== ðŸ§© UnknownRepo â†’ CartOrderPrivateController.java ===

--- CartOrderPrivateController | minimartOrderSync | CODE | 1/1 ---
    @PostMapping(value = "/v1/minimart-order-sync")
    public ResponseEntity<?> minimartOrderSync(@RequestBody OrderSyncRequestModel orderSyncRequestModel){
        return new ResponseEntity<>(myOrderService.minimartOrderSync(orderSyncRequestModel), HttpStatus.OK);

--- CartOrderPrivateController | orderStatusEvent | CODE | 1/1 ---
    @PostMapping("/v1/order/status/event")
    public ResponseEntity<?> orderStatusEvent(@RequestBody OrdersStatusUpdateEvent ordersStatusUpdateEvent){
        return myOrderService.triggerEvent(ordersStatusUpdateEvent);


=== ðŸ§© UnknownRepo â†’ ExpressDeliveryServiceImpl.java ===

--- ExpressDeliveryServiceImpl | syncOrdersToIms | CODE | 1/1 ---
    private void syncOrdersToIms(List<DealLevelPromotion> cartItems, long warehouseId) {
        List<Long> orderIds = cartItems.stream().filter(cartItem ->
                cartItem.getDeliveryType().equalsIgnoreCase(DeliveryType.EXPRESS.name()))
                .map(DealLevelPromotion::getOrderPKId).collect(Collectors.toList());
        OrderPushToImsRequest orderPushToImsRequest = new OrderPushToImsRequest();
        orderPushToImsRequest.setWarehouseId(warehouseId);
        orderPushToImsRequest.setOrderIds(orderIds);
        orderPushToImsRequest.setDeliveryType(DeliveryType.EXPRESS.name());
        try {


=== ðŸ§© UnknownRepo â†’ UserAddressServiceImpl.java ===

--- UserAddressServiceImpl | updateLastUsedAddress | CODE | 1/1 ---
    @Async
    public void updateLastUsedAddress(Long userId, Long addressId, String orderStatus) throws Exception {
        UpdateUserAddressRequestModel userAddressRequestModel = new UpdateUserAddressRequestModel();
        userAddressRequestModel.setAddressId(addressId);
        userAddressRequestModel.setUserId(userId);
        userAddressRequestModel.setOrderStatus(orderStatus);
        try {


=== ðŸ§© UnknownRepo â†’ MyOrderServiceImpl.java ===

--- MyOrderServiceImpl | checkMinimumMovPerDay | CODE | 1/1 ---
    @Override
    public OrderMovModel checkMinimumMovPerDay(String phone, String source, String pinCode) throws IOException {
        OrderMovModel orderMovModel = new OrderMovModel();
        orderMovModel.setIsShow(Boolean.FALSE);
        return orderMovModel;

--- MyOrderServiceImpl | pushToSellersPanel | CODE | 1/1 ---
    public void pushToSellersPanel(Order order){
        if(!MARKET_PLACE.equalsIgnoreCase(order.getOrderType()))
            return;


        CancelOrderSellerSyncModel cancelOrderSellerSyncModel= new CancelOrderSellerSyncModel();
        cancelOrderSellerSyncModel.setOrderId(order.getId());
        queueProducer.pushOrderCancelToSellerSync(cancelOrderSellerSyncModel);

--- MyOrderServiceImpl | processCancelOrder | CODE | 1/1 ---
    private void processCancelOrder(Order orderData, String source, OrderCancelModel orderCancelModel, Long cartId,
                                    String pinCode, Boolean cartLevelDeliveryFee,Boolean isInternalServiceCall){
        OrderHistory orderHistory = new OrderHistory(orderData, source, orderData.getUserId());
        String orderStatus = CANCEL_STATUS;
        String orderSubStatus = CANCEL_BY_SYSTEM;
        orderData.setOrderStatus(orderStatus);
        orderData.setOrderSubStatus(orderSubStatus);
        if (Optional.ofNullable(orderCancelModel.getCancellationReason()).isPresent()) {
            if(orderCancelModel.getCancellationReason().startsWith(AVP_CANCELLATION_PREFIX)){
                orderData.setOrderSubStatus(orderCancelModel.getCancellationReason());
            }else if(Optional.ofNullable(orderCancelModel.getComments()).isPresent()){
                orderData.setOrderSubStatus(orderCancelModel.getCancellationReason());
                orderData.setComments(orderCancelModel.getComments());
            }
            else {
                String subStatus = fetchReasonForCancellationFromKey(orderCancelModel.getCancellationReasonTag());
                orderData.setOrderSubStatus(subStatus);
                if (subStatus.equals("app_others") && orderCancelModel.getCancellationReason() != null) {
                    orderData.setComments(orderCancelModel.getCancellationReason());
                }
            }
        }
        this.cancelOrderData(orderData, orderCancelModel.getLang(), true,orderHistory, cartId, pinCode, cartLevelDeliveryFee, false, isInternalServiceCall);

--- MyOrderServiceImpl | triggerOrderCancelEventBulk | CODE | 1/1 ---
    private void triggerOrderCancelEventBulk(List<Order> orderDataList) {
        List<Long> orderIds = orderDataList.stream().map(Order::getId).collect(Collectors.toList());
        OrdersStatusUpdateEvent ordersStatusUpdateEvent = new OrdersStatusUpdateEvent();
        ordersStatusUpdateEvent.setOrderIds(orderIds);
        if(!orderIds.isEmpty()) {

--- MyOrderServiceImpl | triggerOrderCancelEvent | CODE | 1/1 ---
    private void triggerOrderCancelEvent(List<Order> order,Long cartId, Boolean isInternalServiceCall, Boolean cloneCart) {
        if(Objects.isNull(order) || order.isEmpty()) return;

        // no need to raise events for internal service calls and clone cart
        if(!cloneCart && !isInternalServiceCall){

--- MyOrderServiceImpl | bulkReturnWalletUpdate | CODE | 1/1 ---
    @Override
    public BulkOrderReturnWalletUpdate bulkReturnWalletUpdate(BulkCancelWalletCreditModel bulkCancelWalletCreditModel) {
        BulkOrderReturnWalletUpdate bulkOrderReturnWalletUpdate = new BulkOrderReturnWalletUpdate();

        List<Order> ordersData = orderRepository.findByIdIn(bulkCancelWalletCreditModel.getOrderIds());
        if (ordersData.isEmpty()) {
            log.error("bulkReturnWalletUpdate ordersData not found : {}", bulkCancelWalletCreditModel);
            return bulkOrderReturnWalletUpdate;
        }

        bulkOrderReturnWalletUpdate.setBulkCancelWalletUpdate(this.bulkCancelWalletUpdate(bulkCancelWalletCreditModel));

        List<Order> codOrdersData = orderRepository.findByIdInAndPaymentType(bulkCancelWalletCreditModel.getOrderIds(), COD_TYPE);
        if (codOrdersData.isEmpty()) {
            log.error("bulkReturnWalletUpdate codOrdersData ordersData not found : {}", bulkCancelWalletCreditModel);
            return bulkOrderReturnWalletUpdate;
        }

        bulkOrderReturnWalletUpdate.setCreditReturnOrderCustomerPoints(pointsService.creditReturnOrderCustomerPoints(codOrdersData));
        return bulkOrderReturnWalletUpdate;

--- MyOrderServiceImpl | refundOrderWalletCredits | CODE | 1/1 ---
    @Override
    public BulkOrderReturnWalletUpdate refundOrderWalletCredits(WalletRefundCreditModel walletRefundCreditModel) {
        BulkOrderReturnWalletUpdate bulkOrderReturnWalletUpdate = new BulkOrderReturnWalletUpdate();

        List<Order> ordersData = orderRepository.findByIdIn(Collections.singletonList(walletRefundCreditModel.getOrderId()));
        if (ordersData.isEmpty()) {
            log.error("bulkReturnWalletUpdate ordersData not found : {}", walletRefundCreditModel);
            return bulkOrderReturnWalletUpdate;
        }

        if ( ! walletRefundCreditModel.isRefundDiscountAmount()) {
            List<Order> codOrdersData = orderRepository.findByIdInAndPaymentType(Collections.singletonList(walletRefundCreditModel.getOrderId()), COD_TYPE);
            if (codOrdersData.isEmpty()) {
                log.error("bulkReturnWalletUpdate codOrdersData ordersData not found : {}", walletRefundCreditModel);
                return bulkOrderReturnWalletUpdate;
            }
        }

        bulkOrderReturnWalletUpdate.setCreditReturnOrderCustomerPoints(
                pointsService.creditOrderCustomerPoints(ordersData.get(0), walletRefundCreditModel));
        return bulkOrderReturnWalletUpdate;

--- MyOrderServiceImpl | triggerOrderStatusNotification | CODE | 1/1 ---
    @Override
    public void triggerOrderStatusNotification(OrderStatusChangeCommModel orderStatusChangeCommModel) {
        if (ObjectUtils.isEmpty(orderStatusChangeCommModel.getOrderId())) {
            return;
        }

        List<Order> ordersData = orderRepository.findByIdIn(Collections.singletonList(orderStatusChangeCommModel.getOrderId()));
        if (ordersData.isEmpty()) {
            log.error("triggerOrderStatusNotification ordersData not found : {}", orderStatusChangeCommModel);
            return;
        }

        try {

--- MyOrderServiceImpl | triggerOrderStatusNotificationBulk | CODE | 1/1 ---
    @Override
    public void triggerOrderStatusNotificationBulk(BulkOrderStatusChangeCommModel bulkOrderStatusChangeCommModel) {
        if (bulkOrderStatusChangeCommModel.getOrderIds().isEmpty()) {
            return;
        }

        List<Order> ordersData = orderRepository.findByIdIn(bulkOrderStatusChangeCommModel.getOrderIds());
        if (ordersData.isEmpty()) {
            log.error("triggerOrderStatusNotificationBulk ordersData not found : {}", bulkOrderStatusChangeCommModel);
            return;
        }

        for (Long orderId : bulkOrderStatusChangeCommModel.getOrderIds()) {

--- MyOrderServiceImpl | triggerOrderCancelEventSyncCall | CODE | 1/1 ---
    @Override
    public void triggerOrderCancelEventSyncCall(Long userId, OrderCancelModel orderCancelModel) {

        if (Objects.isNull(orderCancelModel)  || orderCancelModel.getOrderId() == null) {
            return;
        }

        Optional<Order> optionalOrder = orderRepository.findById(orderCancelModel.getOrderId());
        if(!optionalOrder.isPresent()){
            return;
        }
        Order order = optionalOrder.get();

        OrdersStatusUpdateEvent ordersStatusUpdateEvent = new OrdersStatusUpdateEvent();
        ordersStatusUpdateEvent.setOrderIds(Collections.singletonList(order.getId()));
        String event = order.getPaymentType().equalsIgnoreCase(PAYMENT_TYPE_PAYTM) ?
                APP_CANCEL_ONLINE : APP_CANCEL_COD;
        ordersStatusUpdateEvent.setEvent(event);
        queueProducer.sendOrdersStatusUpdateTopic(ordersStatusUpdateEvent);

        log.error("raised event for order cancellation for dto : {} and event : {} and orderId : {}", ordersStatusUpdateEvent,event,order.getId());

        String flagValue = staticPropertyService.getStaticPropertyCache(SP_USER_RANK_TRANSITION_LIVE,
                SP_USER_RANK_TRANSITION_CANCEL_FLOW, Language.ENG.getValue());
        if (!ObjectUtils.isEmpty(flagValue) && flagValue.equals("true")) {

--- MyOrderServiceImpl | prepareOrderInfo | CODE | 1/1 ---
    private List<OrderInfo> prepareOrderInfo(List<Order> orders, Set<Long> cancelledByCustomerFault,
                                             Map<Long, OrderCancelDiscountUpdateRequest> orderIdToOrderSyncRequestMap,
                                             Map<Long, DealDetail> orderToDealDetailMap){
        return orders.stream().map(o -> {

--- MyOrderServiceImpl | updateDoorStepDeliveryFee | CODE | 1/2 ---
    @Override
    public DoorStepDeliveryFeeUpdateResponseModel updateDoorStepDeliveryFee(DoorStepDeliveryFeeUpdate doorStepDeliveryFeeUpdate)
        throws JsonProcessingException {

        DoorStepDeliveryFeeUpdateResponseModel doorStepDeliveryFeeUpdateResponseModel = new DoorStepDeliveryFeeUpdateResponseModel();

        if(doorStepDeliveryFeeUpdate==null){
            log.error("Received empty body from ops for door step delivery Fee Update");
            return doorStepDeliveryFeeUpdateResponseModel;
        }
        if(ObjectUtils.isEmpty(doorStepDeliveryFeeUpdate.getDeliveryFee())||
            ObjectUtils.isEmpty(doorStepDeliveryFeeUpdate.getOrderIds())||
            ObjectUtils.isEmpty(doorStepDeliveryFeeUpdate.getShipmentId())){
            log.error("Received bad request from ops for door step delivery Fee Update");
            return doorStepDeliveryFeeUpdateResponseModel;
        }

        Optional<DoorStepCancellationsOnlineUpdate> alreadyUpdated =
            doorStepCancellationsOnlineUpdateRepository.findFirstByShipmentId(doorStepDeliveryFeeUpdate.getShipmentId());
        if(!ObjectUtils.isEmpty(alreadyUpdated)){
            return doorStepDeliveryFeeUpdateResponseModel;
        }

        List<Order> orderList = orderRepository.findByIdIn(doorStepDeliveryFeeUpdate.getOrderIds());
        Order orderToProcess = null;
        for(Order order: orderList){
            if(order.getAmount()>doorStepDeliveryFeeUpdate.getDeliveryFee()){
                orderToProcess = order;
                break;
            }
        }
        if(ObjectUtils.isEmpty(orderToProcess)){
            log.error("No order found with order value greater than delivery fee for request = {}",doorStepDeliveryFeeUpdate.toString());
            return doorStepDeliveryFeeUpdateResponseModel;
        }

        Optional<CartOrderMapping> cartOrderMapping = cartOrderMappingRepository.findFirstByOrderId(orderToProcess.getId());
        if(!cartOrderMapping.isPresent()){
            log.error("No cart order mapping found for this order id = {}",orderToProcess.toString());
            return doorStepDeliveryFeeUpdateResponseModel;
        }

        Optional<Cart> cart = cartRepository.findById(cartOrderMapping.get().getCartId());
        if(!cart.isPresent()){
            log.error("No cart found for this order id = {}",orderToProcess.toString());
            return doorStepDeliveryFeeUpdateResponseModel;
        }

        RefundAmountPaymentsUpdateModel refundAmountPaymentsUpdateModel = new RefundAmountPaymentsUpdateModel();
        refundAmountPaymentsUpdateModel.setDeliveryFee(doorStepDeliveryFeeUpdate.getDeliveryFee());

--- MyOrderServiceImpl | minimartOrderSync | CODE | 1/2 ---
    public OrderSyncResponseModel minimartOrderSync(OrderSyncRequestModel orderSyncRequestModel) {

        List<UserOrderSyncModel> userOrderSyncModelList = orderSyncRequestModel.getUserOrderSyncModelList();
        
        List<String> posOrderIds = userOrderSyncModelList.stream()
                .map(UserOrderSyncModel::getPosOrderId)
                .filter(Objects::nonNull)
                .distinct()
                .collect(Collectors.toList());
        
        List<String> acquiredLocks = new ArrayList<>();
        try {
            for (String posOrderId : posOrderIds.stream().sorted().collect(Collectors.toList())) {
                String lockKey = MINIMART_ORDER_SYNC_LOCK + posOrderId;
                acquireLock(lockKey, posOrderId);
                acquiredLocks.add(lockKey);
            }
        } catch (Exception e) {
            // Release all acquired locks if any lock acquisition fails
            releaseLocks(acquiredLocks);
            throw e;
        }

        OrderSyncResponseModel orderSyncResponseModel = new OrderSyncResponseModel();
        Map<String, List<OrderDealMappingModel>> posOrderOmsOrderMap = new HashMap<>();
        Map<String, String> ordersSyncStatusMap = new HashMap<>();

        List<String> posOrderIdList = userOrderSyncModelList.stream()
                .map(UserOrderSyncModel::getPosOrderId)
                .collect(Collectors.toList());

        List<POSOrderMapping> posOrderMappingList = posOrderMappingRepository.findByPosOrderIdIn(posOrderIdList);

        Set<String> posOrderIdSet = posOrderMappingList.stream()
                .map(POSOrderMapping::getPosOrderId)
                .collect(Collectors.toSet());

        List<UserOrderSyncModel> existingUserOrderSyncModelList = userOrderSyncModelList.stream()
                .filter(userOrderSyncModel -> posOrderIdSet.contains(userOrderSyncModel.getPosOrderId()))
                .collect(Collectors.toList());

        Map<String, List<POSOrderMapping>> posOrderMappingMap = posOrderMappingList.stream()
                .collect(Collectors.groupingBy(POSOrderMapping::getPosOrderId));

        posOrderIdSet.clear();

        for(UserOrderSyncModel userOrderSyncModel : existingUserOrderSyncModelList) {
            List<POSOrderMapping> posOrderMappings = posOrderMappingMap.get(userOrderSyncModel.getPosOrderId());

            List<OrderDealMappingModel> orderDealMappingModelList = getOrderDealMappingForExistingOrder(posOrderMappings,

--- MyOrderServiceImpl | updateDoorStepDeliveryFee | CODE | 2/2 ---
            return doorStepDeliveryFeeUpdateResponseModel;
        }

        RefundAmountPaymentsUpdateModel refundAmountPaymentsUpdateModel = new RefundAmountPaymentsUpdateModel();
        refundAmountPaymentsUpdateModel.setDeliveryFee(doorStepDeliveryFeeUpdate.getDeliveryFee());
        refundAmountPaymentsUpdateModel.setOrderId(orderToProcess.getId());
        ResponseEntity<?> response = null;

        try {
            response = paymentServiceClient
                .updateRefundAmount(refundAmountPaymentsUpdateModel, userName, password);
        }
        catch (Exception e){
            log.error("exception is {}",e.toString());
            return doorStepDeliveryFeeUpdateResponseModel;
        }

        cart.get().setDeliveryFee(doorStepDeliveryFeeUpdate.getDeliveryFee());
        cart.get().setCartConfigId(doorStepDeliveryFeeUpdate.getConfigId());
        cartRepository.save(cart.get());

        DoorStepCancellationsOnlineUpdate doorStepCancellationsOnlineUpdate = new DoorStepCancellationsOnlineUpdate();
        doorStepCancellationsOnlineUpdate.setDeliveryFee(doorStepDeliveryFeeUpdate.getDeliveryFee());
        doorStepCancellationsOnlineUpdate.setCancelledOrderIds(objectMapper.writeValueAsString(doorStepDeliveryFeeUpdate.getOrderIds()));
        doorStepCancellationsOnlineUpdate.setOrderId(orderToProcess.getId());
        doorStepCancellationsOnlineUpdate.setConfigId(doorStepDeliveryFeeUpdate.getConfigId());
        doorStepCancellationsOnlineUpdate.setShipmentId(doorStepDeliveryFeeUpdate.getShipmentId());

        doorStepCancellationsOnlineUpdateRepository.save(doorStepCancellationsOnlineUpdate);

        doorStepDeliveryFeeUpdateResponseModel.setStatus(Boolean.TRUE);
        return doorStepDeliveryFeeUpdateResponseModel;

--- MyOrderServiceImpl | minimartOrderSync | CODE | 2/2 ---

        for(UserOrderSyncModel userOrderSyncModel : existingUserOrderSyncModelList) {
            List<POSOrderMapping> posOrderMappings = posOrderMappingMap.get(userOrderSyncModel.getPosOrderId());

            List<OrderDealMappingModel> orderDealMappingModelList = getOrderDealMappingForExistingOrder(posOrderMappings,
                    userOrderSyncModel.getOfferIdOrderSummaryModelMap());

            if(!ObjectUtils.isEmpty(orderDealMappingModelList)) {
                posOrderIdSet.add(userOrderSyncModel.getPosOrderId());
                posOrderOmsOrderMap.put(userOrderSyncModel.getPosOrderId(), orderDealMappingModelList);
            }
        }

        userOrderSyncModelList = userOrderSyncModelList.stream()
                .filter(userOrderSyncModel -> !posOrderIdSet.contains(userOrderSyncModel.getPosOrderId()))
                .collect(Collectors.toList());

        for (UserOrderSyncModel userOrderSyncModel : userOrderSyncModelList) {

            UserInfoModel userInfoModel = userOrderSyncModel.getUserInfoModel();
            try {
                UserCacheModel userCacheModel = userService.getUser(userInfoModel);

                /** userCacheModel and userInfoModel pincode can be different if user is present in db already*/
                Long userAddressId = userAddressService.getUserAddress(userCacheModel).getId();

                List<OrderDealMappingModel> orderDealMappingModelList = userOrderService.syncOrders(userCacheModel,
                        userOrderSyncModel,
                        userAddressId);

                posOrderOmsOrderMap.put(userOrderSyncModel.getPosOrderId(), orderDealMappingModelList);
            } catch (Exception e) {
//                chatServiceClient.sendEmailToMultiple(CommonUtils.prepareEmailRequestModel(EmailSubject.MINIMART_ORDER_SYNC.getValue(), String.format("userOrderSyncModel : %s, Exception : %s", userOrderSyncModel, e)));
                ordersSyncStatusMap.put(userOrderSyncModel.getPosOrderId(), e.getMessage());
                log.error("Something went wrong in saving order : {}, Exception : {}", userOrderSyncModel, e.getMessage());
            }
        }
        orderSyncResponseModel.setPosOrderOmsOrderMap(posOrderOmsOrderMap);
        posOrderOmsOrderMap.keySet().forEach(posOrderId -> ordersSyncStatusMap.put(posOrderId, "Synced Successfully"));
        orderSyncResponseModel.setOrdersSyncStatusMap(ordersSyncStatusMap);

        releaseLocks(acquiredLocks);

        return orderSyncResponseModel;


=== ðŸ§© UnknownRepo â†’ UserShipmentServiceImpl.java ===

--- UserShipmentServiceImpl | calculateShipmentEta | CODE | 1/1 ---
    public void calculateShipmentEta(UserShipmentModel shipment, List<Order> orders){
        Boolean isLive = commonUtils.getEtaFlag(ETA_FLAG,ETA_FLAG);
        String eta = null;
        if(isLive){
            Order latestOrder = orders.stream()
                    .max(Comparator.comparing(Order::getId))
                    .orElse(null);
            eta = etaService.orderEta(latestOrder);
            if (eta != null) {
                try {
                    // Parse the string according to ETA_FORMAT_FROM_CACHE
                    shipment.setEtaFromCache(eta);
                    SimpleDateFormat inputFormat = new SimpleDateFormat(ETA_FORMAT_FROM_CACHE);
                    Date etaDate = inputFormat.parse(eta);
                    eta = commonUtils.formatEtaV2(etaDate);
                } catch (Exception e) {
                    eta = null;
                }
            }
        }
        if(eta == null){
            Optional<List<OrderHistory>> orderHistories = orderHistoryRepository.findByOrderId(orders.get(0).getId());
            eta = orderHistories
                    .flatMap(list -> list.stream()
                            .filter(oh -> OUT_FOR_DELIVERY.equalsIgnoreCase(oh.getStatus()))
                            .map(OrderHistory::getCreatedDate)
                            .filter(Objects::nonNull) // ensure no null date
                            .findFirst()
                    )
                    .map(commonUtils::formatEta)
                    .orElse(null);
        }
        if(eta == null || eta.isEmpty() ){


=== ðŸ§© UnknownRepo â†’ EtaServiceImpl.java ===

--- EtaServiceImpl | getOrderConfirmationEtaBufferConfig | CODE | 1/1 ---
    @Override
    public OrderConfirmationEtaBufferConfig getOrderConfirmationEtaBufferConfig(Integer warehouseId){
        return growthbookService.getOrderConfirmationEtaBufferConfig(warehouseId);

--- EtaServiceImpl | getStoreTimeConfigFromWarehouseEta | CODE | 1/1 ---
    public StoreTimeConfig getStoreTimeConfigFromWarehouseEta(Integer warehouseId) {
        
        StoreTimeConfig storeTimeConfig = new StoreTimeConfig();
        
        try {
            ResponseEntity<WarehouseEtaConfigResponseModel> response = etaServiceClient.getWarehouseEtaConfig(warehouseId);

            if (response.getStatusCode() == HttpStatus.OK && response.getBody() != null) {
                WarehouseEtaConfigResponseModel responseModel = response.getBody();

                if (Boolean.TRUE.equals(responseModel.getStatus()) && responseModel.getData() != null) {
                    LocalTime orderStartTime = responseModel.getData().getOrderStartTime();
                    LocalTime orderEndTime = responseModel.getData().getOrderEndTime();

                    // Convert time format from "HH:mm:ss" to "HH:mm"
                    String storeOpeningTime = CommonUtils.convertTimeFormat(orderStartTime != null ? orderStartTime.format(DateTimeFormatter.ofPattern("HH:mm:ss")) : null);
                    String storeClosingTime = CommonUtils.convertTimeFormat(orderEndTime != null ? orderEndTime.format(DateTimeFormatter.ofPattern("HH:mm:ss")) : null);

                    storeTimeConfig.setStoreOpeningTime(storeOpeningTime);
                    storeTimeConfig.setStoreClosingTime(storeClosingTime);

                    return storeTimeConfig;
                } else {
                    log.warn("ETA service returned unsuccessful status for warehouseId: {}", warehouseId);
                }
            } else {
                log.warn("Invalid response from ETA service for warehouseId: {}, status: {}", 
                        warehouseId, response.getStatusCode());
            }
        } catch (Exception e) {
            log.error("Error fetching warehouse ETA config for warehouseId: {}, error: {}", 
                    warehouseId, e.getMessage(), e);
        }
        
        // Fallback to default values if warehouse config is not available
        log.warn("Warehouse ETA config not available for warehouseId: {}, using default values", warehouseId);
        storeTimeConfig.setStoreOpeningTime(DELIVERY_STARTING_HOUR_FOR_STORE);
        storeTimeConfig.setStoreClosingTime(DELIVERY_ENDING_HOUR_FOR_STORE);
        
        return storeTimeConfig;

--- EtaServiceImpl | updateCacheForCancelledOrders | CODE | 1/1 ---
    public List<OrderStatusWidgetCacheUpdateModel> updateCacheForCancelledOrders(Order order){
        if(order == null){
            return null;
        }
        OrderStatusWidgetCacheUpdateModel model = new OrderStatusWidgetCacheUpdateModel();
        model.setOrderId(order.getId());
        model.setUserId(order.getUserId());
        model.setStatus(order.getOrderStatus());
        return Collections.singletonList(model);

--- EtaServiceImpl | updateOrderStatusWidgetCacheAsync | CODE | 1/1 ---
    @Async
    public CompletableFuture<Void> updateOrderStatusWidgetCacheAsync(List<OrderStatusWidgetCacheUpdateModel> orderStatusWidgetCacheUpdateModelList) {
        orderServiceClient.updateOrderStatusWidgetCache(orderStatusWidgetCacheUpdateModelList);
        return CompletableFuture.completedFuture(null);


=== ðŸ§© UnknownRepo â†’ CartServiceV2Impl.java ===

--- CartServiceV2Impl | triggerOrderPlacedEvent | CODE | 1/1 ---
    private void triggerOrderPlacedEvent(CartOrderModel responseCartOrderModel){
        List<Long> orderIds = new ArrayList<>();
        responseCartOrderModel.getCartItems()
                .forEach(cartItem -> orderIds.add(cartItem.getOrderPKId()));
        OrdersStatusUpdateEvent ordersStatusUpdateEvent = new OrdersStatusUpdateEvent();
        ordersStatusUpdateEvent.setOrderIds(orderIds);
        ordersStatusUpdateEvent.setEvent(UserRankUpdateEvent.ORDER_PLACED.toString());
        queueProducer.sendOrdersStatusUpdateTopic(ordersStatusUpdateEvent);

        UserRankTransitionRequestModel userRankTransitionRequestModel = UserRankTransitionRequestModel.builder()
                .userId(responseCartOrderModel.getUserId())
                .event(UserRankUpdateEvent.ORDER_PLACED.toString())
                .build();

        try {

--- CartServiceV2Impl | syncDeliveryFees | CODE | 1/1 ---
    @Transactional
    public Boolean syncDeliveryFees(List<SyncDeliveryFeesModel> syncDeliveryFeesModels){
        List<Long> cartIds = syncDeliveryFeesModels.stream().map(SyncDeliveryFeesModel::getCartId).distinct().collect(Collectors.toList());
        Map<Long, Long> cartDeliveryFeeMap;
        cartDeliveryFeeMap = syncDeliveryFeesModels.stream().collect(Collectors.toMap(SyncDeliveryFeesModel::getCartId, SyncDeliveryFeesModel::getDeliveryFees));
        List<Cart> carts = cartRepository.findAllById(cartIds);
        if(!carts.isEmpty()) {
            for(Cart cart:carts){
                cart.setDeliveryFee(cartDeliveryFeeMap.get(cart.getId()).intValue());
            }
            cartRepository.saveAll(carts);
        }
        return true;

--- CartServiceV2Impl | getTitleAndGradientFromEtaDateV2 | CODE | 1/2 ---
    private EtaDisplayData getTitleAndGradientFromEtaDateV2(OrderStatusWidgetStaticModel orderStatusWidgetStaticModel,
                                                    LocalDateTime eta, String lang, Integer warehouseId) {
        EtaDisplayData etaDisplayData = new EtaDisplayData();
        try {
            LocalDate orderETADate = eta.toLocalDate();
            LocalTime orderETATime = eta.toLocalTime();
            LocalDate currentDate =  LocalDate.now();
            LocalDate nextDate = currentDate.plusDays(1);

            OrderConfirmationEtaBufferConfig etaBuffer = etaService.getOrderConfirmationEtaBufferConfig(warehouseId);
            if (Objects.isNull(etaBuffer.getHours()) || etaBuffer.getHours().equals(0L)) {
                etaBuffer.setEnable(true);
                etaBuffer.setHours(1L);
            }

            TomorrowEtaWarehouseConfig etaTomorrow = etaService.getTomorrowEtaWarehouseConfig(warehouseId);

            if (orderETADate.isEqual(currentDate)) {
                EtaDisplayData etaDisplayData1 = getETAResponse(orderStatusWidgetStaticModel.getArrivingToday(),
                        orderETATime,orderStatusWidgetStaticModel.getToday()
                        , etaBuffer, lang, orderStatusWidgetStaticModel);
                return etaDisplayData1;
            } else if (orderETADate.isEqual(nextDate)) {
                if (etaTomorrow.isEnable()) {
                    return getETAResponse(orderStatusWidgetStaticModel.getArrivingTomorrow(),
                            orderETATime, orderStatusWidgetStaticModel.getTomorrow(),
                            etaBuffer, lang, orderStatusWidgetStaticModel);
                } else {
                    etaDisplayData.setTitle(CommonUtils.getValueFromMapByLang(orderStatusWidgetStaticModel.getArrivingTomorrow(), lang));
                    etaDisplayData.setEtaTitle(CommonUtils.getValueFromMapByLang(orderStatusWidgetStaticModel.getArrivingTomorrow(), lang));
                    return etaDisplayData;
                }

            } else if (orderETADate.isAfter(nextDate)) {
                // etaString is replaced by etaDate (need to modify etaDate to match etaString format)
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(stringToDateFormat, Locale.ENGLISH); // Adjust format as needed
                etaDisplayData.setEtaTitle(CommonUtils.getValueFromMapByLang(orderStatusWidgetStaticModel.getArrivingOn(), lang)
                        + orderETADate.format(formatter));
                etaDisplayData.setTitle(CommonUtils.getValueFromMapByLang(orderStatusWidgetStaticModel.getArrivingOn(), lang)
                        + orderETADate.format(formatter));
                return etaDisplayData;

            }
        } catch (Exception e) {
            log.error("Fetching title from eta date {}, input- staticModel: {}, deliveryDateTime: {}, lang: {}",
                    e.getMessage(), orderStatusWidgetStaticModel, eta, lang);
        }
        return etaDisplayData;

--- CartServiceV2Impl | getTitleAndGradientFromEtaDateV2 | CODE | 2/2 ---
                    e.getMessage(), orderStatusWidgetStaticModel, eta, lang);
        }
        return etaDisplayData;


=== ðŸ§© UnknownRepo â†’ UserOrderCartServiceImpl.java ===

--- UserOrderCartServiceImpl | setModifiedDate | CODE | 1/1 ---
    private void setModifiedDate(OrderListModel orderListModel, Order order){
        DateFormat dateFormat = new SimpleDateFormat("dd MMM");
        String fetchModifiedDate = dateFormat.format(order.getModifiedDate());
        orderListModel.setDeliveryDate(fetchModifiedDate);

--- UserOrderCartServiceImpl | setOrderedDate | CODE | 1/1 ---
    private void setOrderedDate(OrderListModel orderListModel,Order order){
        DateFormat dateFormat = new SimpleDateFormat("MMMMM dd, hh:mm:aa");
        String dateString = dateFormat.format(order.getOrderDate());
        orderListModel.setOrderedDate(dateString);


=== ðŸ§© UnknownRepo â†’ UserOrderServiceImpl.java ===

--- UserOrderServiceImpl | getOrderTracking | CODE | 1/1 ---
    @Override
    public List<OrderTrackingModel> getOrderTracking(Long orderId, String authkey) {
        List<OrderTrackingModel> orderTrackingModels = new ArrayList<>();
        Optional<List<OrderHistory>> orders = orderHistoryRepository.findByOrderId(orderId);
        if (orders.isPresent()) {
            {
                for (OrderTrackingType orderTrackingType : OrderTrackingType.values()) {
                    OrderTrackingModel orderTrackingModel = new OrderTrackingModel();
                    for (OrderHistory orderHistory : orders.get()) {
                        if (orderHistory.getStatus().equalsIgnoreCase(orderTrackingType.toString())) {
                            orderTrackingModel.setStatus(orderTrackingType.toString());
                            orderTrackingModel.setUpdatedAt(setOrderTrackingDate(orderHistory));
                            orderTrackingModel.setStageChanged(true);
                            break;
                        } else {
                            orderTrackingModel.setStatus(orderTrackingType.toString());
                            orderTrackingModel.setUpdatedAt(setOrderTrackingDate(orderHistory));
                            orderTrackingModel.setStageChanged(false);
                        }
                    }
                    orderTrackingModels.add(orderTrackingModel);
                }
            }
        } else {
            throw new ValidationException("Order not found in Order History");
        }
        return orderTrackingModels;

--- UserOrderServiceImpl | createOrderHistory | CODE | 1/1 ---
    private OrderHistory createOrderHistory(Order order, Date cancellationTime) {
        return new OrderHistory(order, cancellationTime,

--- UserOrderServiceImpl | updateOrderIdAndTransactionIdInOrderEntity | CODE | 1/1 ---
    private void updateOrderIdAndTransactionIdInOrderEntity(List<Order> orderList) {
        orderList.forEach(order -> {
            Long id = order.getId();
            order.setTransactionId(id);
            order.setOrderId(ORDER_ID_PREFIX + id);
        });
        orderRepository.saveAll(orderList);

--- UserOrderServiceImpl | discardOrders | CODE | 1/2 ---
    public byte[] discardOrders(MultipartFile file) throws Exception {
        List<OrderStatusUpdateDTO> orderDTOs = parseOrderFile(file);
        if(orderDTOs.size() >= 100 ){
            throw new ValidationException("You can only update 100 orders at a time, can you please update a new file.");
        }
        List<Long> orderIds = orderDTOs.stream()
                .map(OrderStatusUpdateDTO::getOrderId)
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
        List<Order> orders = orderRepository.findByIdIn(orderIds);
        Map<Long, Order> orderIdToOrder = orders.stream()
                .filter(Objects::nonNull)
                .collect(Collectors.toMap(Order::getId, order -> order));
        Map<Long, Order> result = orderIds.stream()
                .filter(orderIdToOrder::containsKey)
                .collect(Collectors.toMap(
                        id -> id,
                        orderIdToOrder::get
                ));
        List<Order> orderToUpdate = new ArrayList<>();
        for(OrderStatusUpdateDTO orderDTO : orderDTOs){
            if(orderDTO.getOrderId() == null){
                orderDTO.setTechRemarks("Order id is null");
            }
            else if(!orderDTO.getStatus().equalsIgnoreCase("discarded")){
                orderDTO.setTechRemarks("Cannot update the status to : "+orderDTO.getStatus());
            }
            else if(orderDTO.getComments() == null || orderDTO.getComments().isEmpty()){
                orderDTO.setTechRemarks("Reason / Remark cannot be empty to discard the order, Please try again with Valid Reason");
            }
            else if(orderDTO.getSubStatus() == null || orderDTO.getSubStatus().isEmpty()){
                orderDTO.setTechRemarks("Substatus cannot be empty to discard the order, Please try again with Valid subStatus");
            }
            else{
                if (result == null || result.get(orderDTO.getOrderId()) == null){
                    orderDTO.setTechRemarks("Order doesn't exist with this id");
                    continue;
                }
                Order order = result.get(orderDTO.getOrderId());
                if(!order.getOrderStatus().equals(CANCEL_STATUS)){
                    if(order.getOrderStatus().equals(DISCARD_STATUS)){
                        orderDTO.setTechRemarks("Order is already in Discard status");
                    }else{
                        orderDTO.setTechRemarks("Order is not in cancel state");
                    }
                }else{
                    order.setOrderStatus(DISCARD_STATUS);
                    order.setOrderSubStatus(orderDTO.getSubStatus());
                    order.setComments(orderDTO.getComments());
                    orderDTO.setTechRemarks(DONE);

--- UserOrderServiceImpl | discardFlaggedOrders | CODE | 1/2 ---
    public void discardFlaggedOrders(Long userId, Long cartId) {
        if (cartId > 0) {
//            log.error("Discard is blocked as of now userId {} cartId {}", userId, cartId);
            return;
        }

        cartRepository.findCartByIdAndUserId(cartId, userId)
                .orElseThrow(() -> new ValidationException("Cart not found for the given user."));

        List<CartOrderMapping> cartOrderMappings = cartOrderMappingRepository.findByCartId(cartId)
                .orElseThrow(() -> new ValidationException("No orders found for the given cart."));

        List<Long> orderIds = cartOrderMappings.stream()
                .map(CartOrderMapping::getOrderId)
                .collect(Collectors.toList());

        List<Order> orders = orderRepository.findAllById(orderIds);
        if (orders.isEmpty()) {
            throw new ValidationException("Orders not found for the given cart.");
        }

        for (Order order : orders) {
            if (order.getOrderStatus().equals(DISCARD_STATUS)) {
                log.warn("discardFlaggedOrders Order {} is already in discard status, skipping.", order.getId());
                continue;
            }

            if (order.getOrderStatus().equals(CANCEL_STATUS)) {
                log.warn("discardFlaggedOrders Order {} is already in cancel status, skipping.", order.getId());
                continue;
            }

            OrderCancelModel cancelModel = createOrderCancelModel(
                    order.getId(), order.getUserId(), order.getSource(), CANCEL_BY_SYSTEM, "Flagged Abuse Users"
            );

            try {
                myOrderService.cancelOrder(cancelModel, order.getUserId(), null, true);
                myOrderService.triggerOrderCancelEventSyncCall(order.getUserId(),cancelModel);
            } catch (Exception | ValidationExceptionV2 ex) {
                log.error("discardFlaggedOrders Failed to cancel order {}: {}", order.getId(), ex.getMessage(), ex);
            }

            order.setComments("Flagged Abuse Users");
            order.setOrderSubStatus(CANCEL_BY_SYSTEM);
            order.setOrderStatus(DISCARD_STATUS);
        }

        orderRepository.saveAll(orders);

--- UserOrderServiceImpl | syncOrders | CODE | 1/4 ---
    @Override
    @Transactional
    public List<OrderDealMappingModel> syncOrders(UserCacheModel userCacheModel,
                                                  UserOrderSyncModel userOrderSyncModel,
                                                  Long userAddressId) {

        List<OrderSummaryModel> orderSummaryModelList = new ArrayList<>(userOrderSyncModel.getOfferIdOrderSummaryModelMap().values());

        boolean newCart = isNewCartRequired(orderSummaryModelList);

        Long cartId = null;
        if (newCart) {
            cartId = createCart(userCacheModel.getId());
        }

        List<SkuInventoryUpdateModel> skuInventoryUpdateModelList = new ArrayList<>();

        List<Order> orderList = new ArrayList<>();

        for (OrderSummaryModel orderSummaryModel : orderSummaryModelList) {
            String status = orderSummaryModel.getStatus();
            switch (status) {

                case AppConstant.DELIVERED:
                    orderList.add(createOrder(orderSummaryModel,
                            userCacheModel,
                            userOrderSyncModel.getPaymentType(),
                            userOrderSyncModel.getSource(),
                            userAddressId,
                            userOrderSyncModel.getWarehouseId()));

                    /** update inventory */
                    skuInventoryUpdateModelList.addAll(createUpdateInventoryModel(orderSummaryModel.getOrderProductDetailModel(), Boolean.TRUE));
                    break;

                case AppConstant.CANCEL_STATUS:
                    /** update order status*/
                    if (orderSummaryModel.getIsOrderPresent()) {
                        Optional<Order> presentOrder = orderRepository.findById(orderSummaryModel.getOrderId());
                        if (presentOrder.isPresent()) {
                            if (cartId == null) {
                                cartId = cartOrderMappingRepository.findFirstByOrderId(presentOrder.get().getId()).get().getCartId();
                            }

                            presentOrder.get().setOrderStatus(AppConstant.CANCEL_STATUS);
                            orderList.add(presentOrder.get());
                        } else {
                            log.error("Order Mapping present in pos_order_mapping table but in order table : {}", orderSummaryModel);
                        }


--- UserOrderServiceImpl | discardOrders | CODE | 2/2 ---
                }else{
                    order.setOrderStatus(DISCARD_STATUS);
                    order.setOrderSubStatus(orderDTO.getSubStatus());
                    order.setComments(orderDTO.getComments());
                    orderDTO.setTechRemarks(DONE);
                    orderToUpdate.add(order);
                }
            }
        }
        orderRepository.saveAll(orderToUpdate);
        byte[] bite = generateCsvFile(orderDTOs);
        emailSenderService.sendEmailWithAttachment(
                DISCARD_ORDER_EMAIL_LIST,
                DISCARD_ORDER_SUBJECT,
                DISCARD_ORDER_CONTENT,
                DISCARD_ORDER_FILE_NAME,
                bite
        );
        return bite;

--- UserOrderServiceImpl | discardFlaggedOrders | CODE | 2/2 ---
            order.setOrderStatus(DISCARD_STATUS);
        }

        orderRepository.saveAll(orders);

--- UserOrderServiceImpl | syncOrders | CODE | 2/4 ---
                            orderList.add(presentOrder.get());
                        } else {
                            log.error("Order Mapping present in pos_order_mapping table but in order table : {}", orderSummaryModel);
                        }

                        /**  update inventory */
                        skuInventoryUpdateModelList.addAll(createUpdateInventoryModel(orderSummaryModel.getOrderProductDetailModel(), Boolean.FALSE));
                    } else {
                        /** create order with cancel status*/
                        orderList.add(createOrder(orderSummaryModel,
                                userCacheModel,
                                userOrderSyncModel.getPaymentType(),
                                userOrderSyncModel.getSource(),
                                userAddressId,
                                userOrderSyncModel.getWarehouseId()));
                    }
                    break;
            }
        }

        List<Order> orders = orderRepository.saveAll(orderList);
        List<Order> cancelOrders = orders.stream().filter(order -> CANCELLED.getValues().contains(order.getOrderStatus())).collect(
                Collectors.toList());
        List<InvoiceCancelDto> invoiceCancelList = new ArrayList<>();
        try {
            if (!CollectionUtils.isEmpty(cancelOrders)) {
                List<BtocInvoiceDetails> btocInvoiceDetails =
                        btocInvoiceDetailsRepository.findByOrderIdIn(
                                cancelOrders.stream().map(Order::getId).collect(
                                        Collectors.toSet()));
                Map<Long, List<BtocInvoiceDetails>> btocInvoiceDetailsMap =
                        btocInvoiceDetails.stream()
                                .collect(Collectors.groupingBy(BtocInvoiceDetails::getInvoiceId));
                for (Map.Entry<Long, List<BtocInvoiceDetails>> entry :
                        btocInvoiceDetailsMap.entrySet()) {

                    InvoiceCancelDto invoiceCancelDto = new InvoiceCancelDto();
                    invoiceCancelDto.setBtocInvoiceId(entry.getKey().toString());
                    invoiceCancelDto.setOrders(
                            entry.getValue().stream().map(BtocInvoiceDetails::getOrderId).collect(
                                    Collectors.toList()));
                    invoiceCancelList.add(invoiceCancelDto);
                }
                if (!CollectionUtils.isEmpty(invoiceCancelList)) {
                    invoiceServiceClient.minimartOrderCancelInvoice(invoiceCancelList);
                }
            }
        } catch (Exception e) {
            log.error("error occurred while issuing cancel invoice, {}", invoiceCancelList);
        }

--- UserOrderServiceImpl | syncOrders | CODE | 3/4 ---
                }
            }
        } catch (Exception e) {
            log.error("error occurred while issuing cancel invoice, {}", invoiceCancelList);
        }

        List<OrderDealMappingModel> orderDealMappingModelList = new ArrayList<>();
        List<OrderHistory> orderHistoryList = new ArrayList<>();


        List<CartDetails> cartDetailsList = new ArrayList<>();
        List<CartOrderMapping> cartOrderMappingList = new ArrayList<>();
        List<OrderProductDetails> orderProductDetailsList = new ArrayList<>();
        List<OrderDiscountingHistory> orderDiscountingHistoryList = new ArrayList<>();
        List<POSOrderMapping> posOrderMappingList = new ArrayList<>();

        int i = 0;
        for (Order order : orderList) {
            OrderSummaryModel orderSummaryModel = orderSummaryModelList.get(i++);
            OrderProductDetailModel orderProductDetailModel = orderSummaryModel.getOrderProductDetailModel();
            OrderPricingModel orderPricingModel = orderSummaryModel.getOrderPricingModel();
            List<OrderDiscountModel> orderDiscountBifurcation=orderSummaryModel.getOrderDiscountBifurcation();
            if (newCart) {
                cartDetailsList.add(createCartDetails(orderProductDetailModel, cartId));
                cartOrderMappingList.add(createCartOrderMapping(order.getId(), cartId));

                orderProductDetailsList.addAll(createOrderProductDetails(order.getId(),
                        orderPricingModel.getMrp(),
                        userOrderSyncModel.getWarehouseId(),
                        orderProductDetailModel, userOrderSyncModel.getPosOrderId()));

                if (orderDiscountBifurcation.size() > 0) {
                    orderDiscountingHistoryList.addAll(orderDiscountBifurcation.stream().map(discountModel -> createDiscountingHistory(discountModel,order.getId())).collect(
                            Collectors.toList()));
                }
            }

            if (order.getOrderStatus().equalsIgnoreCase(AppConstant.CANCEL_STATUS)) {
                orderHistoryList.add(createOrderHistory(order, orderSummaryModel.getTransactionTime()));
            }

            orderDealMappingModelList.add(
                    createOrderDealMappingModel(order, orderSummaryModel.getIsOrderPresent(), orderProductDetailModel.getSkus(), cartId));

            POSOrderMapping posOrderMapping = POSOrderMapping.builder()
                    .posOrderId(userOrderSyncModel.getPosOrderId())
                    .orderId(order.getId())
                    .status(OrderStatus.valueOf(order.getOrderStatus()))
                    .offerId(orderProductDetailModel.getOfferId())
                    .orderDate(order.getOrderDate())

--- UserOrderServiceImpl | syncOrders | CODE | 4/4 ---
                    .posOrderId(userOrderSyncModel.getPosOrderId())
                    .orderId(order.getId())
                    .status(OrderStatus.valueOf(order.getOrderStatus()))
                    .offerId(orderProductDetailModel.getOfferId())
                    .orderDate(order.getOrderDate())
                    .cartId(cartId)
                    .build();
            posOrderMappingList.add(posOrderMapping);
        }

        if (!cartDetailsList.isEmpty())
            cartDetailsRepository.saveAll(cartDetailsList);
        if (!cartOrderMappingList.isEmpty())
            cartOrderMappingRepository.saveAll(cartOrderMappingList);
        if (!orderProductDetailsList.isEmpty()) {
            orderProductDetailsRepository.saveAll(orderProductDetailsList);
            try {
                orderProductDetailsList.stream().map(CommonUtils::getSqsWabpModel)
                        .forEach(sqsWabpModel -> {
//                        log.error("Message Published for Wabp/Promo Order update: {}",
//                            sqsWabpModel);
                            sqsPublisherService.publishMessage(wabpOrderUpdateQueue,
                                    sqsWabpModel);
                        });
            } catch (Exception ex) {
                log.error("Error occurred while message publish for Wabp Order update: {}",
                        orderProductDetailsList);
            }
        }
        if (!orderDiscountingHistoryList.isEmpty())
            orderDiscountingHistoryRepository.saveAll(orderDiscountingHistoryList);
        if (!orderHistoryList.isEmpty())
            orderHistoryRepository.saveAll(orderHistoryList);
        if (!posOrderMappingList.isEmpty()) {
            posOrderMappingRepository.saveAll(posOrderMappingList);
        }


        updateInventory(skuInventoryUpdateModelList, userOrderSyncModel.getWarehouseId(), cartId);
        updateOrderIdAndTransactionIdInOrderEntity(orderList);
        return orderDealMappingModelList;


=== ðŸ§© UnknownRepo â†’ KafkaProducer.java ===

--- KafkaProducer | sendOrdersStatusUpdateTopic | CODE | 1/1 ---
    @Async
    @Override
    public void sendOrdersStatusUpdateTopic(OrdersStatusUpdateEvent ordersStatusUpdateEvent) {
        try {

--- KafkaProducer | sendOrderPlacedUserSMSCommunicationEvent | CODE | 1/1 ---
    @Async
    @Override
    public void sendOrderPlacedUserSMSCommunicationEvent(OrderUpdateEventDetail orderUpdateEventDetail) {
        try {


=== ðŸ§© UnknownRepo â†’ UserCartServiceImpl.java ===

--- UserCartServiceImpl | CreateOrderWidgetModel | CODE | 1/1 ---
    public EtaWidgetModel CreateOrderWidgetModel(List <Order> orders, String lang){
        EtaWidgetModel etaWidgetModel = EtaWidgetModel.builder().icon("https://images.dealshare.in/1753346135502fi_17124525.png?tr=f-webp").etaTitle("Arriving Soon").build();
        Boolean isLive = getEtaFlag(ETA_FLAG,ETA_FLAG);
        String eta = null;
        try{
            if(isLive){
                Order latestOrder = orders.stream()
                        .max(Comparator.comparing(Order::getId))
                        .orElse(null);
                eta = etaService.orderEta(latestOrder);
                etaWidgetModel.setEtaFromCache(eta);
                SimpleDateFormat inputFormat = new SimpleDateFormat(ETA_FORMAT_FROM_CACHE);
                try {
                    Date date = inputFormat.parse(eta);
                    eta = commonUtils.formatEtaV2(date);
                } catch (Exception e) {
                    eta = null;
                }
            }
            if(eta != null){
                etaWidgetModel.setEtaTitle(ARRIVING);
                etaWidgetModel.setEtaData(eta);
            }else{
                List<Long> ordersList = orders.stream().map(Order::getId).collect(Collectors.toList());
                OrderStatusWidgetStaticModel staticModel = commonUtils.getOrderStatusWidgetFromStaticProperties(ENGLISH);
                ZonedDateTime cartETA = etaService.getEarliestCeiledDeliveryHour(ordersList);
                String finalTitle = etaService.formatDeliveryEta(staticModel,cartETA, lang);
                etaWidgetModel.setEtaTitle(CommonUtils.getValueFromMapByLang(staticModel.getArrivingBy(), lang));
                etaWidgetModel.setEtaData(finalTitle);
            }

        }catch(Exception e){
            log.error("Exception in CreateOrderWidgetModel: {}", e.getMessage(), e);
        }
        return etaWidgetModel;
